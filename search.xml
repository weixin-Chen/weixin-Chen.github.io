<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nodeJs]]></title>
    <url>%2F2018%2F07%2F22%2Fnode%2F</url>
    <content type="text"><![CDATA[安装下载教程环境配置在node目录中创建两个文件夹【node_global】及【node_cache】运行=&gt;cmd npm config set prefix “D:\nodeJs\node_global”npm config set cache “D:\nodeJs\node_cache” 在【系统变量】下新建【NODE_PATH】，输入【D:\nodeJs\node_modules】，将【用户变量】下的【Path】修改为【D:\nodeJs\node_global】 安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用cnpm！cnpm安装的模块路径比较奇怪，packager不能正常识别！淘宝镜像 npm config set registry https://registry.npm.taobao.org –globalnpm config set disturl https://npm.taobao.org/dist –global 模块化在node中,一个js 就是一个模块 模块化―― npm：NodeJS Package Manager(NodeJS包管理器)1.系统模块：http、querystring、url2.自定义模块3.包管理器 系统模块： 断言： www.baidu.comgetServer Crypto 加密Events 事件Net 网络操作OS 操作系统信息Path 处理文件路径Stream 流操作Timers 定时器ZLIB 压缩1234567891011121314151617181920212223console.log(arguments.callee+"") //每一个js文件都有一个函数包着//输出结果:function (exports, require, module, __filename, __dirname)&#123; console.log(arguments.callee+"")&#125;console.log(arguments[3]) __filename //E:\WebStorm\webProject\node\test2.js 完整路径console.log(arguments[4]) __dirname//E:\WebStorm\webProject\node 路径console.log(module.exports==exports) //true//创建demo.js 对外输出 exports.a=12;//批量输出 module.exports=&#123; xxx: ??, xxx: ??, xxx: ??&#125;;//引入自定的模块 const demo =require('./demo.js') npm命令 npm init 初始化管理包 方便下载 npm publish 发布(在npm官网查找) npm update name 升级 npm unpublish 删除 npm –force unpublish 删除上一个版本 创建本地服务器 npm install http-server -ghttp-server -p 8801 在有index.html 目录下运行 使用基础模块HTTP1234567891011121314151617181920212223const http=require('http');var server=http.createServer(function (req, res)&#123; switch(req.url)&#123; case '/1.html': res.write("111111"); break; case '/2.html': res.write("2222"); break; default: res.write('404'); break; &#125; res.end();&#125;);//监听——等着//端口-数字server.listen(8080);//http://localhost:8080/ 页面显示404 fshttp://nodejs.cn/api/fs.html 打开文件 同步fs.openSync(path,flag[,mode]) -path要打开文件的路径 -flags 打开文件要做的操作 r 只读的 w 可写的 -mode 设置文件的操作权限,一般不传 返回值: -该方法会返回一个文件的描符作为结果,我们可以通过描述符来对文件进行各种操作 向文件写入内容fs.writeSync(fd, string[, position[, encoding]]) -fd 文件的描述符 需要传递要写入的描述符 -string 要写入的内容 -position 写入的起始位置 -encoding写入的编码,默认utf-8fs.write() 的同步版本。返回写入的字节数 保存并关闭文件fs.closeSync(fd) -fd 要关闭的文件的描述符 例子:123456789let fs =require('fs')//1.打开文件let fd=fs.openSync('test.txt','w')//console.log(fd); //3//2. 向文件写入内容fs.writeSync(fd,"输入内容2333",20)//3.关闭文件fs.closeSync(fd) 异步文件写入1234567891011121314151617181920// 异步打开 不会阻塞代码fs.open('test.txt','w',function(err,fd)&#123; if(!err)&#123; console.log(fd) //3 //写入 fs.write(fd,'这是异步写入的内容',function(err,written,string)&#123; if(!err)&#123; console.log('写入成功~~') &#125; //关闭 fs.close(fd,function(err)&#123; if(!err)&#123; console.log('文件已关闭~~') &#125; &#125;) &#125;) &#125;else&#123; console.log(err) &#125;&#125;) 文件操作：fs——File System异步 vs 同步异步——多个操作可以同时进行，前一次的操作没完事，后一次也能开始同步——一次一个 读写模式123456789101112131415const fs=require('fs');//读取//readFile(文件名, 回调函数)fs.readFile('aaa.txt', function (err, data)&#123; if(err)&#123; console.log('读取失败'); &#125;else&#123; console.log(data.toString()); &#125;&#125;);//writeFile(文件名, 内容, 回调)fs.writeFile("bbb.txt", "输入内容会覆盖", function (err)&#123; console.log(err); //null(没错误)&#125;); 流式写入同步,异步 简单的文件写入都不适合大文件的写入,性能比较差,容易导致内存溢出fs.WriteStream(path,[,options]) -可以用来创建一个可写流 -path,文件路径 -options 配置的参数 例子1234567891011121314151617let fs =require('fs')let ws = fs.createWriteStream('test.txt');// 可以通过监听流的open和close事件来监听流的打开和关闭//触发一次ws.once('open',function()&#123; console.log('流打开了~~')&#125;)// 通过ts向文件中输入内容 (多次)ws.write("通过可写流写入文件的内容")ws.write("今天天气不错的")ws.write("锄禾日当午")ws.write("汗滴禾下土")// 关闭流ws.end() //ws.close() 异步关闭 读取流式文件读取也适用于一些比较大的文件,可以分多次将文件读取到内存中流式复制12345678910111213141516171819202122232425262728293031323334353637let fs =require('fs')//可读流let rs =fs.createReadStream('test.gif')//写入流let ws =fs.createWriteStream('test-copy.gif')rs.once('open',function()&#123; console.log('可读流打开了');&#125;)rs.once('close',function()&#123; console.log('可读流关闭了'); ws.end()&#125;)ws.once('open',function()&#123; console.log('可写流打开了');&#125;)ws.once('close',function()&#123; console.log('可写流关闭了');&#125;)// 要绑定data事件完毕,才会读取数据// rs.on('data',(data)=&gt;&#123; //文件大可以多次读取// // console.log(data); //文件小,只读一次 大的每次最多读data.length=65536// ws.write(data)// &#125;)//简单的写法rs.pipe(ws)//顺序//可读流打开了//可写流打开了//可读流关闭了//可写流关闭了 复制123456789101112131415let fs =require('fs')fs.readFile('E:/桌面/timg.gif',function(err,data)&#123; if(err)&#123; console.log('读取失败'); &#125;else&#123; fs.writeFile('E:/WebStorm/webProject/node/文件系统/test.gif',data,(err)=&gt;&#123; if(!err)&#123; console.log('写入成功') &#125;else&#123; console.log(err); &#125; &#125;) &#125;&#125;) 其他其他操作 验证路径是否存在fs.exists(path,callback)fs.existsSync(path) 获取文件信息fs.stat(path,callback)fs.statSync(path) 删除文件fs.unlink(path,callback)fs.unlinkSync(path) 列出文件fs.readdir(path,[,options],callback)fs.readdirSync(path[,options]) 截断文件fs.truncate(path,len,callback)fs.truncateSync(path,len) 建立目录fs.mkdir(path[,mode],callback)fs.mkdirSync(path[,mode]) 判断文件是否存在123// fs.existsSync(path) 检查一个路径是否存在var isExists=fs.existsSync("a123.mp3") //没有console.log(isExists) //false 获取文件的状态属性123456789101112 // fs.stat(path,callback) // fs.statSync(path) // -获取文件的状态 // -它会给我们返回一个对象,这个对象中保存了当前 // 对象状态的相关信息fs.stat('test.txt',function(err,stat)&#123; // size 文件的大小 //isFile() 是否是一个文件 console.log(stat.size); console.log(stat.isFile());// true 必须有这个文件或文件夹&#125;) 删除文件12345// fs.unlink(path,callback)// fs.unlinkSync(path,callback) // -删除文件fs.unlinkSync('hello.txt') 截断文件内容长度1234// fs.truncate(path,len,callback)// fs.truncateSync(path,len)// - 截断文件,将文件修改为指定的大小fs.truncateSync('hello.txt',10) 删除目录12345678910// fs.mkdir(path[,mode],callback)// fs.mkdirSync(path[,mode])// -创建目录//// fs.mkdir(path,callback)// fs.rmdirSync(path)// -删除一个目录fs.mkdirSync('hello')fs.rmdirSync('hello') 重命名或者剪切文件12345678910111213// fs.rename(oldPath,newPath,callback)// fs.renameSync(oldPath,newPath)// -对文件进行重名名// -参数:// oldPath 旧路径// newPath 新路径// callback 回调函数fs.rename('a.mp3','b.mp3',function(err)&#123; if(!err)&#123; console.log("修改成功"); &#125;&#125;) 监听文件的变化1234567891011121314// fs.watchFile(fliename[,option],listener)// - 监视文件的修改// - 参数:// filename 要监视的文件的名字// options 配置选项 检测的时间// listener 回调函数,当文件发生变化时,回调函数会执行// 在回调函数中有两个参数:// curr 当前文件的状态// prev 修改文件的状态// - 这两个对象都是stats对象fs.watchFile('hello.txt',&#123;interval:1000&#125;,function (curr,prev) &#123; console.log('修改文件前的大小' + prev.size); console.log("修改文件后的大小" + curr.size);&#125;) urlget请求解析1234567891011121314151617181920212223242526272829const http=require('http');const urlLib=require('url');const fs=require('fs')//http://localhost:8081/aaa?user=123&amp;pass=123http.createServer(function (req, res)&#123; var obj=urlLib.parse(req.url, true); var url=obj.pathname; var GET=obj.query; // console.log(url, GET); // /aaa &#123; user: '123', pass: '123' &#125; //req获取前台请求数据 // res.write('aaa'); // res.end(); //把1.html放在www目录中域名重定向 var file_name='./www'+url; //访问http://localhost:8081/1.html console.log(file_name) //./www/1.html ./www/favicon.ico fs.readFile(file_name, function (err, data)&#123; if(err)&#123; res.write('404'); &#125;else&#123; res.write(data); &#125; res.end(); &#125;);&#125;).listen(8081); querystring解析post请求的数据123456789101112131415161718192021const querystring=require('querystring');var json=querystring.parse("user=blue&amp;pass=123456&amp;age=18");console.log(json);//&#123; user: 'blue', pass: '123456', age: '18' &#125;//post请求http.createServer(function (req, res)&#123; //POST——req var str=''; //接收数据 //data——有一段数据到达(很多次) var i=0; req.on('data', function (data)&#123; console.log(`第$&#123;i++&#125;次收到数据`); str+=data; &#125;); //end——数据全部到达(一次) req.on('end', function ()&#123; var POST=querystring.parse(str); console.log(POST); &#125;);&#125;).listen(8080); path路径解析1234567891011121314151617const path=require('path');var str='c:\\wamp\\www\\a.html';var obj=path.parse(str);console.log(obj);/*&#123; root: 'c:\\', dir: 'c:\\wamp\\www', base: 'a.html', ext: '.html', name: 'a' &#125; *///base 文件名部分//ext 扩展名//dir 路径//name 文件名部分 bufferhttp://nodejs.cn/api/buffer.html 缓冲区 数组中不能存储二进制的文件,而buffer就是专门用来存储二进制数据 使用Buffer 不需要引入模块,直接使用即可 在Buffer中存储的都是二进制数据,但是在显示时都是以16进制的形式显示的buffer中的每一个元素的范围是从00-ffbuffer 中每一个元素的范围从00-ff 0-25500000000-11111111 计算机 一个0 或者一个1 称为1位(bit)1个汉字占3个字节1个字母占1个字节buffer中的一个元素,占有一个字节8bit =1byte(字节)1024byte=1kb1024kb=1mb1024mb=1gb1024gb=tb 1234567891011121314151617181920212223242526272829303132333435let str = 'helloworld'let buf =Buffer.from(str)console.log(buf) //&lt;Buffer 68 65 6c 6c 6f 77 6f 72 6c 64&gt;console.log(buf.length); //10个字节 占用内存的大小// 创建一个指定大小的buffer// buffer 构造函数都是不推荐使用的var buf2 =new Buffer(10); //10个字节的bufferconsole.log(buf2);//&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;// 创建一个指定大小的buffer// buffer 构造函数都是不推荐使用的var buf2 =new Buffer(10); //10个字节的bufferconsole.log(buf2);//&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;//创建一个10个字节的buffervar buf3=Buffer.alloc(10); //alloc 分配console.log(buf3); //&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;//通过索引,来操作buf中的元素buf3[0]=88;buf3[1]=255;buf3[2]=0xaa;buf3[10]=15; // buffer的长度一旦确定,就无法修改了console.log(buf3) //&lt;Buffer 58 ff aa 00 00 00 00 00 00 00&gt;// 只要数字在控制台或页面中输出一定是10进制console.log(buf3[2]); //170console.log(buf3[2].toString(16)); //aa 转化成16进制//Buffer.allocUnsafe(size) buffer中可能含有敏感的数据 ,不会清空数据var buf4=Buffer.allocUnsafe(10); //&lt;Buffer 04 fa 24 00 00 00 00 00 78 3c&gt;console.log(buf4)//&lt;Buffer 04 fa 24 00 00 00 00 00 78 3c&gt; 引入modulesexpressexpress原生：res.write()res.end() express：res.send()res.write()res.end() npm install express express保留了原生的功能，添加了一些方法(send)，增强原有的功能12345678910111213141516171819202122232425const express=require('express');//1.创建服务var server=express();//2.监听server.listen(8080);//3.处理请求server.use('地址', function (req, res)&#123;&#125;);//除了use，还有get和post和delete等，//当然use是全部都会响应//3种方法：.get('/', function (req, res)&#123;var user=req.query['user'];&#125;);.post('/', function (req, res)&#123;&#125;);.use('/', function (req, res)&#123;&#125;);const expressStatic=require('express-static');//处理静态资源server.use(expressStatic('./www')); //默认路径//访问 http://localhost:8081/a.html//中间件 处理/login?user=xxx&amp;pass=xxx =&gt;&#123;ok: true/false, msg: '原因'&#125; 中间件(body-parser)req.query //GET {}用来post请求post使用req.body引用body-parser使用post12345678910111213141516171819202122232425const bodyParser=require('body-parser');server.use(bodyParser.urlencoded(&#123; //参数可以省略 extended: false, //扩展模式 limit: 2*1024*1024 //限制-2M&#125;));server.use('/', function (req, res)&#123; console.log(req.body);&#125;);//链式操作 use post另一种写法server.use(function (req, res, next)&#123; var str=''; req.on('data', function (data)&#123; str+=data; &#125;); req.on('end', function ()&#123; req.body=querystring.parse(str); next(); &#125;);&#125;);server.use('/', function (req, res)&#123; console.log(req.body);&#125;); cookiehttp-无状态的 cookie：在浏览器保存一些数据，每次请求都会带过来 *不安全、有限(4K) session：保存数据，保存在服务端 安全、无限session：基于cookie实现的 cookie中会有一个session的ID，服务器利用sessionid找到session文件、读取、写入 隐患：session劫持 npm install cookie-parser cookie-session 1234567891011121314151617181920212223242526272829//原生cookie存储server.use('/aaa/a.html', function (req, res)&#123; res.cookie('user', 'blue', &#123;path: '/aaa', maxAge: 30*24*3600*1000&#125;); //30天 res.send('ok');&#125;);//cookie-parser读取server.use(cookieParser());//可以访问'/'目录底下的cookieserver.use('/', function (req, res)&#123; console.log(req.cookies); //&#123;'user':'blue'&#125; res.send('ok');&#125;);// &gt;decodeURIComponent(解析code)//cookie防止篡改server.use(cookieParser('wesdfw4r34tf'));server.use('/', function (req, res)&#123; req.secret='wesdfw4r34tf';//秘钥 res.cookie('user', 'blue', &#123;signed: true&#125;);//签名 console.log('签名cookie：', req.signedCookies) //&#123;user:blue&#125; console.log('无签名cookie：', req.cookies); //&#123;&#125; 读取不了 res.send('ok');&#125;);res.clearCookie('user');//清除cookie cookie-encrypter 加密解密 插件 cookie-session123456789101112131415161718192021222324252627282930313233343536const cookieSession=require('cookie-session');// 1.写入// 2.读取 F12存储在cookie有两个:1.ID(不变) 2.签名 //session存在劫持 要求严格 必须要keys 越长越安全// server.use(cookieParser());server.use(cookieSession(&#123; name: 'sess', keys: ['aaa', 'bbb', 'ccc'], maxAge: 2*3600*1000 //两天&#125;));server.use('/', function (req, res)&#123; if(req.session['count']==null)&#123; //访问服务器次数 req.session['count']=1; &#125;else&#123; req.session['count']++; &#125; console.log(req.session['count']); res.send('ok');&#125;);//session中的keys 安全性更高var arr=[];for(var i=0;i&lt;100000;i++)&#123; arr.push('sig_'+Math.random());&#125;server.use(cookieParser());server.use(cookieSession(&#123; name: 'sess', keys: arr, maxAge: 2*3600*1000&#125;)); 文件上传multer上传之后文件没后缀要加后缀12345&lt;form action="http://localhost:8080/" method="post" enctype="multipart/form-data"&gt; 文件：&lt;input type="file" name="f1" /&gt;&lt;br&gt; &lt;input type="submit" value="上传"&gt;&lt;/form&gt; 1234567891011121314151617181920212223242526272829303132const express=require('express');//const bodyParser=require('body-parser');const multer=require('multer');const fs=require('fs');const pathLib=require('path');var objMulter=multer(&#123;dest: './www/upload/'&#125;);var server=express();//错误//server.use(bodyParser.urlencoded(&#123;extended: false&#125;));server.use(objMulter.any());server.use(objMulter.single(‘f1’));//接收一个的文件,input的name值server.post('/', function (req, res)&#123; //新文件名 //'./www/upload/dfb33662df86c75cf4ea8197f9d419f9' + '.png' //var newName=req.files[0].path+pathLib.parse(req.files[0].originalname).ext; console.log(req.files) fs.rename(req.files[0].path, newName, function (err)&#123; if(err) res.send('上传失败'); else res.send('成功'); &#125;); //1.获取原始文件扩展名 //2.重命名临时文件&#125;);server.listen(8080); req.files上传文件属性 如下 模板引擎1234567891011121314const consolidate=require('consolidate');//.配置模板引擎//输出什么东西server.set('view engine', 'html');//模板文件放在哪儿server.set('views', './views'); //模板文件目录//哪种模板引擎server.engine('html', consolidate.ejs);//接收用户请求server.get('/index', function (req, res)&#123; res.render('1.ejs', &#123;name: 'blue'&#125;);&#125;); router1234567//目录1：/user/var routeUser=express.Router();server.use('/user', routeUser);//http://xxx.com/user/1.htmlrouteUser.get('/1.html', function (req, res)&#123; res.send('user1');&#125;); 5.模板jade123const jade=require('jade');jade.render('html'); //&lt;html&gt;&lt;/html&gt;jade.renderFile('模板文件名', 参数) 模板引擎：jade-破坏式、侵入式、强依赖ejs-温和、非侵入式、弱依赖 1234567891011doctype &lt;!DOCTYPE html&gt;html &lt;html&gt; head &lt;head&gt; style &lt;style&gt;&lt;/style&gt; &lt;/head&gt; body &lt;body&gt; div &lt;div&gt;&lt;/div&gt; div &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 美化123var str=jade.renderFile('./views/1.jade', &#123;pretty: true&#125;); //pretty 可以换行缩进 美化console.log(str); 写入12345678var str=jade.renderFile('./views/2.jade', &#123;pretty: true&#125;);//生成fs.writeFile('./build/2.html', str, function (err)&#123; if(err) console.log('写入失败'); else console.log('写入成功');&#125;); 规则:1.根据缩进2格，规定层级2.属性放在()里面，逗号分隔3.内容空1个格，直接往后堆4.识别单双标签属性&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;script(src=”a.js”)内容&lt;a href=&quot;http://www.zhinengshe.com/&quot;&gt;官网&lt;/a&gt;a(href=”http://www.zhinengshe.com/&quot;) 官网样式&lt;div style=&quot;width:200px;height:200px;background:red;&quot;&gt;&lt;/div&gt;1.div(style=”width:200px;height:200px;background:red”)2.div(style= {width: ‘200px’, height: ‘200px’, background: ‘red’})类名&lt;div class=&quot;aaa left-warp active&quot;&gt;&lt;/div&gt;div(class=”aaa left-warp active”)div(class= [‘aaa’, ‘left-warp’, ‘active’])Id和classdiv.boxdiv#div1属性div(title=”aaa”,id=”div1”)div&amp;attributes({title: ‘aaa’, id: ‘div1’})竖线或点原样输出 函数竖线 丨a=1; script.a=2 include加载js代码script include a.js渲染1234567div 我的名字：#&#123;name&#125;var str=jade.renderFile('./views/6.jade', &#123;pretty: true, name: 'blue'&#125;)div 我的名字：#&#123;a+b&#125;div(style=json)div(class=arr)div(class=arr class="active") 也可以 代码计算输出body -var a=12; -var b=5;div 结果是：#{a+b} //17 输出span #{a} 一样的写法 span=a for循环 -for(var i=0;i&lt;arr.length;i++) li #{i} 输出html 注入式攻击js123console.log(jade.renderFile('./views/12.jade', &#123;pretty: true, content: "&lt;h2&gt;你好啊&lt;/h2&gt;&lt;p&gt;对方水电费色弱威尔士地方&lt;/p&gt;"&#125;)); div!=content if -var a=19; if(a%2==0) div(style={background:’red’}) 偶数 else div(style={background:’green’}) 奇数switch -var a=1; case a when 0 div aaa when 1 div bbb when 2 div ccc default |不靠谱 ejsejs――非侵入、非破坏 &lt;%= name %&gt;&lt;%= json.arr[0].name %&gt;&lt;%= 12+5 %&gt;&lt;%= ‘asdfasdf’ %&gt; 1.ejs12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;我的名字叫：&lt;%= name %&gt;&lt;/body&gt;&lt;/html&gt; 1.js12345678const ejs=require('ejs');ejs.renderFile('./views/1.ejs', &#123;name: 'blue'&#125;, function (err, data)&#123; if(err) console.log('编译失败'); else console.log(data); //打印1.ejs文档&#125;); 代码12345678910111213&lt;%var str="&lt;div&gt;&lt;/div&gt;";%&gt; &lt;%- str %&gt; //输出div标签include&lt;% for(var i=0;i&lt;5;i++)&#123; %&gt;&lt;% include ../a.txt %&gt; &lt;% &#125; %&gt;if&lt;% if(type=='admin')&#123; %&gt;&lt;% include ../style/admin.css %&gt; &lt;%&#125;else&#123;%&gt;&lt;% include ../style/user.css %&gt; &lt;% &#125; %&gt; 链接Mysql npm install mysql 1234567891011121314151617181920const mysql=require('mysql');//1.连接//createConnection(哪台服务器, 用户名, 密码, 库) port:3308var db=mysql.createConnection(&#123; host: 'localhost', user: 'root', password: '123456', database: '20161222'&#125;);//2.查询//query(干啥, 回调)db.query("SELECT * FROM `user_table`;", (err, data)=&gt;&#123; if(err) console.log('出错了', err); else console.log('成功了'); console.log(JSON.stringify(data));&#125;); 操作语句 查-SELECTSELECT 什么 FROM 表1SELECT * FROM `user_table` 增-INSERTINSERT INTO 表 (字段列表) VALUES(值列表)1`INSERT INTO `user_table` (`ID`, `username`, `password`) VALUES(0, &apos;blue2&apos;, &apos;987654&apos;);`]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码片段]]></title>
    <url>%2F2018%2F07%2F13%2F%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[去重12345678910111213141516171819202122232425//第一种方法 Array.prototype.unique = function()&#123; //在原型上加方法 var res = []; var json = &#123;&#125;; for(var i = 0; i &lt; this.length; i++)&#123; if(!json[this[i]])&#123; //是否存在 res.push(this[i]); json[this[i]] = 1; //保存了 &#125; &#125; return res;&#125;var arr = [112,112,34,'你好',112,112,34,'你好','str','str1'];console.log(arr.unique()) //[112, 34, "你好", "str", "str1"]//2.//判断是否第一个index,返回第一出现的值let uniqueArr=arr.filter((item,index,arr)=&gt;arr.indexOf(item)==index)console.log(uniqueArr) //[112, 34, "你好", "str", "str1"]//3.es6 Set方法let a =[...new Set(arr)]console.log(a) //[112, 34, "你好", "str", "str1"] 防抖与节流JS的防抖与节流 防抖123456789101112131415function debounce(fn, wait) &#123; var timeout = null; return function() &#123; if(timeout !== null) &#123; clearTimeout(timeout) &#125; timeout = setTimeout(fn, wait) &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random()); &#125;// 滚动事件window.addEventListener('scroll', debounce(handle, 1000)); 节流1234567891011121314151617181920212223//节流var throttle = function(func, delay) &#123; var timer = null; var startTime = Date.now(); return function() &#123; var curTime = Date.now(); var remaining = delay - (curTime - startTime); var context = this; var args = arguments; clearTimeout(timer); if (remaining &lt;= 0) &#123; func.apply(context, args); startTime = Date.now(); &#125; else &#123; // 超1s多出时间执行 timer = setTimeout(func, remaining); &#125; &#125;&#125;function handle() &#123; console.log(Math.random());&#125;//当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数 window.addEventListener('scroll', throttle(handle, 3000)); 多级数组变一级(扁平) 12345678910111213141516171819 var arr=[1,2,3,4,['a',55,[111,&#123;"name":'bbb'&#125;]]] var empty=[] function flat(arr)&#123; arr.forEach(item=&gt;&#123; if (typeof item==='string' || typeof item==='number')&#123; empty.push(item) &#125;else if(Array.isArray(item))&#123; //判断数组 1.typeof item ==='object' &amp;&amp;item instanceof Array // 2. Object.prototype.toString.call(item)==='[object Array]' flat(item) &#125;else&#123; empty.push(item) &#125; &#125;) return empty &#125;console.log(flat(arr)) // [1, 2, 3, 4, "a", 55, 111, &#123;"name":'bbb'&#125;] 千分符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var str="3562123761";//[3,562,123,761]function test(str)&#123; var iNum=str.length%3; var prev=""; var arr=[]; var iNow=0; var tmp=''; if(iNum !=0)&#123; //不是三的整除,先放在数组 prev =str.substring(0,iNum); arr.push(prev) &#125; str =str.substring(iNum); for (var i=0;i&lt;str.length;i++)&#123; iNow++; tmp+=str[i]; if(iNow==3&amp;&amp;tmp)&#123; arr.push(tmp) //三个数字一组 tmp=''; iNow=0; &#125; &#125; //console.log(arr) return arr.join(',');&#125;console.log(test(str));//正则//(?=)前项声明//(?!)反前向声明//例子var str1='abacad';var re=/a(?=b)/gstr1=str1.replace(re,"*");console.log(str1);//*bacadvar re2=/a(?!b)/gvar str2=str1.replace(re2,"*")console.log(str2);//*b*c*dfunction test2(str)&#123; var re=/(?=(?!\b)(\d&#123;3&#125;)+$)/g; //边界不能替换 return str.replace(re,',')&#125;console.log(test2(str));//3,562,123,761 驼峰命名法12345678910111213141516171819var str="border-bottom-color";function test(str)&#123; var arr=str.split("-");//[border,bottom,color] for(var i=1;i&lt;arr.length;i++)&#123; arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substring(1); &#125; return arr.join('')&#125;console.log(test(str));//borderBottomColor//2.正则function test2(str)&#123; var re=/-(\w)/g; return str.replace(re,function($0,$1)&#123; //-b b return $1.toUpperCase() &#125;)&#125;console.log(test2(str));//borderBottomColor 排序Javascript常见排序算法的笔记 从小到大排序 冒泡排序123456789101112131415161718192021var arr = [15, 55, 99, 77, 8, 0, 2]let time = 0;function bubbleSort(arr) &#123; var len = arr.length for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; time++ if (arr[j] &gt; arr[j + 1]) &#123; var temp temp = arr[j]; arr[j] = arr[j + 1] arr[j + 1] = temp &#125; &#125; &#125; return arr&#125;console.log(time) //21console.log(bubbleSort(arr)) //[0, 2, 8, 15, 55, 77, 99] 二分法排序123456789101112131415161718192021const Arr = [85, 24, 63, 45, 17, 31, 96, 50];function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let pivotIndex = Math.floor(arr.length / 2); let pivot = arr.splice(pivotIndex, 1)[0]; let left = []; let right = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; // 递归 return quickSort(left).concat([pivot], quickSort(right));&#125;console.log(quickSort(Arr));//[17, 24, 31, 45, 50, 63, 85, 96] 添加class12345678910function addClass(el, className) &#123; //加class let reg = new RegExp('(^|\\s)' + className + '(\\s|$)') //"className" 或者 “ className ” if (reg.test(el.className)) &#123; //判断是否有class return &#125; //加上class名 let newClass = el.className.split(' ') //拆分 newClass.push(className) //添加 el.className = newClass.join(' ') //字符串 &#125; 设置data节点属性1234567function getData(el, name, val) &#123; const prefix = 'data-' if (val) &#123; return el.setAttribute(prefix + name, val) //设置 &#125; return el.getAttribute(prefix + name) //获取&#125; 浏览器css前缀的兼容123456789101112131415161718192021222324252627282930313233//设置浏览器的兼容function prefixStyle(style) &#123; let elementStyle = document.createElement('div').style //供应商 let vendor = (() =&gt; &#123; let transformNames = &#123; webkit: 'webkitTransform', Moz: 'MozTransform', O: 'OTransform', ms: 'msTransform', standard: 'transform' &#125; for (let key in transformNames) &#123; if (elementStyle[transformNames[key]] !== undefined) &#123; return key //返回前缀 &#125; &#125; return false &#125;)() if (vendor === false) &#123; return false &#125; if (vendor === 'standard') &#123; //标准,没有前缀 return style &#125; return vendor + style.charAt(0).toUpperCase() + style.substr(1) //驼峰命名&#125;//测试alert(prefixStyle('transform'))// webkitTransform (谷歌浏览器 webkit内核) 获取DOM大小和位置123456789101112131415161718function getRect(el) &#123; if (el instanceof window.SVGElement) &#123; let rect = el.getBoundingClientRect() return &#123; top: rect.top, left: rect.left, width: rect.width, height: rect.height &#125; &#125; else &#123; return &#123; top: el.offsetTop, left: el.offsetLeft, width: el.offsetWidth, height: el.offsetHeight &#125; &#125;&#125; 对象hasOwnProperty 对象本身的属性123456789101112131415161718192021222324//构造函数function Foo(name)&#123; this.name=name&#125;Foo.prototype.alertName=function()&#123; alert(this.name)&#125;// 创建示例var f = new Foo('小明')f.printName=function()&#123; console.log(this.name) //小明&#125;//测试f.printName() f.alertName()f.toString() //要去f.__proto__.__proto__中查找var item for(item in f)&#123; //高级浏览器已经在 for in 中 屏蔽了来自原型的属性 //但是这里还是建议大家还是加上这个判断,保证程序的健壮性 if(f.hasOwnProperty(item))&#123; console.log(item) // name printName &#125;&#125; 原型链 instanceof用于判断引用类型属于哪个构造函数的方法 f instanceof 的判断逻辑是: f的proto一层一层往上,能否找打对应到Foo.prototype 再试判断f instanceof Object instanceof变量 属于 数组123var arr=[]arr instanceof Array //truetypeof arr //object, typeof 是无法判断是否是数组的 例子DOM操作1234567891011121314151617181920212223function Elem(id) &#123; this.elem = document.getElementById(id)&#125;Elem.prototype.html = function(val) &#123; //设置/获取innerHTML var elem = this.elem if (val) &#123; elem.innerHTML = val return this //链式操作 &#125; else &#123; return elem.innerHTML &#125;&#125;Elem.prototype.on = function(type,fn) &#123; //绑定事件 var elem=this.elem elem.addEventListener(type,fn) return this&#125;let div1 = new Elem('div1') //获取设置id类//console.log(div1.html()) //innerHTMLdiv1.html("&lt;p&gt;hello world&lt;/p&gt;").on('click',function()&#123; alert('clicked')&#125;) 深层拷贝1234567function deepClone(obj)&#123; var newObj=obj instanceof Array ? []:&#123;&#125; for(var key in obj)&#123; newObj[key]= typeof obj[key]==='object'? deepClone(obj[key]):obj[key] &#125; return newObj&#125; 日期 Date.now() //获取当前毫秒数1531824326654 new Date().getTime()//获取毫秒数1234567891011function getTime()&#123; var dt=new Date() //中国标准时间 var year=dt.getFullYear() //年 var month=dt.getMonth()+1 //月(0-11) var date=dt.getDate() //日(0-31) var hour=dt.getHours() //时(0-23) var minute=dt.getMinutes() //分 (0-59) var second=dt.getSeconds() //秒 (0-59) return year+'-'+month+'-'+date+' '+hour+':'+minute+':'+second&#125;getTime() //2018-6-17 18:58:22 递归阶乘1234567891011121314//书P70 可以被es6引擎优化//阶乘function factorial(n,p=1)&#123; if(n&lt;=1)&#123; return 1*p &#125;else&#123; let result =n*p //优化后 return factorial(n-1,result) &#125;&#125; factorial(3)//6 ##菲波那契12345678910111213141516171819202122232425262728293031//菲波那契 //1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144function fibo(n) &#123; if (n &gt;= 2) &#123; return fibo(n - 1) + fibo(n - 2) &#125; else &#123; return n; &#125;&#125;fibo(3) //2//最优解// 菲波那契可能是最普通的解法var series = function (n) &#123; var sum = [0, 1]; if(n &lt; 2) &#123; return sum[n]; &#125; var firstNum = 0; var secondNum = 1; var total = 0; for (var i = 2; i&lt;= n; i++) &#123; total = firstNum + secondNum; firstNum = secondNum; secondNum = total; &#125; return total;&#125; 浏览器内置对象navigatornavigator.userAgent 浏览器代理器名称 location例子location.href=’跳转的地址’https://www.baidu.com/index.html?id=99&amp;a=b#mid=100 location值 location.protocolhttps: location.pathname/index.html location.search?id=99&amp;a=b location.hash#mid=100 事件event. stopPropagatio()是阻止冒泡事件的方法，在ie浏览器上没有stopPropagatio()这个方法，在ie上要用e.cancelBubble=true阻止冒泡事件 123456789function stopPropagation(event)&#123; var e=window.event||event; if(document.all)&#123; e.cancelBubble=true; &#125;else&#123; e.stopPropagation();//阻止冒泡 e.preventDefault()// 取消默认行为 &#125;;&#125; 事件委托代理12345678910&lt;div id="div1"&gt;&lt;a href=""&gt;这是a标签&lt;/a&gt;&lt;/div&gt;&lt;script&gt;let div1=document.getElementById('div1')div1.addEventListener('click',function(e)&#123; let target=e.target if(target.nodeName==='A')&#123; alert(target.innerHTML) &#125;&#125;)&lt;/script&gt; 完善封装代理1234567891011121314151617181920212223242526272829function bindEvent(elem,type,selector,fn)&#123; if(fn==null)&#123; //3个参数 fn=selector selector=null &#125; elem.addEventListener(type,function(e)&#123; var target if(selector)&#123; //四个参数(代理) target=e.target console.log(target) if (target.matches(selector))&#123; fn.call(target,e) &#125; &#125;else&#123; //没有代理 fn(e) &#125; &#125;)&#125;//使用代理var div1=document.getElementById('div1')bindEvent(div1,'click','a',function(e)&#123; console.log(this.innerHTML)&#125;)//不使用代理// var a=document.getElementById('a1')// bindEvent(div1,'click',function(e)&#123;// console.log(a.innerHTML)// &#125;) ajax123456789101112var xhr =new XMLHttpRequest()xhr.open('GET','/api',false)xhr.onreadystatechange=function()&#123; //这里的函数异步执行 if(xhr.readyState=4)&#123; //ajax状态码 if(xhr.status==200)&#123; //http请求状态码 alert(xhr.responseText) &#125; &#125;&#125;xhr.send(null) AMD异步模块定义123456789101112131415161718192021222324252627282930313233343536//1.util.jsdefine(function()&#123; var util=&#123; getFormatData:function(date,type)&#123; if(type===1)&#123; return '2018-06-20' &#125;if(type===2)&#123; return '2018年6月20日' &#125; &#125; &#125; return util&#125;)//2.a-util.jsdefine(['./util.js'],function(util)&#123; var aUtil=&#123; aGetFormatDate:function(date)&#123; return util.getFormatData(date,2) &#125; &#125; return aUtil&#125;)//3.a.jsdefine(['./a-util.js'],function(util)&#123; var a=&#123; printDate:function(date)&#123; console.log(util.aGetFormatDate(date)) &#125; &#125; return a&#125;)//4.main.jsrequire(['./a.js'],function(a)&#123; var date=new Date() a.printDate(date) //2018年6月20日&#125;) 使用 data-main1&lt;script src="https://cdn.bootcss.com/require.js/2.3.4/require.min.js" data-main='./main.js'&gt;&lt;/script&gt; 运动运动的tool12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970function getStyle(ele, attr) //获取样式&#123; if(ele.currentStyle) &#123; return ele.currentStyle[attr]; &#125; else &#123; return getComputedStyle(ele, false)[attr]; &#125;&#125;function startMove(ele, obj, fn)&#123; clearInterval(ele.timer); ele.timer=setInterval(function ()&#123; var bStop=true; //这一次运动就结束了――所有的值都到达了 for(var attr in obj) &#123; //1.取当前的值 var iCur=0; if(attr=='opacity') &#123; iCur=parseInt(parseFloat(getStyle(ele, attr))*100); &#125; else &#123; iCur=parseInt(getStyle(ele, attr)); &#125; //2.算速度 var iSpeed=(obj[attr]-iCur)/8; iSpeed=iSpeed&gt;0?Math.ceil(iSpeed):Math.floor(iSpeed); //3.检测停止 if(iCur!=obj[attr]) &#123; bStop=false; &#125; if(attr=='opacity') &#123; ele.style.filter='alpha(opacity:'+(iCur+iSpeed)+')'; ele.style.opacity=(iCur+iSpeed)/100; &#125; else &#123; ele.style[attr]=iCur+iSpeed+'px'; &#125; &#125; if(bStop) &#123; clearInterval(ele.timer); if(fn) &#123; fn(); &#125; &#125; &#125;, 30)&#125;//例子 // let div1=document.getElementById('div1') // startMove(div1,&#123;height:300&#125;,function()&#123; //高度变化300px // cosnole.log('运动完成') // &#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript-6]]></title>
    <url>%2F2018%2F07%2F11%2Fes6%2F</url>
    <content type="text"><![CDATA[一.资料MDN（Mozilla开发者网络）ECMAScript 6 入门（阮一峰） 二.块级作用域绑定var function 存在变量提升var 只会提前声明 function 既声明有定义12345console.log(fun1)function fun1()&#123; var b=4;&#125;console.log('fun1' in window) //true let12345678910111213141516171819202122 // a is not defined //console.log(a) 报错//1.没有变量提升//2.不可以重复声明//3.不会给window增加属性 let a=1; console.log(window.a)//undefined function getValue()&#123; if(condition)&#123; // var value='blue' let value='blue' //其他代码 return value &#125;else &#123; //var 声明变量value 值为undefined //let const声明变量 value此处不存在 return null &#125; &#125; const1.没有变量提升2.不可以重复声明3.不会给window增加属性4.const 定义变量,一旦声明必须赋值5.const 定义是一个常量,不可以重新赋值 12345678910const person=&#123; name:"make" &#125; //可以修改对象属性的值 person.name='greg' //抛出语法错误 person=&#123; name:'Greg' &#125; 块级作用域{}:一个{}就是一个块级作用域 在块级作用域下,var和function声明变量依然是全局的 在块级作用域下let和const声明变量都是私有的 {}如果表示一个对象不可以放在行首 {name:&#39;小明&#39;} 看成一个块级作用域 1234567891011121314151617 //用小括号console.log(eval('(&#123;name:"小明"&#125;)')) &#123; let b=1; var a=0; function getA()&#123;console.log(a)&#125; &#125; console.log(a); //0 getA() //0 //console.log(b) //b is not defined// if()&#123;&#125;中function 只会提前声明不会定义,当条件成立先给函数赋值 代码再执行if(0)&#123; var A=1; function getAA()&#123;&#125;&#125;console.log(A);//undefinedconsole.log(getAA)//undefined var和let 临时死区TDZTemporal Dead Zone12345678console.log(typeof value) //引用错误let value='123'// 正确: 当value不存在TDZconsole.log(typeof value) //'undefined' if(1)&#123; let value='blue'; &#125; 三.数组和对象数组的结构赋值12345678910let [x,y,m,n]=arrconsole.log(x, y, m, n);//1,2,3,4//设置默认值 只有后面结构的值是undefined才会走默认值let [x1,x2=10]=[1]//省略赋值let [,,m3]=[1,2,3] //m3=3//不定参数赋值 将后面的项放在一个数组中赋值y3=[3,4,5]let[y1,y2,...y3]=[1,2,3,4,5] //扩展运算符 对象12345678910111213141516//如果变量名和属性名一样 可以直接省略写法let &#123;name,age&#125;=&#123;name:"小明",age:10&#125; console.log(name);//小明//默认值let &#123;name,age=100&#125;=&#123;name:"小明"&#125;//嵌套let &#123;name,age,list:[a1,a2,a3]&#125;=&#123;name:"小明",age:10,list:['js','node','vue']&#125;;console.log(name, age, a1, a2, a3);//小明 10 js node vue 块// let x1,x2;// [x1,x2]=[1,2];(&#123;x1,x2&#125;=&#123;x1:1,x2:2&#125;)//加括号console.log(x1, x2);//1,2 合并和操作对象 get和set symbolSymbol是一个新的基本类型 而且是一个值的类型 数字和字符串123456789101112131415//使用数组的结构赋值的方式,如果等号右边不是一个数组,// 默认会转化为类数组(类似数组的对象 必须有一个length属性)let [x,y]="123";console.log(x, y);//1,2//使用对象的结构赋值的形式 如果等号右边不是对象// 默认转化成对象let &#123;__proto__:a&#125;=1;console.log(a);console.log(Object(1));//Number &#123;[[PrimitiveValue]]: 1&#125;//__proto__:Numberlet &#123;length:b&#125;="1234";console.log(Object("1,2,3,4"));//String &#123;[[PrimitiveValue]]: "1,2,3,4"&#125;console.log(b)//4 函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//函数参数的结构赋值 function getA([a,b,c,...d])&#123; console.log(a,b,c,d)//1,2,3,[4,5] &#125; getA([1,2,3,4,5])//默认值 function getB(&#123;name="小明",age=10&#125;=&#123;&#125;) &#123; console.log(name,age)//小明,10 &#125; getB() //设置默认值function fn(x="小明",y="es6")&#123; console.log(x,y)//0 "es6"&#125;fn(0)//length属性 ,形参的个数,如果形参有默认值情况// length就会失真function fn2(x,y=10) &#123;&#125;fn2(1,2)console.log(fn2.length)//1//参数默认值位置:一般参数的默认值放在最后面function fn3(x=10,y=20) &#123;&#125;//fn3(,1)会报错//arguments 类数组function fn4(...arg)&#123; console.log(arguments) console.log(arg)// [1, 2, 3, 4]&#125;fn4(1,2,3,4)//name的问题function fn()&#123;&#125;console.log(fn.name);//"fn"console.log(function()&#123;&#125;.name);//""//特殊情况function fn()&#123;&#125;//1.bind name是"bound 原来函数的名字"let fn1=fn.bind(null);console.log(fn1.name);//bound fn//2.通过构造函数创建一个函数 名字叫做"anonymous"//function fn(形参)&#123;函数体&#125;//new Function("形参","函数体")//new Function("函数体")let fn2=new Function("x,y","console.log(x,y);return x+y")console.log(fn2(10, 100));//110console.log(fn2.name);//anonymous bind12345678function list() &#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3]// 预定义参数37var leadingThirtysevenList = list.bind(undefined, 37);var list2 = leadingThirtysevenList(); // [37]var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3] 扩展运算符将数组变成非数组1234let arr1=[1,2,3];let arr2=[4,5,6];console.log(arr1.concat(arr2));//[1, 2, 3, 4, 5, 6]console.log([...arr1,...arr2]);//[1, 2, 3, 4, 5, 6] 求数组的最大值12345let ary=[1,22,35,66,77];//Math.max(1,22,35,66,77)console.log(Math.max.apply(null,ary));//77console.log(eval("Math.max("+ary+")"))//77console.log(Math.max(...ary));//77 字符串的扩展12345678910111213141516171819202122232425262728293031console.log(String.prototype); //1.includes 返回值布尔 true/false //判断字符串中有没有指定字符 //includes("指定字符",开始查找的位置(可选)) //第二个参数是数字,不是会转化成数字Number()let str="abcdefg12345";console.log(str.includes('a',null))//2.startsWith和endsWith//startsWith 判断字符串是不是以指定字符作为开头//stratsWith("指定字符",开始查找的位置(可选)) console.log(str.startsWith('b',1))//true//endsWith 判断字符串是不是以指定字符作为结尾//endsWith("指定字符",num);//num:从前num中查看 console.log(str.endsWith('c', 3));//true//3.repeat(num) 将字符串重复num次 num取整不可以是负数 // 或者Infinity console.log(str.repeat(1.9));//1次abcdefg12345//0到-1 -0.3取整0 console.log(str.repeat(-0.9));//空字符//4.padStart padEnd ES7中的方法//按照指定字符串补全字符串的指定长度//参数 1.length长度 2.指定字符//padStart(length,'指定字符')let str1='ab'; console.log(str1.padStart(7, 'ghk'));//ghkghab console.log(str1.padEnd(7, 'ghk'));//abghkgk 操作数组Array类上扩展的方法1234567891011121314151617console.dir(Array)//解析字典//Array 类是一个函数 返回一个数组//Array(x,y,z)将参数变成一个数组返回[x,y,z]console.log(Array)console.log(Array(1, 2, 3));//[1,2,3]console.log(Array("1"))//["1"]//注意:如果只有一个参数并且参数是个数字n,返回有n个空位的数组console.log(Array(7));//[empty × 7]//Array.of(); 跟Array一样的 唯一不同的是 参数是一个数字的时候//返回仍然是一个只有一项的数组console.log(Array.of(7));//[7];//Array.from(数组/类数组) 返回一个数组console.log(Array.from([1, 2, 3]));console.log(Array.from('123'));//["1", "2", "3"] 原型上的扩展方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192console.log(Array.prototype);//copyWithin 从原数组中读取内容 替换数组的指定的位置的内容//参数(替换的目标起始位置target,查找的起始的位置begin,查找的结束位置end 默认到末尾)//原数组的length不变,如果有超出的部分截取掉let ary1=[1,2,3,4,5,6,7,8]ary1.copyWithin(4,2,4)console.log(ary1); //[1, 2, 3, 4, 3, 4, 7, 8]ary1.copyWithin(3,2)console.log(ary1);//[1, 2, 3, 3, 4, 3, 4, 7]//fill按照指定字符填充数组// 将数组的每一项都变成指定字符console.log(ary1.fill('小明'));//['小明',......]let ary2=[1,2,3,4,5,6,7,8];ary2.fill('小法',3,5);//索引3,4替换console.log(ary2)//[1, 2, 3, "小法", "小法", 6, 7, 8]//filter 过滤数组 依据返回值过滤原数组//返回一个新数组let ary3=['小红',1,2,3,'小黄'];let arr=ary3.filter(function(item,index)&#123; //如果返回true就留下当前项 return typeof item=="number";&#125;)console.log(arr) //[1, 2, 3]//find 先遍历数组 一旦参数函数返回true 停止查找 返回当前项//只会找一个let a=ary3.find(function(item)&#123; return typeof item=="number";&#125;)console.log(a); //1//findIndex先遍历数组 一旦参数函数返回true 停止查找 返回当前项的索引//只会找一个let i=ary3.findIndex(function(item)&#123; return typeof item=="string";&#125;)console.log(i); //0//includes 判断数组中有没有某一项//第二个 参数是查找位置的索引console.log([1,2,3].includes(1,1)) //false//every 遍历数组 如果遍历每一项都返回true,最后结果为true// 有一项false,结果就是falseconsole.log([1,2,3,'小明'].every(function(item)&#123; return typeof item==='number'&#125;)) //false//some 遍历数组 如果有一项返回true,最后结果为trueconsole.log([1,2,3,'小明'].some(function(item)&#123; return typeof item==='number'&#125;)) //true//reduce 迭代 第二个参数作为初始的prevlet ary4=[1,2,3,4,5];let result=ary4.reduce(function(prev,item)&#123; //prev 上一次返回值 item:当前项 return prev+item;&#125;,0)//求和console.log(result);//15/** prev item prev+item* 0 1 0+1=1* 1 2 1+2=3* 1+2 3 1+2+3=6* 1+2+3 4 1+2+3+4=10* 1+2+3+4 5 1+2+3+4+5=15* *///reduceRight 跟reduce一样 只是顺序从右开始//keys 遍历每一项的索引的接口 使用for of 遍历let ary5=[1,2,3,4];for(let key of ary5.keys())&#123; console.log(key)//0,1,2,3 (索引)&#125;//默认使用for of 遍历数组 默认遍历的就是每一项let ary6=['a','b','c']for(let item of ary6)&#123; console.log(item)//a b c&#125;//entries 遍历接口 可以遍历到索引的每一项//每一项遍历得到一个数组[索引,当前项]//一般可以通过数组的结构赋值获取遍历的结构//let [index,item] of ary6.entries()for(let e of ary6.entries())&#123; console.log(e)//[0, "a"] [1,"b"] [2,"c]&#125; 处理数组数据数据的变异(以下能改变原数组)pop push unshift shift splice reverse sort查找合并indexof(查找位置) lastIndexof concat slice 处理数据forEach filter(过滤) map(映射) some every reduce (include find es6) ofofof对象会报错 obj is not iterble(迭代)1234567891011121314151617181920let arr=[1,2,3,4,5]for(let i=0;i&lt;arr.length;i++)&#123; //编程 console.log(arr[i])&#125;// 1.forEach 不支持returnarr.forEach(function(item)&#123;//声明式(不关心如何实现) console.log(item)&#125;)arr.b='100'for(let key in arr)&#123;//key会变成字符串类型,包括数组的私有属性 console.log(typeof key)//6个string&#125;for(let val of arr)&#123;//支持return 并且是值of数组(不能遍历对象) console.log( val)//12345&#125;// Object.keys()let obj =&#123;name:'cwx',age:23&#125;;for(let val of Object.keys(obj))&#123; console.log(obj[val])//cwx 23&#125; filter删除filter是否操作原数组: 不 返回结果 : 过滤后的新数组 回调函数的返回结果:如果返回true 表示这一项放在数组中1234let newArr=[1,2,3,4,5].filter(function (item,index) &#123; return item&gt;2&amp;&amp;item&lt;5;&#125;)console.log(newArr) //[3,4] map更新map 映射 将原有的数组映射成一个新的数组[1,2,3]&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;不操作原数组 返回新数组 回调函数中返回什么这一项就是什么1234let arr1=[1,2,3].map(function(item)&#123; return `&lt;li&gt;$&#123;item&#125;&lt;/li&gt;`//es6 模板字符串 遇到变量用$&#123;&#125;取值&#125;)console.log(arr1.join(''))//&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt; includes返回布尔值12let arr2=[1,2,3,4,55]console.log(arr2.includes(5)) //false find返回找到的那一项 不会改变数组 回调函数中返回true表示找到了,找到后停止循环123456let arr2=[1,2,3,4,55,555]//找到具体的某一项用find,找不到结果为undefinedlet result =arr2.find(function (item,index) &#123; return item.toString().indexOf(5)&gt;-1&#125;)console.log(result)//55 some和everysome 找true 找到true后停止 返回true1234567let arr2=[1,2,3,4,55,555]let result =arr2.some(function (item,index) &#123; return item.toString().indexOf(5)&gt;-1&#125;)console.log(result)//true//every 找false 找到false后停止 返回false reducereduce 收敛四个参数 返回的是叠加后的结果 原数组不发生变化,回调函数返回的结果1234567891011121314151617let arr3=[1,2,3,4,5]let sum=arr3.reduce(function(prev,next,index,item)&#123; console.log(arguments) // &#123; '0': 1, '1': 2, '2': 1, '3': [ 1, 2, 3, 4, 5 ] &#125; // &#123; '0': 3, '1': 3, '2': 2, '3': [ 1, 2, 3, 4, 5 ] &#125; // &#123; '0': 6, '1': 4, '2': 3, '3': [ 1, 2, 3, 4, 5 ] &#125; // &#123; '0': 10, '1': 5, '2': 4, '3': [ 1, 2, 3, 4, 5 ] &#125; return prev+next//求和&#125;)console.log(sum) //15//对象里数求和let obj1=[&#123;price:30,count:2&#125;,&#123;price:20,count:3&#125;]let sum2=obj1.reduce(function (prev,next) &#123; return prev+next.price*next.count&#125;,0)//默认指定第一次的prevconsole.log(sum2)//120 数组扁平结合12345let flat=[[1,2,3],[4,5,6]].reduce(function (prev,next) &#123; return prev.concat(next)&#125;)console.log(flat);//[1,2,3,4,5,6] defineProperty1234567let obj =&#123;&#125;;Object.defineProperty(obj,'name',&#123; configurable:false,//操作是否删除 delete obj.name writable:false,//是否可重新赋值 enumerable:false,//是否可枚举(key in obj) value:1&#125;) 双向1234567891011121314151617181920&lt;input type="text" id="input"&gt;&lt;script&gt; let input=document.getElementById('input') let obj =&#123;&#125;; let temp=&#123;&#125;; Object.defineProperty(obj,'name',&#123; get()&#123;// 取obj中的name属性触发 return temp['name']; &#125;, set(val)&#123; //给obj赋值会触发get方法 temp['name']=val;//改变temp的结果 input.value=val //将值赋值给输入框 &#125; &#125;); input.value=obj.name;//页面一加载就会调用get方法 input.addEventListener('input',function () &#123; obj.name=this.value;//当值发生变化时,调用set方法 &#125;)&lt;/script&gt; 四.箭头函数 arrow fn 不具备有this,arguments自己家没有this就找上一级的this如何更改this 指向 1.call apply bind 2.var that=this 3.=&gt; 如何确定this 是谁 看谁调用的 .前面是谁this就是谁 12345678910111213function a(b) &#123; return b+1&#125;let a=b=&gt;b+1;//去掉function关键字 参数只有一个可以省略小括号 小括号和大括号之间有一个箭头// 如果没有大括号则直接是返回值// 有括号必须写returnlet a=b=&gt;c=&gt;b+c;//高阶函数 (&gt;=2个箭头)console.log(a(1)(2))//3[1,2,3].forEach(item=&gt;console.log(item));//错误//在Vue中很多时候不能用箭头函数 五.promise123456789101112131415161718192021222324252627282930//执行顺顺序//new promise() 中的函数==&gt;当前队列中的同步代码==&gt;then中的回调let pro1=new Promise((resolve,reject)=&gt;&#123; //resolve 函数 //reject 函数 //只能执行一个 resolve("success");//成功 reject("error");//失败&#125;)pro1.then((res)=&gt;&#123; //成功的回调 console.log(res);&#125;,(e)=&gt;&#123; //失败 console.log(e)&#125;)//catch promise捕获错误的,then中也会捕获错误pro1.then((res)=&gt;&#123;&#125;).catch((e)=&gt;&#123;&#125;);//resolve 代表是转向成功(函数)//reject 失败(函数)//promise的实例就一个then方法,then方法中有两个参数let p=new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; let a='蘑菇'; resolve(a) //reject() &#125;,2000)&#125;)p.then((data)=&gt;&#123;console.log(data)&#125;,(err)=&gt;&#123;console.log('err')&#125;) //蘑菇 ajax All1234567891011121314151617//console.dir(Promise);//Promise.all([每一项都是Promise,如果不是默认会转化为Promise])//数组中每一项都是成功状态 才会总成功回调 默认将每一项的参数放在一个数组中传给回调函数let p1=new Promise((resolve,reject)=&gt;&#123; resolve("ok");&#125;)let p2=new Promise((resolve,reject)=&gt;&#123; resolve("vue");&#125;)let pAll=Promise.all([p1,p2])console.log(pAll);//Promise &#123; &lt;pending&gt; &#125;pAll.then(res=&gt;&#123; console.log(res)//[ 'ok', 'vue' ]&#125;).catch(e=&gt;&#123; //有个错就执行 console.log(e)&#125;) race12345678//Promise.race([p1,p2])//只要有一个状态改变,当前实例的状态就跟着改变//执行一个Promise.race([p1,p2]).then(res=&gt;&#123; console.log(res)&#125;).catch(err=&gt;&#123; console.log(err)&#125;) 六.set和mapSet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//类似数组 只有值value 没有键key//通过构造函数方式创建一个set实例//参数是一个数组(或者是类似数组只有是有iterable接口)//有iterable接口:数组,arguments,元素集合,Set,Map,字符串//默认有去重console.log(new Set([1,2,3,4]))//Set(4) &#123;1, 2, 3, 4&#125;console.log(new Set('1234'))//Set(4) &#123;"1", "2", "3", "4"&#125;function fn()&#123; console.log(new Set(arguments));&#125;fn(1,2,3,4,2,2)//Set(4) &#123;1, 2, 3, 4&#125;//size 实例的大小个数//add clear delete has//add 增加 如果之前没有加上,有就不加上,返回值增加后的Set实例//可以实现链式写法 参数一次加一个let set1=new Set([1,2,"呵呵",null,NaN]);console.log(set1.add(10).add(100));//&#123;1, 2, "呵呵", null, NaN,10,100&#125;//delete (删除的值) 返回值 true/false 如果里面有这一项就删除成功true//没有此项删除失败falseconsole.log(set1.delete(1))//true;//clear 清空 没有返回值 undefined,没有参数console.log(set1.clear())//undefinedconsole.log(set1)//Set(0) &#123;&#125;//has判断由没有此项,返回值true/falselet set2=new Set([1,2,"哈哈",NaN])console.log(set2.has(NaN))//true//遍历forEach keys values entriesset2.forEach((item,index,input)=&gt;&#123; //Set实例只有value没有key //item,index:当前value //input:当前Set实例&#125;)for(let key of set2.keys())&#123; //key 仍然是value值 console.log(key);//1 2 哈哈 NaN&#125;for(let val of set2.values())&#123; //val 是value值 console.log(val);//1 2 哈哈 NaN&#125;for(let [item,val] of set2.entries())&#123; //item,val 是value值 console.log(item,val);//1 1 2 2 哈哈 哈哈 NaN NaN&#125; 数组去重123456789101112131415161718192021222324252627//数组去重let ary=[1,1,2,2,3,4,4]console.log([...new Set(ary)])//[1, 2, 3, 4]function unique() &#123; return [...new set(ary)]; //return Array.from(new Set(ary))&#125;let ary1=[1,3,5,7,8,9];let ary2=[2,4,6,7,8,9];//并集function add(ary1,ary2)&#123; return [...new Set([...ary1,...ary2])];&#125;console.log(add(ary1,ary2));// [1, 3, 5, 7, 8, 9, 2, 4, 6]//交集 function same(ary1,ary2)&#123; return ary1.filter(item=&gt;ary2.includes(item)) &#125;console.log(same(ary1, ary2));//[7, 8, 9]//差集=并集-交集 function diff(ary1,ary2) &#123; return add(ary1,ary2).filter(item=&gt;!same(ary1,ary2).includes(item)) &#125; console.log(diff(ary1,ary2))//[1, 3, 5, 2, 4, 6] Map123456789101112131415161718192021222324252627282930313233343536373839//Map//构造函数方式创建一个Map实例//new Map([[key,value],[]])//参数是一个数组,数组每一项也是一个数组,有两项key,value//一个对象, 属性名必须是字符串,如果写的不是字符串也默认转化为字符串//Map实例的key可以是任意的数据类型let obj=&#123; name:'小明', 1:"1", true:'true'&#125;new Map([[&#123;name:"小明"&#125;,'小明'],[2,'小红']])let map1=new Map([[1,'小明'],[2,'小红']])console.log(map1)//0:&#123;1 =&gt; "小明"&#125;1:&#123;2 =&gt; "小红"&#125;//size 键值对的个数//get set has delete value entries//get 获取valueconsole.log(map1.get(1));//小明//set(key,value) 可以实现链式写法//has has(1)判断key有没有对应的value//delete delete(1)删除属性key 返回值true/false//clear clear()清空//遍历 forEach keys values entriesmap1.forEach((value,key,input)=&gt;&#123;&#125;)for(let key of map1.keys())&#123;&#125;//数组变成Map实例let ary=["vue","node","React"];let map3=new Map();for(let [index,item] of ary.entries())&#123; map3.set(index,item);&#125;console.log(map3); 七.Proxy12345678910111213141516171819202122232425262728293031323334353637383940414243//代理//对目标对象默认操作的拦截/改写//new Proxy(&#123;目标对象target&#125;,&#123;拦截的方法&#125;)let obj=&#123;name:'小明',age:"18"&#125;//让proxy1代理obj 需要通过proxy1 去操作代理的objlet proxy1=new Proxy(obj,&#123; get(target,key,proxy)&#123; //target:原对象 //key;属性名 //peoxy:实例 console.log("get拦截"); //这里return声什么 获取就是什么 return target[key] &#125;&#125;)//get 只要是获取,例如:proxy1.name就会触发getconsole.log(proxy1.name);//小明//set(target,propKey,value,receiver(接收器)) let obj=&#123;name:"小法"&#125;; let proxy=new Proxy(obj,&#123; get(target,propKey,receiver)&#123; return target[propKey] &#125;, set(target,propKey,value,receiver)&#123; console.log("设置"); //propKey:设置的属性名 //value:设置的属性名 target[propKey]=value; return true; &#125;, has(target,propKey)&#123; console.log("has"); if(propKey.startsWith("_"))&#123;//拦截下划线开头 return false; &#125; return propKey in target; &#125; &#125;); proxy.age='18'; console.log(proxy);//Proxy &#123;name: "小法", age: "18"&#125;console.log("name" in proxy);//trueconsole.log("__proto__" in proxy);//false apply1234567891011121314151617181920212223function getObj()&#123; console.log(this) return &#123;name:'小米'&#125;;&#125;let proxy1=new Proxy(getObj,&#123; apply(target,object,args)&#123; //函数直接执行(),call执行,apply执行 //console.log("apply"); console.log(target, object, args); //target getObj函数 //args 函数执行的参数 //object 给函数修改this的 if(object)&#123; object.__proto__.fn=target; object.fn(...args); delete object.__proto__.fn &#125;else&#123; target(...args) &#125; &#125;&#125;)proxy1(1,2);//this--&gt;windowproxy1.call(obj,1,2)//this--&gt;obj 八.class123456789101112131415161718192021 //constructor 相当于函数本身 function Fn()&#123; this.x=10; &#125; Fn.prototype.getX=function()&#123;&#125; let f=new Fn();//Fn() //es6 class A&#123; constructor()&#123; //当前类本身的函数, //this :当前实例 this.x=10;//增加私有属性 //return 的是基本数据类型对实例没有影响 //如果是引用数据类型会改变实例的结果(一般不写return) &#125; &#125; let a=new A(10);//A x:10 console.log(a); //A();类必须使用new执行 console.log(typeof A);// function class 的name的问题123456789101112let A=class AA&#123; //AA只在类里面使用 constructor()&#123; console.log(AA.name)//AA &#125; getA()&#123; console.log(AA.name)//AA &#125;&#125;let a=new A();console.log(A.name);//AAa.getA()//AA 执行的问题123456//采用class表达式让类直接执行let a1=new class&#123; constructor(name)&#123; console.log(name); &#125;&#125;("杨小虎")//杨小虎 class是没有变量提升的 1234567//Es6 中的class 和let,const一样没有变量提升new GG;//GG is not definedclass GG&#123; constructor()&#123; this.gg="gg" &#125;&#125; class的静态方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//类就相当于原型,写在原型上的方法都被实例继承了//假如想给当前类本身加一些方法,可以在方法前面加上一个// 关键字static 不会被实例继承,只有类本身可以使用//例如 Array.ofclass AA&#123; constructor()&#123; this.a='aa'; &#125; getA()&#123; console.log("哈哈"); &#125; static getB()&#123; console.log("我是AA的静态方法"); &#125;&#125;let aa=new AA();console.log(aa);//AA &#123; a: 'aa' &#125;aa.getA()//哈哈console.log(aa.getB);//undefinedAA.getB()//我是AA的静态方法//静态方法可以被子类继承class F&#123; static getF()&#123; console.log("我是F的getF") &#125;&#125;;class G extends F&#123; static getG()&#123; super.getF() &#125;&#125;G.getG()//我是F的getF//es6原型上的方法不可以枚举1.function F()&#123; this.f='ff';&#125;F.prototype.getF=function () &#123; let f=new F; for(let key in f)&#123; console.log(key) &#125;&#125;;let f=new F();f.getF()//f getF 可以枚举2.class FF&#123; constructor()&#123; this.ff="ff" &#125; getF()&#123;&#125;;&#125;let ff=new FF();for (let key in ff)&#123; console.log(key)//ff 不可枚举&#125;console.log(Object.getOwnPropertyDescriptor(FF.prototype, "getF"));/* &#123; value: [Function: getF], writable: true, enumerable: false,不可枚举 configurable: true &#125;*/ 继承123456789101112131415161718192021222324252627282930313233343536class A&#123; constructor(x)&#123; this.x=x &#125; getX()&#123; console.log(this.x); &#125; static getY()&#123; console.log(this); &#125;&#125;A.getY();//[Function: A]//子类B继承父类Aclass B extends A&#123; constructor(x)&#123; //子类没有this this继承父类 //super()执行完成之后才有this //super() 就是父类A的constructor //this.y=100;不可以在super执行之前使用this super(x); this.y=100; &#125; getX()&#123; //super 指向父类A的原型 super.getX() &#125; //static 父类的静态/私有方法也可以继承 getY()&#123; //super 指向父类本身 super.getY() &#125;&#125;let b=new B("熊猫");b.getX();//熊猫B.getY();//[Function: B] 九.async123456789101112//async 函数默认返回一个promise对象async function getA()&#123; //return 出的内容就是成功的回调的参数 //这里有错误就会被catch捕获到 throw new Error("对不起") return "小明"&#125;getA().then(res=&gt;&#123; console.log(res)&#125;).catch(e=&gt;&#123; console.log(e)&#125;) await1234567891011121314151617let p=new Promise((resolve,reject)=&gt;&#123; resolve("小明")&#125;)async function getA()&#123; //await 后面是一个promise的实例,如果不是也会转化Promise //直接让promise实例的回调执行,返回执行时的参数 //await 是一个语法糖 不用通过then就可以拿到resolve或者reject的参数 let a=await p; //等await 后面的异步完成中再去执行后面的代码 //console.log(a)//小明 return a&#125;getA().then(res=&gt;&#123; console.log(res)&#125;).catch(e=&gt;&#123; console.log(e)&#125;)]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2F2018%2F07%2F04%2Fwechat%2F</url>
    <content type="text"><![CDATA[开始下载地址 helloworld第一个小程序创建 显示的效果 app.js (全局配置) 1App(&#123;&#125;) app.json (json全局配置)12345&#123;"pages":["pages/helloworld/helloworld"]&#125; project.config.json1234567891011121314151617181920212223242526272829303132&#123; "description": "项目配置文件。", "setting": &#123; "urlCheck": true, "es6": true, "postcss": true, "minified": true, "newFeature": true &#125;, "compileType": "miniprogram", "libVersion": "1.9.94", "appid": "touristappid", "projectname": "helloworld", "condition": &#123; "search": &#123; "current": -1, "list": [] &#125;, "conversation": &#123; "current": -1, "list": [] &#125;, "game": &#123; "currentL": -1, "list": [] &#125;, "miniprogram": &#123; "current": -1, "list": [] &#125; &#125;&#125; pages/helloworld 页面下 helloworld.js1Page(&#123;&#125;) helloworld.json1&#123;&#125; helloworld.wxml1&lt;view&gt;helloworld&lt;/view&gt; helloworld.wxss12345view&#123;width: 100%;height:40rpx;text-align: center;&#125; 使用WXML WXSS WXS JavaScript WXML 是框架设计的一套标签语言,组合组件,WXS和事件系统,可以构建出页面的结构 语法123&lt;标签名 属性名='属性值1' 属性名='属性值2' ...&gt; ...&lt;/标签名&gt; 属性 列表渲染 条件渲染 模板渲染 模板的import和include只能引用一个模板,有作用域,不能嵌套引用 include 只包括template里的内容,拷贝到指定的位置 WXSS样式优先级 JavaScript WXS 运行机制 生命周期 路由 事件 冒泡事件.WXML12345&lt;view bindtap='clickA' class='classA'&gt; &lt;view bindtap='clickB' class='classB'&gt; &lt;view bindtap='clickC' class='classC'&gt;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; .WXS123456789101112Page(&#123;clickA()&#123; console.log('我是A触发的')&#125;,clickB() &#123; console.log('我是B触发的')&#125;,clickC() &#123; console.log('我是C触发的')&#125;&#125;) 点击c,触发三个 阻止冒泡用catchtap=&#39;clickC&#39; 捕获12345&lt;view capture-bind:tap='clickA' class='classA'&gt; &lt;view capture-bind:tap='clickB' class='classB'&gt; &lt;view capture-bind:tap='clickC' class='classC'&gt;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 停止捕获 capture-catch=&#39;clickA&#39; 组件教程 view12345678&lt;view class='parent' hover-class='parent-hover'&gt; &lt;view class='child' hover-class='child-hover' /*要加的hover样式*/ hover-stop-propagation='true'/*阻止冒泡*/ hover-start-time='3000' /*按下3s后加hover样式*/ hover-stay-time='2000' /*松开后保留样式2s*/ &gt;&lt;/view&gt;&lt;/view&gt;]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[better-scroll]]></title>
    <url>%2F2018%2F06%2F27%2Fbetter-scroll%2F</url>
    <content type="text"><![CDATA[开始中文文档适应vue项目移动端的框架官网例子 文档 finger-mover 安装 &gt; npm install better-scroll --save &gt; npm install stylus stylus-loader -D css解析 轮播图slider例子 预览 Slider-base.vue源码vue父组件1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;slider :speed='speed'&gt; &lt;div v-for="item in imgs"&gt; &lt;a href="#"&gt; &lt;img class="needsclick" :src="item"&gt; &lt;/a&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type='text/ecmascript-6'&gt;import Slider from './Slider-base.vue'export default &#123; data() &#123; return&#123; imgs: [ 'https://m.360buyimg.com/mobilecms/s1125x549_jfs/t11578/40/1816587279/47894/42dba539/5a0d36f7N149b127f.jpg!q70.jpg', 'https://img1.360buyimg.com/da/jfs/t14110/207/712950073/377098/a23521b1/5a129386N7f39c763.jpg', 'https://img1.360buyimg.com/da/jfs/t13657/160/507550199/94542/6e62a404/5a0d3658Nce159095.jpg' ], speed:1000 &#125; &#125;, components:&#123; Slider &#125;&#125;&lt;/script&gt; scroll.vue 组件封装一个scroll.vue 组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;template&gt; &lt;div ref="wrapper"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt; import BScroll from 'better-scroll' export default &#123; name:'scroll', props: &#123; probeType: &#123; //滑动速度的监听 type: Number, default: 1 &#125;, click: &#123; // 点击 type: Boolean, default: true &#125;, listenScroll: &#123; //监听滚动事件 type: Boolean, default: false &#125;, listData: &#123; // 数据动态变化 type: Array, default: null &#125;, beforeScroll: &#123; //滚动之前 type: Boolean, default: false &#125;, refreshDelay: &#123; //刷新的时间 type: Number, default: 20 &#125;, pullup:&#123; //下拉刷新 type:Boolean, default:false &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; //确保DOM的渲染 this._initScroll() //初始化方法 &#125;, 20) &#125;, methods: &#123; _initScroll() &#123; if (!this.$refs.wrapper) &#123; //没有值 return &#125; this.scroll = new BScroll(this.$refs.wrapper, &#123; probeType: this.probeType,//滑动速度监听 1 click: this.click //true &#125;) if (this.listenScroll) &#123;//监听滚动事件 let me = this this.scroll.on('scroll', (pos) =&gt; &#123; me.$emit('scroll', pos) //派发scroll事件 拿到位置 &#125;) &#125; if (this.pullup) &#123; this.scroll.on('scrollEnd', () =&gt; &#123; // if (this.scroll.y &lt;= (this.scroll.maxScrollY + 50)) &#123; this.$emit('scrollToEnd') //下拉 &#125; &#125;) &#125; if (this.beforeScroll) &#123; this.scroll.on('beforeScrollStart', () =&gt; &#123; this.$emit('beforeScroll') &#125;) &#125; &#125;, disable() &#123; //关 this.scroll &amp;&amp; this.scroll.disable() &#125;, enable() &#123; //开 this.scroll &amp;&amp; this.scroll.enable() &#125;, refresh() &#123; //刷新 this.scroll &amp;&amp; this.scroll.refresh() &#125;, scrollTo() &#123;//滚动到 this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments) &#125;, scrollToElement() &#123;// 滚动到DOM元素 this.scroll &amp;&amp; this.scroll.scrollToElement.apply(this.scroll,arguments) &#125; &#125;, watch: &#123; listData() &#123; setTimeout(() =&gt; &#123; this.refresh() &#125;, this.refreshDelay)//默认刷新的20ms &#125; &#125; &#125;&lt;/script&gt; 拼音导航列表预览list.vue使用scroll.vue源码]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>滚动框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2018%2F06%2F21%2Fvue%2F</url>
    <content type="text"><![CDATA[vue.js中文文档 下载vue.js源码兼容性Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用的 ECMAScript 5 特性在 IE8 无法模拟。Vue.js 支持所有兼容 ECMAScript 5 的浏览器。object.defineProperty(es5)的没有替代的方案 不支持ie8&lt;= vue概述vue.js (读音/vju:/,类似view)是一套构建用户页面的渐进式框架 vue的特点· 核心只关注视图层(view)· 易学,轻量,灵活的特点· 适用于移动端项目· 渐进式框架 框架和库-库 jquery underscore zepto animate.css 我们调用他 主动-框架 vue 拥有完整的解决方案 我们写好人家调用我 被动vue是一个mvvm框架(库)、和angular类似比较容易上手、小巧 mvc (backbone)单向 model view controller MVVM(angular,vue)双向model数据 view视图 viewModel(视图模型) vue数据驱动(主要操作的是数据)-以前操作DOM js数据的类型 Vue 操作类型基本 number String boolean null undefined-Object func..-Symbol(es6){} [] cdn我们推荐链接到一个你可以手动更新的指定版本号：1&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.13/dist/vue.js"&gt;&lt;/script&gt; vue和angular区别?vue——简单、易学指令以 v-xxx一片html代码配合上json，在new出来vue实例个人维护项目适合: 移动端项目,小巧vue的发展势头很猛，github上start数量已经超越angular angular——上手难 指令以 ng-xxx 所有属性和方法都挂到$scope身上 angular由google维护 合适: pc端项目 共同点: 不兼容低版本IE 什么是bower?Bower是一个客户端技术的软件包管理器，它可用于搜索、安装和卸载如JavaScript、HTML、CSS之类的网络资源。其他一些建立在Bower基础之上的开发工具，如YeoMan和Grunt，这个会在以后的文章中介绍。npm install -g bowerbower install vue (包名) 生成bower_components/vue目录bower uninstall vuebower info vue (版本信息)bower install vue#2.0.8 (安装对应版本) 下载 animate.cssbower install animate.css 使用1234567891011121314&lt;div id="app"&gt; &lt;!--moustache 小胡子语法 表达式 可以放赋值 取值 三元--&gt; &#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; //引入一个vue构造函数 let vm=new Vue(&#123; //vm == viewmodel el:"#app",//querySelector data:&#123; //data中的数据会被vm所代理 msg:'hello world!'//内容 &#125; &#125;); //object.defineProperty&lt;/script&gt; DOM指令 v-model 一般表单元素(input) 双向数据绑定 .number指定数字类型 v-text 防止页面出现 {{}} v-once 只绑定第一次 v-html把html字符当做html渲染,一定是可信任的html元素 如data中元素 v-bloak 解决闪烁,基本不采用,要加样式12345&lt;style&gt; [v-cloak]&#123;display:none;&#125;&lt;/style&gt;&lt;div id="app" v-cloak&gt;&lt;/div&gt; v-model 的修饰符来自官网的例子： 1.number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。 2.trim如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：&lt;input v-model.trim=&quot;msg&quot;&gt;3.lazy在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步(当输入框失去焦点)：在“change”时而非“input”时更新&lt;input v-model.lazy=&quot;msg&quot; &gt;循环 v-for 循环(数组,对象,字符串,数字)12&lt;div v-for='value in/of 数组'&gt;&lt;/div&gt;&lt;div v-for='(value,index) in/of 数组'&gt;&lt;/div&gt; 循环: 要循环谁就在谁的身上加v-for属性 v-for=&quot;name in arr&quot; {{$index}} //1.0 才有现在2.0没了 `v-for=&quot;name in json&quot;` `{`{$index`}}` `{`{$key`}}` `v-for=&quot;(k,v) in json&quot;` Vue 2.01234567&lt;div v-for="(item,index) in arr" :key="item.id"&gt; &lt;span&gt;index:&#123;&#123;index&#125;&#125;/ item:&#123;&#123;item&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div v-for="(value,key,index) in obj"&gt; &lt;span&gt;index:&#123;&#123;index&#125;&#125;/ &#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;,&lt;/span&gt;&lt;/div&gt;&lt;li v-for='(value,index) in arr' :key="value.id" :class="&#123;'active':index==1&#125;"&gt; index 为1 加class 2.0里面默认就可以添加重复数据123arr.forEach(function(item,index)&#123;&#125;); 去掉了隐式一些变量 $index $key 之前: v-for=&quot;(index,val) in array&quot; 现在: v-for=&quot;(val,index) in array&quot; v-on事件 v-on(@)绑定给DOM元素,函数需要定义在methods中,不能和data里的内容重名,this指向的是实例,不能使用箭头函数,事件源对象如果不写括号,可以自动传入,否则只能手动传入$event 1&lt;div @事件名='fn'&gt;&lt;/div&gt; v-bindv-bind:动态绑定数据 v-if v-showif操作的是dom show操作的是样式如果频繁的切换dom 使用v-show但数据一开始就确定下来就使用v-if更好开始 属性和方法data data:{a:{}}vue会循环data中的数据(数据劫持)依次会增加setter和getter使用变量时,先要初始化,否则新加的属性不会导致页面刷新方法: a:{school:&#39;&#39;} vm.$set(vm.a,&#39;school&#39;,&#39;fuming&#39;)给对象添加响应式的数据变化 vm.a={school:&#39;xxxx&#39;,age:8}替换原对象 数组vm.arr[0]=10 错误去改变数组中的某一项式监控不到的,也不能使用改变数组长度的方法 vm.arr.length-=2可以 变异方法:pop push shift unshift sort reserve splicevm.arr=vm.arr.map(item=&gt;item+=3) //filter map也可以 数组和对象的注意事项数组 由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如：vm.items.length = newLength12345678var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue相同的效果，同时也将触发状态更新： 12345// 1.Vue.setVue.set(vm.items, indexOfItem, newValue)// 2.Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：vm.$set(vm.items, indexOfItem, newValue)为了解决第二类问题，你可以使用 splice：vm.items.splice(newLength) 对象Vue 不能检测对象属性的添加或删除：123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。例如，对于：123456789var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125;&#125;)//你可以添加一个新的 age 属性到嵌套的 userProfile 对象：Vue.set(vm.userProfile, 'age', 27) 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：vm.$set(vm.userProfile, &#39;age&#39;, 27)有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：1234Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) 你应该这样做：1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) computedcomputed计算”属性” 不是方法 方法不会有缓存,computed会依据依赖(归vue管理的数据,可以响应式变化的)的属性进行缓存 两部分组成有get和set(不能只写set)一般情况下,通过js赋值影响其他人或者表单元素设置值的时候会调用set方法get 必须return 不支持异步操作 复选框123456&lt;div id="app"&gt; 全选 &lt;input type="checkbox" v-model='checkAll'&gt; &lt;br&gt; &lt;input type="checkbox" v-for="product in products" v-model="product.ischeck"&gt;&lt;/div&gt;&lt;script src='node_modules/vue/dist/vue.js'&gt;&lt;/script&gt; js12345678910111213141516let vm=new Vue(&#123; computed:&#123; checkAll:&#123; get()&#123; //返回什么结果,就会赋予给checkAll属性 return this.products.every(item=&gt;item.ischeck) &#125;, set(val)&#123; //val是给checkAll 赋予值的时候传递过来的 this.products.forEach(item=&gt;item.ischeck=val) &#125; &#125; &#125;, el:'#app', data:&#123;//length渲染复选框的个数 products:[&#123;ischeck:true&#125;,&#123;ischeck:true&#125;] &#125;&#125;) 注意computed里面可以放置一些业务逻辑代码，一定记得return1234567891011121314151.computed:&#123; // 有缓存依赖 如果说value没有发生变化, 多次访问 comValue 都只会返回之前计算的结果,不会再次执行函数 comValue: function()&#123; console.log('computed') //默认调用get return this.value * 2; &#125;,&#125;2.computed:&#123; b:&#123; get()&#123;&#125; set()&#123;&#125; &#125;&#125; watch12345678910111213141516171819let vm=new Vue(&#123; el:'#app', data:&#123;a:'',msg:''&#125;, watch:&#123; // 只有值变化的时候才会触发,支持异步,其他情况一般使用computed a(newVal,oldVal)&#123; // watch的属性名字要和观察的人的名字一致 this.msg='..................' setTimeout(()=&gt;&#123; console.log(newVal.length) if(newVal.length&lt;3)&#123; return this.msg='太少' //vm.$data.a='12' &#125; if(newVal.length&gt;6)&#123; return this.msg='太多' // vm.$data.a='1234567' &#125; this.msg='' &#125;,2000); &#125; &#125; &#125;) 另一种方法类型：{ [key: string]: string | Function | Object | Array } vue实例$属性组件树 $parent：用来访问组件实例的父实例 $root: 用来访问当前组件树的根实例 $children:用来访问当前组件实例的直接子组件实例 $refs:用来访问ref指令的子组件DOM访问 $el：用来挂载当前组件实例的dom元素 $els：用来访问$el元素中使用了v-el指令的DOM元素数据访问 $data：用来访问组件实例观察的数据对象 $options：用来访问组件实例化时的初始化选项对象DOM方法的使用 $appendTo(elementOrSelector, callback)：将el所指的DOM元素插入目标元素 $before(elementOrSelector, callback)：将el所指的DOM元素或片段插入目标元素之前 $after(elementOrSelector, callback)：将el所指的DOM元素或片段插入目标元素之后 $remove(callback)：将el所指的DOM元素或片段从DOM中删除 $nextTick(callback)：用来在下一次DOM更新循环后执行指定的回调函数123456789101112131415161718192021222324// vue 的 渲染过程是异步的&lt;template&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;export default &#123; data() &#123; return &#123; text: 0 &#125;; &#125; mounted()&#123; setInterval(()=&gt; &#123; this.text +=1; this.text +=1; this.text +=1; this.text +=1; this.text +=1; &#125;,1000) &#125;&#125;&lt;/script&gt; 可以看到text值的变化是0 5 10 15 … 而并没有出现 0 1 2 3 … 这样连续的变化 event方法的使用 1.监听 $on(event, callback)：监听实例的自定义事件$once(event, callback)：同上，但只能触发一次$watch(property,callback(new, old)): 监听属性的变化，拿到变化前后的值 1234567891011121314// 第一种写法watch: &#123; text(new, old) &#123; console.log(`$&#123;new&#125;：$&#123;old&#125;`); &#125;&#125;// 第二种写法const unWatch = this.$watch('text',(new,old)=&gt; console.log(`$&#123;new&#125;：$&#123;old&#125;`);&#125;)// 2秒后销毁 unWatchsetTimeout(()=&gt; &#123; unWatch();&#125;,2000) // 两种写法的结果一样，只是第二种需要在组件销毁手动销毁$watch 2.触发 $dispatch(event,args)：派发事件，先在当前实例触发，再沿父链一层层向上，对应的监听函数返回false停止$broadcast(event,args)：广播事件，遍历当前实例的$children，如果对应的监听函数返回false，就停止$emit(event, args)：触发事件 3.删除 $off(event, callback)：删除时间监听 4.其他 $forceUpdate()：强制组件刷新$set(ele,attr,value)：给对象设置属性$delete(ele,attr,value)：删除对象属性 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;obj.a&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; obj:&#123;&#125; &#125;; &#125; mounted()&#123; let i = 0; setInterval(()=&gt; &#123; i++; // 第一种 this.obj.a = i ; // obj.a没有定义，vue是无法监听到这个属性的变化， //所以页面的值也不会变化，这时可以用$forceUpdate进行强制渲染，当然不推荐这种用法 this.$forceUpdate(); // 第二种 this.$set(this.obj,'a',i); &#125;,1000) &#125;&#125;&lt;/script&gt; vue实例简单方法:12345678var vm = new Vue(&#123; el: '#app', data: &#123; test: false, arr:['一','二','三','四'], obj:&#123;one:'壹',two:'贰',three:'叁'&#125;, &#125;&#125;); vm.$el -&gt; 就是元素 vm.$data -&gt; 就是data vm.a vm.$mount -&gt; 手动挂在vue程序 DOM vm.$mount(‘#app’) vm.$options -&gt; 获取自定义属性 vm.$destroy -&gt; 销毁对象 vm.$log(); -&gt; 查看现在数据的状态 data里的数据 $nextTick 异步方法,等待渲染DOM完成来获取vm $refs 获取DOM元素 ref=’mydiv’属性用v-for 可以获取多个DOM元素 子组件和父组件同时拥有mounted方法 会先走谁？需要等待子组件挂载完成后在触发父组件的挂载 父组件调用子组件的方法&lt;loading ref=&quot;load&quot;&gt;&lt;/loading&gt;1234mounted()&#123; // ref 如果放在组件上 获取的是组件的实例 并不是组件的dom元素 // this.$refs.load.hide() // this.$refs.load.$el.style.background = 'red'&#125; 事件 @事件.stop阻止冒泡 123e.cancelBubble=truee.stopPropagation();@click.stop //vue @事件.capture事件捕获 1&lt;div @click.capture='parent'&gt; 从上往下 @事件.once@事件.selfv-on:click=”函数”v-on:click/mouseout/mouseover/dblclick/mousedown…..简写: @click=’事件对象:@click=’show()’事件冒泡: 阻止冒泡: a). ev.cancelBubble=true/e.stopPropagation(); b). @click.stop 推荐默认行为(默认事件): 阻止默认行为: a). ev.preventDefault(); b). @contextmenu.prevent 推荐 c).returnValue=false (以前)e.secElement&amp;&amp;e.target 判断事件源键盘事件@keydown $event ev.keyCode 键码 @keyup123456789常用键: 回车 a). @keyup.13 b). @keyup.enter 上、下、左、右 @keyup/keydown.left @keyup/keydown.right @keyup/keydown.up @keyup/keydown.down 自定义键盘指令 之前：Vue.directive(&#39;on&#39;).keyCodes.f1=17; 现在: Vue.config.keyCodes.ctrl=17 &lt;input type=&quot;text&quot; @keyup.ctrl=&quot;change&quot;&gt; todo练习todolist完整版在线预览源码todolist部分代码1234567891011121314151617181920&lt;div id="app"&gt; &lt;input type="text" @keyup.enter="add" v-model="val"&gt; &lt;ul&gt; &lt;li v-for="(a,index) in arr"&gt;&#123;&#123;a&#125;&#125; &lt;button @click="remove(index)"&gt;删除&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; let vm=new Vue(&#123; el:"#app", methods: &#123; //数组添加,删除筛选 add() &#123;this.arr.unshift(this.val);this.val = ''&#125;, remove(i) &#123;this.arr = this.arr.filter((item,index) =&gt; index !== i)&#125;&#125;, data:&#123; arr:[], val:"" &#125; &#125;)&lt;/script&gt; 绑定属性的写法1234567891011121314151617181920212223242526272829303132v-bind:src="" width/height/title.... 简写: :src="" 推荐 &lt;img src="&#123;&#123;url&#125;&#125;" alt=""&gt; 效果能出来，但是会报一个404错误 &lt;img v-bind:src="url" alt=""&gt; 效果可以出来，不会发404请求class和style: :class="" v-bind:class="" :style="" v-bind:style="" :class="[red]" red是数据 :class="[red,b,c,d]" :class="&#123;red:a, blue:false&#125;" 生效的条件 :class="json" data:&#123; json:&#123;red:a, blue:false&#125; &#125; --------------------------data:&#123; c:&#123;backgroundColor:'red’&#125; &#125; style: :style="[c]" :style="[c,d]" 注意: 复合样式，采用驼峰命名法 :style="json" 官方推荐 模板 vue 各版本Vue1.0 数据更新模板变化&lt;input v-model=’msg’/&gt;{{*msg}} 数据只绑定一次{{{msg}}} HTML转意输出 &lt;h1&gt;&lt;/h1&gt; vue2.0: bower info vue 查看版本 http://vuejs.org/到了2.0以后，有哪些变化? 在每个组件模板，不在支持片段代码组件中模板: 之前: 123&lt;template&gt; &lt;h3&gt;我是组件&lt;/h3&gt;&lt;strong&gt;我是加粗标签&lt;/strong&gt;&lt;/template&gt; 现在: 必须有根元素，包裹住所有的代码 DOM: 12345678910 &lt;template id="aaa"&gt; &lt;div&gt; &lt;h3&gt;我是组件&lt;/h3&gt; &lt;strong&gt;我是加粗标签&lt;/strong&gt; &lt;/div&gt; &lt;/template&gt;&lt;div id="box"&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; 1234567891011121314151617Vue.component('my-aaa',&#123; template:'#aaa' &#125;); window.onload=function()&#123; new Vue(&#123; el:'#box', data:&#123; msg:'welcome vue2.0' &#125; &#125;);&#125;;也可以这样写:new Vue(&#123; ....&#125;).$mount('#box') 关于组件定义Vue.extend 这种方式，在2.0里面有，但是有一些改动，这种写法，即使能用，咱也不用——废弃 12345Vue.component(组件名称,&#123; 在2.0继续能用 data()&#123;&#125; methods:&#123;&#125; template:&#125;); 2.0推出一个组件，简洁定义方式： 123var Home=&#123; template:'' -&gt; Vue.extend()&#125;; vue.extendVue2.0vue.component是定义并且注册一个组件，vue.extend是定义一个组件，然后用vue.component来注册，文档说的很明确了，vue.component的时候会在背后自动调用vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。 data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数 1&lt;div id="mount-point"&gt;&lt;/div&gt; 12345678910111213// 创建构造器var Profile = Vue.extend(&#123; template: '&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; return &#123; firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount('#mount-point') 结果如下：&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt; Vue.use()用 Vue.use() 定义全局组件123456789定义一个 button 组件// button.vue&lt;template&gt; &lt;div class="button"&gt; 按钮 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt; button.js1234567import ButtonComponent from './button.vue';const Button=&#123; install:function (Vue) &#123; Vue.component('Button',ButtonComponent) &#125;&#125;export default Button; main.js12import Button from './component/button.js';Vue.use(Button); 完成上面的步骤就可以在全局使用button组件了，其实最重要的Vue.component(‘Button’,ButtonComponent), Vue.use(Button)会执行install方法，也可以直接在main.js使用Vue.component()注册全局组件。 provide/inject 跨级组件交互 2.2.0 新增这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 12345678910111213141516// 父级组件提供 'foo'var Provider = &#123; provide: &#123; foo: 'bar' &#125;, // ...&#125;// 子组件注入 'foo'var Child = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // =&gt; "bar" &#125; // ...&#125; 如果是注入一个父级组件内部的值，provide需要作为一个函数，类似于data123456789101112131415161718192021222324252627282930const component = &#123; name: 'comp', inject: ["value"] template: ` &lt;div&gt;子组件 &#123;&#123;value&#125;&#125;&lt;/div&gt; `&#125;new CompVue(&#123; el: '#root', data() &#123; return &#123; value: '123' &#125; &#125; components:&#123; Comp &#125;, provide() &#123; // 这里如果只是一个对象的话是无法拿到this.value的 return &#123; value: this.value &#125; &#125;, template: ` &lt;div&gt; &lt;comp&gt;&lt;/comp&gt; &lt;input type="text" v-model="value"&gt; &lt;/div&gt; `&#125; 如果要监听父级组件的属性值的变化，从而自动更新子组件的值，需要手动实现监听123456789101112131415161718192021const component = &#123; name: 'comp', inject: ["data"] template: ` &lt;div&gt;子组件 &#123;&#123;data.value&#125;&#125;&lt;/div&gt; `&#125;...provide() &#123; const data = &#123;&#125; // 这是vue双向绑定的基础 Object.defineProperty(data,"value",&#123; get: () =&gt; this.value, enumerable: true &#125;) return &#123; data &#125;&#125;,... 组件Component使用方法 加data 常规的方法 组件的三层嵌套 例子:123456789101112Vue.component('my-aaa',&#123; template:'&lt;h3&gt;我是组件&lt;/h3&gt;&lt;strong&gt;我是加粗标签&lt;/strong&gt;' &#125;); window.onload=function()&#123; new Vue(&#123; el:'#box', data:&#123; msg:'welcome vue2.0' &#125; &#125;); &#125;; 1234&lt;div id="box"&gt; &lt;my-aaa&gt;&lt;/my-aaa&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; 生命周期生命周期图示 之前: init created beforeCompile compiled ready √ -&gt; mounted beforeDestroy destroyed 现在: beforeCreate 组件实例刚刚被创建,属性都没有 created 实例已经创建完成，属性已经绑定 beforeMount 模板编译之前 mounted 模板编译之后，代替之前ready ※ beforeUpdate 组件更新之前 updated 组件更新完毕 ※ beforeDestroy 组件销毁前 destroyed 组件销毁后1234567891011beforeCreate()&#123; console.log('组件实例刚刚被创建');&#125;methods:&#123; update()&#123; this.msg='大家好';&#125;, destroy()&#123; this.$destroy(); &#125;&#125; 过滤器例子:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id="app"&gt; &#123;&#123;msg | my&#125;&#125; &lt;!-- 装饰过滤器 --&gt; &lt;br&gt; &#123;&#123;'111' | test('参数')&#125;&#125; &lt;!--内置111参数--&gt; &lt;br&gt; &#123;&#123;time | date&#125;&#125; &lt;!-- 2018-6-24 16:55:50 --&gt; &lt;br&gt; &#123;&#123;number | toFixed(2)&#125;&#125; &lt;!--¥1.23--&gt; &lt;br&gt; &#123;&#123;html | filterHTML&#125;&#125; &lt;!-- p内容 --&gt; &lt;/div&gt; &lt;script&gt; Vue.filter('my', (data) =&gt; &#123; //要放在vue挂载对象前 ,注册过滤器 return '装饰' + data &#125;) Vue.filter('date', (input) =&gt; &#123; var oDate = new Date(input); return oDate.getFullYear() + '-' + (oDate.getMonth() + 1) + '-' + oDate.getDate() + ' ' + oDate.getHours() + ':' + oDate.getMinutes() + ':' + oDate.getSeconds(); &#125;) // Vue.filter('filterHtml', &#123; //// 过滤html标签 错误 // read: function(input) &#123; //model-view // return (input.replace(/&lt;[^&lt;]+&gt;/g, '')); // &#125;, // write: function(val) &#123; //view -&gt; model // return val; // &#125; // &#125;); new Vue(&#123; data: &#123; msg: '过滤器', time: new Date(), number: 1.226565, html: '&lt;p&gt;p内容&lt;/p&gt;' &#125;, filters: &#123; //内置过滤器 test(data, param) &#123; return '内置' + data + param &#125;, toFixed(input, param) &#123; //货币 小数点两位 return '¥' + input.toFixed(param) &#125;, filterHTML(input) &#123; // 过滤html标签 console.log(input) return (input.replace(/&lt;[^&lt;]+&gt;/g, '')) &#125; &#125; &#125;).$mount('#app') &lt;/script&gt; vue写法 之前: {{msg | toDou ‘12’ ‘5’}} vue2.0 现在: {{msg | toDou(‘12’,’5’)}} 到了2.0， 内置过滤器，全部删除了 自制时间过滤器 {{time | date}} 2018-6-24 16:55:50 data里:time:new Date() 1234 Vue.filter('date',(input)=&gt;&#123; var oDate=new Date(input); return oDate.getFullYear()+'-'+(oDate.getMonth()+1)+'-'+oDate.getDate()+' '+oDate.getHours()+':'+oDate.getMinutes()+':'+oDate.getSeconds();&#125;) moment.js过滤器 插件 使用插件 指令1.0自定义指令: 属性: Vue.directive(指令名称,function(参数){ this.el -&gt; 原生DOM元素 }); 2.0 &lt;div v-color=&quot;参数&quot;&gt;&lt;/div&gt; 指令名称: v-color -&gt; red 注意: 必须以 v-开头 12345678910111213141516&lt;div id="app"&gt; &lt;button v-color='flag'&gt;变色&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; directives:&#123; //自定color指令方法 color(el,bindings)&#123; el.style.background=bindings.value &#125; &#125;, el:'#app', data:&#123; flag:'red' &#125; &#125;)&lt;/script&gt; 自定拖拽指令 1234&lt;div id="app"&gt; &lt;div v-drag :style="&#123;width:'100px', height:'100px', background:'blue', position:'absolute', right:0, top:0&#125;"&gt;&lt;/div&gt; &lt;div v-drag :style="&#123;width:'100px', height:'100px', background:'red', position:'absolute', left:0, top:0&#125;"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920 //好处 可以使用多个指令控制多个divVue.directive('drag',function(el)&#123; //自定全局拖拽指令 el.onmousedown=function(ev)&#123; //按下 var disX=ev.clientX-el.offsetLeft; //鼠标到div边框的距离 var disY=ev.clientY-el.offsetTop; document.onmousemove=function(ev)&#123; //移动 var l=ev.clientX-disX; //div随移动鼠标偏移 var t=ev.clientY-disY; el.style.left=l+'px'; el.style.top=t+'px'; &#125;; document.onmouseup=function()&#123; //松起 document.onmousemove=null; document.onmouseup=null; &#125;; &#125;; &#125;); 插槽Slot文档slot: 位置、槽口 作用: 占个位置 可以代替移动标签位置默认的标签会放在default中 name=’default’这里存放的内容都是属于父级的1234567891011121314151617181920&lt;div id="box"&gt; &lt;aaa&gt;&lt;/aaa&gt;&lt;/div&gt;&lt;template id="aaa"&gt; &lt;div&gt; &lt;slot&gt;这是默认&lt;/slot&gt; &lt;!--name='default'--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var vm=new Vue(&#123; el:'#box', components:&#123; aaa:&#123; //注册组件 template:"#aaa" &#125; &#125; &#125;);&lt;/script&gt; 具名插槽 作用域插槽 动画 过渡过渡动画的类的增加和删除进入显示的动画离开隐藏的动画到2.0以后 transition 组件 过渡123456789101112&lt;button @click='showHidden'&gt;显示&lt;/button&gt; &lt;transition&gt; &lt;div style='background:red;color:white' v-show='show'&gt;内容&lt;/div&gt; &lt;/transition&gt; &lt;style scoped lang="stylus"&gt; .v-enter .v-leave-to opacity 0 .v-enter-active .v-leave-active transition opacity 3s&lt;/style&gt; 例子123&lt;transition name="fade"&gt; 运动东西(元素，属性、路由....)&lt;/transition&gt; class定义.fade-enter{}//初始状态 (开始变化).fade-enter-active{} //变化成什么样 -&gt; 当元素出来(显示) (没定义leave)会回到最初的属性.fade-leave{} 末状态.fade-leave-active{} //变成成什么样 -&gt; 当元素离开(消失) transition123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; p&#123; width:300px; height:300px; background: red; &#125; .fade-enter-active, .fade-leave-active&#123; transition: 1s all ease; &#125; .fade-enter-active&#123; //第一次点击显示宽高300 opacity:1; width:300px; height:300px; &#125; .fade-leave-active&#123; //第二点击消失到宽高100 opacity:0; width:100px; height:100px; &#125; .fade-enter,.fade-leave&#123; //开始/离开显示 opacity:1; width:100px; height:100px; &#125; &lt;/style&gt;&lt;script&gt; window.onload=function()&#123; new Vue(&#123; el:'#box', data:&#123; show:false &#125; &#125;); &#125;;&lt;/script&gt;&lt;div id="box"&gt; &lt;input type="button" value="点击显示隐藏" @click="show=!show"&gt; &lt;transition name="fade"&gt; &lt;p v-show="show"&gt;&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 不用加name属性1234567891011121314&lt;style type="text/css"&gt; /*开始显示*/ .v-enter&#123; opacity: 0; &#125; /*显示过程*/ .v-enter-active&#123; transition: opacity 1.5s;/*给transition加过渡特效(属性),持续时间为1.5秒*/ &#125; /*显示完毕*/ .v-enter-to&#123; opacity: 1; &#125; /*开始隐藏*/ .v-leave&#123; opacity: 1; &#125; /*隐藏过程*/ .v-leave-active&#123; transition: opacity 1.5s; &#125; /*隐藏完毕*/ .v-leave-to&#123; opacity: 0; &#125;&lt;/style&gt; 相关函数1234567891011&lt;transition name="fade" @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter" @before-leave="beforeLeave" @leave="leave" @after-leave="afterLeave" &gt; &lt;p v-show="show"&gt;&lt;/p&gt; &lt;/transition&gt; 12345678910111213141516171819202122methods:&#123; beforeEnter(el)&#123; console.log('动画enter之前'); &#125;, enter(el)&#123; console.log('动画enter进入'); &#125;, afterEnter(el)&#123; console.log('动画进入之后'); el.style.background='blue'; &#125;, beforeLeave()&#123; console.log('动画leave之前'); &#125;, leave()&#123; console.log('动画leave'); &#125;, afterLeave()&#123; console.log('动画leave之后'); &#125; &#125; 使用注意要有done() 动画放大的动画效果 123456789101112131415161718192021222324252627282930313233 &lt;button @click='showHidden'&gt;显示&lt;/button&gt; &lt;transition&gt; &lt;div style='background:red;color:white' v-show='show'&gt;内容&lt;/div&gt; &lt;/transition&gt;&lt;style scoped&gt; #other &#123; font-size: 32px &#125; @keyframes bounce-in &#123; 0% &#123; transform: scale(0) &#125; 50% &#123; transform: scale(1.5) &#125; 100% &#123; transform: scale(1) &#125; &#125; .v-enter-active &#123; transfrom-origin: left center; animation: bounce-in 1s; &#125; .v-leave-active &#123; transfrom-origin: left center; animation: bounce-in 1s reverse; &#125;&lt;/style&gt; 自定义动画class123&lt;transition enterActiveClass="active" leaveActiveClass="leave"&gt; &lt;div v-show='show'&gt;内容&lt;/div&gt; &lt;/transition&gt; 同时使用和设置时长1234567891011121314151617181920&lt;style&gt; .fade-enter, .fade-leave-to&#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active&#123; transition: opacity 3s; &#125;&lt;/style&gt;&lt;!--1.以过渡为时间--&gt; &lt;!--2.:duration='&#123;enter:5000,leave:10000&#125;' 自定义动画的时长10s--&gt; &lt;transition type="transition" :duration="10000" enterActiveClass="animated swing fade-enter-active" leaveActiveClass="animated shake fade-leave-active" appear appearActiveClass="animated swing" &gt; &lt;div v-show='show'&gt;内容&lt;/div&gt; &lt;/transition&gt; 动画组件切换 123456&lt;transition mode=&quot;out-in&quot;&gt; &lt;!--1.实现多个动画 加key--&gt; &lt;!--2.mode=&apos;out-in&apos;--先隐藏在进入--&gt; &lt;div v-if=&apos;show&apos; key=&quot;hello&quot;&gt;hello&lt;/div&gt; &lt;div v-else key=&quot;bye&quot;&gt;bye&lt;/div&gt; &lt;/transition&gt; 多个组件的过渡&lt;transition-group&gt;&lt;/transition-group&gt; 引入动画插件 官网 cnd &lt;link href=&quot;https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css&quot; rel=&quot;stylesheet&quot;&gt; 例子:1234567891011121314151617181920212223242526272829&lt;div id="app"&gt; &lt;input type="text" v-model="show"&gt; &lt;transition-group enter-active-class="zoomInLeft" leave-active-class="zoomOutRight"&gt; &lt;p v-show="show" class="animated" v-for="(val,index) in lists" :key="index"&gt; &#123;&#123;val&#125;&#125; &lt;/p&gt; &lt;/transition-group&gt;&lt;/div&gt;&lt;script&gt; let vm=new Vue(&#123; el:'#app', data:&#123; show:'', list:['apple','banana','orange','pear'] &#125;, computed:&#123; lists:function()&#123; var arr=[]; this.list.forEach(function(val)&#123; if(val.indexOf(this.show)!==-1)&#123; //按输入的内容渲染li的个数 arr.push(val); &#125; &#125;.bind(this)); return arr; &#125; &#125; &#125;)&lt;/script&gt; 在项目中使用 npm install animate.css –save main.js中：12import animated from 'animate.css' // npm install animate.css --save安装，在引入Vue.use(animated) 在组件中使用12345&lt;transition enterActiveClass="animated swing" leaveActiveClass="animated shake"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; 一开始就有动画效果1234567&lt;transition enterActiveClass="animated swing" leaveActiveClass="animated shake" appear appearActiveClass="animated swing" &gt; &lt;div v-show='show'&gt;内容&lt;/div&gt; &lt;/transition&gt; Velocity.jshttp://www.mrfront.com/docs/velocity.js/index.html 路由**实现单页开发的方式 通过hash记录跳转路径(可以产生历史管理) 浏览器自带历史管理的方式history(history.pushState())可能会导致404错误 开发时使用hash的方式, 上线的话我们会使用history的方式 官网介绍 cnd &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&quot;&gt;&lt;/script&gt; 例子:123456789101112131415161718192021222324252627282930&lt;!--前端后端分离 后端只负责提供接口供前端调用，像跳转都是前端自己处理的hash模式 # 开发时使用hash 不会导致404 hash方式不支持seo h5的history.pushState （上线采用h5的跳转）--&gt;&lt;div id="app"&gt; &lt;!--router-view是一个全局组件，可以直接使用--&gt; &lt;router-link to="/home" tag="button"&gt;首页&lt;/router-link&gt; &lt;router-link to="/list" tag="button"&gt;列表页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; let home = &#123;template:'&lt;div&gt;首页&lt;/div&gt;'&#125;; let list = &#123;template:'&lt;div&gt;列表页&lt;/div&gt;'&#125;; let routes = [ // 路由的映射表 配置路径和组件的关系 &#123;path:'/home',component:home&#125;, // 配置的关系就是页面级组件 &#123;path:'/list',component:list&#125; // 路径必须加/ ]; let router = new VueRouter(&#123; // 引入vue-router自带VueRouter类 // mode:'history', // h5模式 routes, linkActiveClass:'active' // 更改默认样式的类名 默认叫router-link-active &#125;); let vm = new Vue(&#123; el:'#app', router &#125;);&lt;/script&gt; 路由嵌套123456789101112&lt;div id="app"&gt; &lt;router-link to="/home"&gt;首页&lt;/router-link&gt; &lt;router-link to="/detail"&gt;详情页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id="detail"&gt; &lt;div&gt; &lt;router-link to="/detail/profile"&gt;个人中心&lt;/router-link&gt; &lt;router-link to="/detail/about"&gt;关于我&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314let routes = [ &#123; path:'/home', component:home&#125;, &#123; path:'/detail', component:detail, children:[ // children中的路径永远不带，如果带/表示是1级路由 &#123;path:'profile',component:profile&#125;, &#123;path:'about',component:about&#125;, &#123;path:'*', redirect:'/home'&#125; //404 ] &#125;,]; params参数12345&lt;!--如果用对象作为to的属性，并且使用了参数 必须给路由起个名字，通过名字跳转--&gt;&lt;router-link :to="&#123;name:'pro',params:&#123;c:1,a:2&#125;&#125;"&gt;商品1&lt;/router-link&gt;&lt;router-link to="/article/2/b"&gt;商品2&lt;/router-link&gt;&lt;router-link to="/article/3/c"&gt;商品3&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; 12345678910111213141516171819202122// #/article/2let article = &#123;template:'&lt;div&gt;第 &#123;&#123;$route.params.c&#125;&#125; 篇文章&lt;/div&gt;',// /article/2/d 匹配出一个对象// /article/:c/:a =&gt; &#123;c:2,a:'d'&#125; = this.$route.params// 详情页created()&#123; // 默认调用一次created alert('来个ajax');&#125;,watch:&#123; // 路径参数发生变化 监控参数的变化来发送ajax $route()&#123; alert('来个ajax'); &#125;&#125;;let routes = [ // 路径参数 表示值必须要有但是值是随机的 &#123;path:'/article/:c/:a',component:article&#125; //&#123;path:'/article/:c/:a',component:article,name:'pro'&#125;]; 方法路由实例方法:12345678910111213141516171819 router.push(&#123;path:'home'&#125;); //直接添加一个路由,表现切换路由，本质往历史记录里面添加一个 router.replace(&#123;path:'news'&#125;) //替换路由，不会往历史记录里面添加new Vue(&#123; router, methods:&#123; push()&#123; router.push(&#123;path:'home'&#125;); //相当于点击home &#125;, replace()&#123; router.replace(&#123;path:'user'&#125;); &#125; &#125;&#125;).$mount('#box');const router=new VueRouter(&#123; mode: 'history', //切换路径模式，变成history模式 scrollBehavior: () =&gt; (&#123; y: 0 &#125;), // 滚动条滚动的行为，不加这个默认就会记忆原来滚动条的位置 routes&#125;); 动画缓存1234567891011121314151617181920212223242526272829&lt;div id="app"&gt; &lt;router-link to="/home"&gt;首页&lt;/router-link&gt; &lt;router-link to="/list"&gt;列表页&lt;/router-link&gt; &lt;!--mode="out-in"动画的模式--&gt; &lt;transition enter-active-class="animated fadeIn" leave-active-class="animated fadeOut" &gt; &lt;!--要缓存谁 就把谁包起来即可--&gt; &lt;!--一般用作缓存：为的是后面的路由做准备，如果缓存了就不会再走created mounted钩子函数--&gt; &lt;keep-alive&gt; &lt;router-view style="position: absolute;top:50px ;left: 0;width: 100%"&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; let home = &#123;template:'&lt;div style="background: red"&gt;首页&lt;/div&gt;'&#125;; let list = &#123;template:'&lt;div style="background: green"&gt;列表&lt;/div&gt;'&#125;; let routes = [ &#123;path:'/home',component:home&#125;, &#123;path:'/list',component:list&#125;, ]; let router = new VueRouter(&#123; routes &#125;) let vm = new Vue(&#123; el:'#app', router &#125;)&lt;/script&gt; 发布 订阅emit例子:12345678910111213141516171819202122232425&lt;div id="app"&gt; 父亲：&#123;&#123;money&#125;&#125; &lt;!--child.$on('child-msg',things)--&gt; &lt;child :m="money" @child-msg="things"&gt;&lt;/child&gt;&lt;/div&gt;&lt;!--父亲绑定一些事件，儿子触发这个事件 将参数传递过去 单向数据流，父亲数据刷新 儿子就刷新--&gt;&lt;script&gt; let vm = new Vue(&#123; el:'#app', data:&#123;money:400&#125;, methods:&#123;things(val)&#123;this.money = val;&#125;&#125;, components:&#123; child:&#123; props:['m'], template:'&lt;div&gt;儿子:&#123;&#123;m&#125;&#125; &lt;button @click="getMoney()"&gt;多要钱&lt;/button&gt;&lt;/div&gt;', methods:&#123; getMoney()&#123; this.$emit('child-msg',800);// 触发自己的自定义事件，让父亲的方法执行 &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt; props属性 详细介绍 EventBus例子:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id="app"&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt;&lt;/div&gt; &lt;script&gt; let EventBus = new Vue; console.log(EventBus) let brother1 = &#123; template:'&lt;div&gt;&#123;&#123;color&#125;&#125; &lt;button @click="change"&gt;变绿&lt;/button&gt;&lt;/div&gt;', data()&#123; return &#123;color:'绿色',old:'绿色'&#125; &#125;, methods:&#123; change()&#123; EventBus.$emit('changeGreen',this.old); //告诉兄弟2 要改颜绿色 &#125; &#125;, created()&#123; EventBus.$on('changeRed',(val)=&gt;&#123; // 页面一加载兄弟1长个耳朵听 this.color = val; &#125;) &#125; &#125;; let brother2 = &#123; template:'&lt;div&gt;&#123;&#123;color&#125;&#125; &lt;button @click="change"&gt;变红&lt;/button&gt;&lt;/div&gt;', created()&#123; EventBus.$on('changeGreen',(val)=&gt;&#123; this.color = val; &#125;) &#125;, methods:&#123; change()&#123; EventBus.$emit('changeRed',this.old) &#125; &#125;, data()&#123; return &#123;color:'红色',old:'红色'&#125; &#125; &#125;; let vm = new Vue(&#123; el:'#app', components:&#123; brother1,brother2 &#125; &#125;) &lt;/script&gt; 如何实现vue中是如何实现的?1234567891011121314151617181920212223242526272829303132333435// 发布 emit 订阅 on &#123;&#125;function Girl() &#123; this._events = &#123;&#125;&#125;Girl.prototype.on = function (eventName,callback) &#123; if(this._events[eventName])&#123; // 不是第一次 this._events[eventName].push(callback); // &#123;失恋:[cry,eat,shopping]&#125; &#125;else&#123; this._events[eventName] = [callback] //&#123;失恋:[cry]&#125; &#125;&#125;;Girl.prototype.emit = function (eventName,...args) &#123; //[我，你，他] // [].slice.call(arguments,1); 把类数组变成数组后去掉第一个 // Array.from(arguments).slice(1); //arguments=&#123; '0': '失恋', '1': '我' &#125; if(this._events[eventName])&#123; this._events[eventName].forEach(cb=&gt;cb(...args));//cb.apply(this,args) &#125;&#125;;let girl = new Girl();let girl1 = new Girl();let cry = (who) =&gt;&#123;console.log(who+'哭');&#125;;let shopping = (who) =&gt;&#123;console.log(who+'购物');&#125;;let eat = (who) =&gt;&#123;console.log(who+'吃');&#125;;girl.on('失恋',cry); // &#123;失恋:[cry]&#125;girl.on('失恋',eat); // &#123;失恋:[cry,eat]&#125;girl.on('失恋',shopping); // &#123;失恋:[cry,eat,shopping]&#125;girl.emit('失恋',"我",'你');//输出结果//我哭//我吃//我购物 demo例子 demo源码 项目开始12345678# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev 创建项目: vue init webpack-simple my-project(结构简单) 创建vue1.0: vue init webpack-simple#1.0 my-project vue init webpack my-project(结构复杂) 简单的目录结构: |-index.html |-main.js 入口文件 |-App.vue vue文件，官方推荐命名法 |-package.json 工程文件(项目依赖、名称、配置) npm init –yes 生成 |-webpack.config.js webpack配置文件 package.json 中 npm run dev 会自动执行 dev“scripts”: { “dev”: “webpack-dev-server –inline –hot –port 8082” }, 使用main.js12345678910111213141516171819import Vue from 'vue';//runtime不支持template 只支持render// 这样直接引用vue 引用的并不是vue.js 引用的是vue的runtime// vue = compiler + runtime (compiler可以编译模板)// compiler有6kimport App from './App.vue';new Vue(&#123; // render函数的作用是将虚拟dom渲染成真实的dom // createElement返回的是虚拟的dom render:h=&gt;h(App) // ...App&#125;).$mount('#app');/*render:function (createElement) &#123; return createElement('h1',[ 'hello', createElement('span', '一则头条') ]);&#125;*/ package.jsondependencies和devDependencies 对象有什么区别呢？ devDependencies 里面的插件只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。 1.比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies ；2.而我们使用的一些构建工具比如glup、webpack这些只是在开发中使用的包，上线以后就和他们没关系了，所以将它写入devDependencies。 1234567"dependencies": &#123; //安装&gt;npm i 依赖名 --save "vue": "^2.4.1" 版本号跟vue-template-compiler 一样 &#125; "devDependencies": &#123; //&gt; npm i install xxx --save-dev "vue-template-compiler": "^2.4.1" //用来解析vue模板的 &#125; eslinteslint忽略 vue自定生成文件内容编辑vue templates123456789101112131415&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script type='text/ecmascript-6'&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, methods: &#123;&#125;, computed: &#123;&#125;, components: &#123;&#125; &#125;&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;&lt;/style&gt; &lt;!--scoped样式作用于当前组件的节点 使用stylus样式预编译--&gt; 兼容性ie 9-11 兼容性&gt;npm install --save-dev babel-polyfill 打开bulid/webpack.base.conf.js修改module.exports = {entry: {app: [&quot;babel-polyfill&quot;, “./src/main.js”]}, loader使用css 预编译&gt; npm i stylus stylus-loader --save-dev12345&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;#app color: #2c3e50; ....&lt;/style&gt; 其他 - less less-loader - sass sass-loader 引入bootstrap&gt; npm install bootstrap --save-dev 指定版本npm install bootstrap@3.3.0 --save-devmain.js中导入12import 'bootstrap/dist/css/bootstrap.min.css'import 'bootstrap/dist/js/bootstrap.min' 想要使用bootstrap还要&gt; npm install --save jquery popper.js 使用jquery在build/webpack-base-conf.js12345678910111213const webpack=require('webpack'); module.exports = &#123; .... // 增加一个plugins plugins: [ new webpack.ProvidePlugin(&#123; $: "jquery", jQuery: "jquery", "windows.jQuery": "jquery" &#125;) ]&#125; main.js 导入 (可以不用)import $ from &#39;jquery&#39; 图标iconfont UI组件elementUI官网 安装&gt;npm install element-ui -S // i -&gt; install // D -&gt; –save-dev // S -&gt; –save 引入 main.js 入口文件import ElementUI from ‘element-ui’import ‘element-ui/lib/theme-default/index.css’Vue.use(ElementUI); 引用英语:import locale from ‘element-ui/lib/locale/lang/en’ Vue.use(ElementUI, { locale }) minti-u移动端 ui库 下载npm install mint-ui -S -S–save 引入import Vue from ‘vue’;import Mint from ‘mint-ui’;import ‘mint-ui/lib/style.css’Vue.use(Mint); 按需引入:import { Cell, Checklist } from ‘minu-ui’;Vue.component(Cell.name, Cell);Vue.component(Checklist.name, Checklist); http://mint-ui.github.io/docs/#!/zh-cn2 论坛: Mint-ui-demo: 看着手册走了一遍 Mint-ui-demo 插件提示框 例子:新建src/plugin/notify.vue123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;div class="notify"&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; value: '我太帅了' &#125; //默认值 &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.notify &#123; width: 100px; height: 40px; background: rgba(0, 0, 0, .45); border-radius: 15px; line-height: 40px; text-align: center; color: #fff&#125;&lt;/style&gt; src/plugin/notify.js123456789101112131415161718192021222324252627282930import modal from './notify.vue';let notify = &#123; // 需要在此对象中拥有一个install方法&#125;;// this.$notify('吃饭了吗？',&#123;delay:1000&#125;)notify.install = function(Vue, options = &#123; delay: 3000 &#125;) &#123; Vue.prototype.$notify = function(message, opt = &#123;&#125;) &#123; if (notify.el) return; //多次触发,DOM还没消失 options = &#123; ...options, ...opt &#125;; // 用自己调用插件时传递过来的属性 覆盖掉默认设置好的 let V = Vue.extend(modal); // 返回的是一个构造函数的子类，参数是包含组件选项的对象 let vm = new V; let oDiv = document.createElement('div'); //创建一个div将实例挂载到元素上 vm.$mount(oDiv); if(message)&#123; vm.value = message; //提示信息 &#125; document.body.appendChild(vm.$el); // 把当前实例这个真实对象扔到页面上 notify.el = vm.$el;//先挂载DOM对象 setTimeout(() =&gt; &#123; // 延迟多少秒 将dom元素移除掉 document.body.removeChild(vm.$el); // 将实例的元素删除掉 notify.el = null //删掉DOM对象 &#125;, options.delay); &#125;&#125;;// 导出这个包含install的对象，如果使用Vue.use就会调用这个install 方法export default notify; main.js 中引用1234import notify from './plugin/notify.js';Vue.use(notify,&#123; delay:5000&#125;); // 使用带有install的对象 使用123//this.$notify()//默认值//this.$notify('默认延时3s');this.$notify('自定义提示',&#123;delay:1000&#125;); 路由使用&gt; npm i vue-router --save router中的index.js123456789101112131415import Vue from 'vue';import Home from '../components/Home.vue';import List from '../components/List.vue';import VueRouter from 'vue-router';Vue.use(VueRouter); // 和以前不一样的地方引入router必须使用use// 注册一些全局的内容export default new VueRouter(&#123; routes:[ &#123;path:'/',redirect:'/home'&#125;, &#123;path:'*',redirect:'/home'&#125;, &#123;path:'/home',component:Home&#125;, //另外的写法&#123;path:'/home',component:()=&gt;import('../components/Home.vue')&#125; &#123;path:'/list',component:List&#125;, ]&#125;); main.js12345678import router from './router'new Vue(&#123; el: '#app', render: h =&gt; h(App), store, router&#125;) 组件中使用12345&lt;div id="app"&gt; &lt;router-link to="/home" tag="button"&gt;首页&lt;/router-link&gt; &lt;router-link to="/list" tag="button"&gt;列表页&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; router构建选项重定向1234&#123; path: '/', redirect: '/app'&#125; History 模式1234const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。 给个警告页：123456const router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '*', component: NotFoundComponent &#125; ]&#125;) base1234567const router = new VueRouter(&#123; mode: 'history', base: '/base/', routes: [ &#123; path: '/hello', component: hello &#125; ]&#125;) 当访问localhost:8080/hello会变成localhost:8080/base/hello,所有的路由路径都会加上/base,当然手动删除/base还是可以打开页面 linkActiveClass 和 linkExactActiveClass12&lt;router-link to="/app"&gt;app&lt;/router-link&gt;&lt;router-link to="/login"&gt;login&lt;/router-link&gt; router-link在页面中会渲染成a标签，点击之后会添加两个类名:router-link-exact-active 和 router-link-active1234const router = new VueRouter(&#123; linkActiveClass: 'active-link', linkExactActiveClass: 'exact-active-link'&#125;) 这相当于是重新命名了两个类名。 两者的不同点：12&lt;router-link to="/login"&gt;login&lt;/router-link&gt;&lt;router-link to="/login/exact"&gt;login exact&lt;/router-link&gt; 上面这两个路由有一部分/login是相同的，在点击了login exact路由调转到/login/exact后：/login 上还保留了router-link-active类名 scrollBehavior使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 注意: 这个功能只在支持 history.pushState 的浏览器中可用。12345678910const router = new VueRouter(&#123; scrollBehavior(to, form, savedPosition)&#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125; &#125;, routes: [...]&#125;) scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。 parseQuery 和 stringifyQuery提供自定义查询字符串的解析/反解析函数。覆盖默认行为。12345678const router = new VueRouter(&#123; parseQuery (query) &#123; console.log(query) &#125;, stringifyQuery (obj) &#123; console.log(obj) &#125;&#125;) fallback当浏览器不支持 history.pushState 控制路由是否应该回退到 hash 模式。默认值为 true。 在 IE9 中，设置为 false 会使得每个 router-link 导航都触发整页刷新。它可用于工作在 IE9 下的服务端渲染应用，因为一个 hash 模式的 URL 并不支持服务端渲染。123const router = new VueRouter(&#123; fallback: true&#125;) 文档官网文档 路由元信息官网文档定义路由的时候可以配置 meta 字段： 12345678910111213141516const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, children: [ &#123; path: 'bar', component: Bar, // a meta field meta: &#123; requiresAuth: true &#125; &#125; ] &#125; ]&#125;) 那么如何访问这个 meta 字段呢？ 首先，我们称呼 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录 例如，根据上面的路由配置，/foo/bar 这个 URL 将会匹配父路由记录以及子路由记录。 一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。 下面例子展示在全局导航守卫中检查元字段：12345678910111213141516router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; // this route requires auth, check if logged in // if not, redirect to login page. if (!auth.loggedIn()) &#123; next(&#123; path: '/login', query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; next() &#125; &#125; else &#123; next() // 确保一定要调用 next() &#125;&#125;) 命名视图在一个路由下展示多个视图组件,用的并不多1234// 在这个页面中要分别展示三个视图&lt;router-view&gt;&lt;/router-view&gt; // 默认的&lt;router-view name="a"&gt;&lt;/router-view&gt; // 视图a&lt;router-view name="b"&gt;&lt;/router-view&gt; // 视图b 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; // 加s default: Foo, // 对应默认router-view a: Bar, // name = "a" b: Baz // name = "b" &#125; &#125; ]&#125;) 导航守卫路由改变时，按顺序触发的钩子函数 全局守卫12345678910const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; console.log('before each invoked'); next();&#125;)router.beforeResolve((to, from, next) =&gt; &#123; console.log('before resolve invoked'); next();&#125;) 每个守卫方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的 路由对象 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。 next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 轮播图vue-轮播图教程 swiper教程 cdn例子 例子代码 &gt;npm install vue-awesome-swiper --save 版本&quot;vue-awesome-swiper&quot;: &quot;^3.1.3&quot; main.js 全局使用12345// 导入轮播图插件import VueAwesomeSwiper from 'vue-awesome-swiper';// 使用轮播图插件Vue.use(VueAwesomeSwiper);import 'swiper/dist/css/swiper.css'; 或者在组件中使用1234567891011// require stylesimport 'swiper/dist/css/swiper.css'import &#123; swiper, swiperSlide &#125; from 'vue-awesome-swiper'export default &#123; components: &#123; swiper, swiperSlide &#125;&#125; swiper.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;template&gt; &lt;div&gt; &lt;swiper :options="swiperOption" ref="mySwiper" @set-translate="onSetTranslate"&gt; &lt;!-- 滑动内容 --&gt; &lt;!-- &lt;swiper-slide&gt;I'm Slide 1&lt;/swiper-slide&gt; --&gt; &lt;!-- &lt;swiper-slide&gt;I'm Slide 2&lt;/swiper-slide&gt; --&gt; &lt;!-- &lt;swiper-slide&gt;I'm Slide 3&lt;/swiper-slide&gt; --&gt; &lt;swiper-slide v-for='i in imgs' :key=i&gt; &lt;img :src=i&gt; &lt;/swiper-slide&gt; &lt;!-- 选项 --&gt; &lt;div class="swiper-pagination" slot="pagination"&gt;&lt;/div&gt; &lt;div class="swiper-button-prev" slot="button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next" slot="button-next"&gt;&lt;/div&gt; &lt;div class="swiper-scrollbar" slot="scrollbar"&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'carrousel', data() &#123; return &#123; imgs: [ 'https://m.360buyimg.com/mobilecms/s1125x549_jfs/t11578/40/1816587279/47894/42dba539/5a0d36f7N149b127f.jpg!q70.jpg', 'https://img1.360buyimg.com/da/jfs/t14110/207/712950073/377098/a23521b1/5a129386N7f39c763.jpg', 'https://img1.360buyimg.com/da/jfs/t13657/160/507550199/94542/6e62a404/5a0d3658Nce159095.jpg' ], swiperOption: &#123; // some swiper options/callbacks // 所有的参数同 swiper 官方 api 参数 pagination: &#123; //分页 el: '.swiper-pagination' //class &#125;, navigation: &#123; //左右按钮 nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev' &#125;, loop:true //循环 &#125; &#125; &#125;, computed: &#123; swiper() &#123; return this.$refs.mySwiper.swiper &#125; &#125;, mounted() &#123; // 然后你就可以使用当前上下文内的swiper对象去做你想做的事了 console.log(this.swiper) // this.swiper.slideTo(3, 1000, false) 跳转到第三张 &#125;, methods: &#123; onSetTranslate() &#123; //swiper滑动触发 console.log('onSetTranslate') &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;img &#123; width: 100%&#125;&lt;/style&gt; mixins混入教程 本地存储安装 npm install good-storage版本 :&quot;good-storage&quot;: &quot;^1.0.1&quot; 1234567891011121314import storage from 'good-storage' methods:&#123; setStorage()&#123; //保存 storage.set('XXX_KEY','这是本地保存数据') storage.set('ARR_KEY',arr) //保存数组 &#125;, getStorage()&#123; //获取 this.msg=storage.get('XXX_KEY') this.arr=storage.get('ARR_KEY',[]) //获取数组 &#125;, removeStorage()&#123; //删除 storage.remove('XXX_KEY') &#125; &#125; axios教程 npm install axios -Daxios:可以配置,不能vue.use(axios) 例子src/api/index.js12345678910111213import axios from 'axios';// 增加默认的请求的路径// 拦截器axios.defaults.baseURL = 'http://localhost:3000';axios.interceptors.response.use((res)=&gt;&#123; return res.data; // 在这里统一拦截结果 把结果处理成res.data&#125;);// 获取轮播图数据 , 返回的是一个promise对象export let getSliders = () =&gt;&#123; return axios.get('/sliders').catch(e=&gt;&#123; console.log("服务器没打开",e) &#125;)&#125;; 建立服务器数据: (根目录)./mock/sliders.js12345module.exports=[ 'https://m.360buyimg.com/mobilecms/s1125x549_jfs/t11578/40/1816587279/47894/42dba539/5a0d36f7N149b127f.jpg!q70.jpg', 'https://img1.360buyimg.com/da/jfs/t14110/207/712950073/377098/a23521b1/5a129386N7f39c763.jpg', 'https://img1.360buyimg.com/da/jfs/t13657/160/507550199/94542/6e62a404/5a0d3658Nce159095.jpg'] 根目录/mock/server.js1234567891011121314151617181920212223242526let http = require('http');let fs = require('fs');let url = require('url');//访问根地址:http://localhost:3000// 获取本地轮播图数据 let sliders = require('./sliders');http.createServer((req, res) =&gt; &#123; //设置请求头 res.setHeader("Access-Control-Allow-Origin", "*"); res.setHeader("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With"); res.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS"); res.setHeader("X-Powered-By", ' 3.2.1') if (req.method == "OPTIONS") return res.end(); /*让options请求快速返回*/ let &#123; pathname, query &#125; = url.parse(req.url, true); // true把query转化成对象 if (pathname === '/sliders') &#123; // /sliders返回轮播图数据 res.setHeader('Content-Type', 'application/json;charset=utf8'); return res.end(JSON.stringify(sliders)); &#125;&#125;).listen(3000, function() &#123; console.log("http://localhost:3000")&#125;) 组件中使用123456789101112&lt;button @click='getData'&gt;获取轮播数据&lt;/button&gt;&lt;script&gt;//在build/webpack.base.conf.js 配置路径 import &#123;getSliders&#125; from '@api/index.js' methods:&#123; async getData()&#123; //异步获取数据 let sliders=await getSliders() console.log(sliders) //数据 &#125; &#125;&lt;/script&gt; axios.all方法123456789101112export let getSliders = () =&gt;&#123; return axios.get('/sliders')&#125;;// 获取热门图书接口export let getHotBook = () =&gt;&#123; return axios.get('/hot');&#125;;//axios.allexport let getAll = () =&gt;&#123; return axios.all([getSliders(),getHotBook()]);&#125;; 组件中使用12345678import &#123;getAll&#125; from '../api'; methods: &#123; async getData()&#123; let [sliders,hotBooks] = await getAll();// [sliders,books] this.sliders = sliders; this.hotBooks = hotBooks; &#125; &#125; axios拦截1234567891011121314151617181920212223242526272829303132//axios的一些配置，比如发送请求显示loading，请求回来loading消失之类的//axios.interceptors.request.use(function (config) &#123; //配置发送请求的信息 stores.dispatch('showLoading') console.log(config) return config;&#125;, function (error) &#123; return Promise.reject(error);&#125;);//可以再vue中加入&lt;keep-alive&gt;加载的内容&lt;/keep-alive&gt;axios.interceptors.response.use(function (response) &#123; //配置请求回来的信息 stores.dispatch('hideLoading') return response;&#125;, function (error) &#123; return Promise.reject(error);&#125;);//axios.defaults.baseURL='http://localhost:8082/'; 设置请求的根路径//axios.defaults.baseURL = (process.env.NODE_ENV !=='production' ? config.dev.httpUrl:config.build.httpUrl);//axios.defaults.headers.post['Content-Type']= 'application/x-www-form-urlencoded'; //设置post头部默认信息Vue.prototype.$http = axios //其他页面在使用axios的时候直接 this.$http就可以了//Object.keys(对象) [1,2,3]console.log(Object.keys("foo")); [0,1,2] 跨域代理跨域proxy vuex理解 安装&gt; npm i vuex 例子 点击+1 store目录 –|index.js–|state.js–|getters.js–|mutations-type.js–|mutations.js–|actions.js state.js12345const state=&#123; count:0&#125;export default state getter.js1export const count =state=&gt;state.count //获取state mutation-type.js12//方法常量export const INCREMENT="INCREMENT" mutations.js123456789import * as types from "./mutation-type" const mutations=&#123; //方法 [types.INCREMENT](state)&#123; state.count=state.count+1 //设置新state &#125;&#125;export default mutations actions.js12345import * as types from './mutation-type'export const increment=function(&#123;commit&#125;)&#123; commit(types.INCREMENT) //提交方法&#125; index.js1234567891011121314151617181920import Vue from "vue"import Vuex from "vuex"import * as actions from "./actions"import * as getters from "./getters"import state from "./state"import mutations from "./mutations"import createLogger from "vuex/dist/logger" //logVue.use(Vuex)const debug=process.env.NODE_ENV!=="production"//开启调试export default new Vuex.Store(&#123; actions, getters, state, mutations, strict:debug, plugins:debug?[createLogger()]:[]&#125;) main.js1234567import store from './store'new Vue(&#123; el: '#app', render: h =&gt; h(App), store&#125;) 组件中使用vuex123456789101112131415161718192021&lt;button @click='increment'&gt;+1&lt;/button&gt;&lt;button @click='add'&gt;+1&lt;/button&gt;&lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;&lt;script&gt;import &#123;mapGetters,mapActions,mapMutations&#125; from 'vuex' computed:&#123; ...mapGetters([ 'count' ]) &#125;, methods:&#123; ...mapActions([ 'increment' ]), ...mapMutations(&#123; 'add':'INCREMENT' //改名 &#125;), &#125;&lt;/script&gt; 打包项目构建修改打包文件名 不放在服务器根目录访问 要修改config/index,js build: { assetsPublicPath: &#39;./&#39;} &gt; npm run build 生成dist文件夹—&gt;static文件夹和index.html 把static文件夹和index.html放在服务器server.js同文件内 server.js123456789101112131415161718192021222324252627282930313233343536373839let http = require('http');let fs = require('fs');let url = require('url');//访问根地址:http://localhost:3000// 获取本地轮播图数据 let sliders = require('./sliders');http.createServer((req, res) =&gt; &#123; //设置请求头(打包不用设置) // res.setHeader("Access-Control-Allow-Origin", "*"); // res.setHeader("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With"); // res.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS"); // res.setHeader("X-Powered-By", ' 3.2.1') // if (req.method == "OPTIONS") return res.end(); /*让options请求快速返回*/ let &#123; pathname, query &#125; = url.parse(req.url, true); // true把query转化成对象 if (pathname === '/sliders') &#123; // /sliders返回轮播图数据 res.setHeader('Content-Type', 'application/json;charset=utf8'); return res.end(JSON.stringify(sliders)); &#125; // 读取本地html放在服务器中; fs.stat('.'+pathname,function (err,stats) &#123; //读取一个路径 / if(err)&#123; fs.createReadStream('index.html').pipe(res); &#125;else&#123; if(stats.isDirectory())&#123; let p = require('path').join('.'+pathname,'./index.html'); fs.createReadStream(p).pipe(res); &#125;else&#123; fs.createReadStream('.'+pathname).pipe(res); &#125; &#125; &#125;);&#125;).listen(3000, function() &#123; console.log("http://localhost:3000")&#125;) 运行 &gt; node server.js 访问:http://localhost:3000 –report 图形字体错误使用 vue build 之后做网站请求，发现 woff 字体无法获取，调试发现：真实路径应该是xxx/static/fonts/icomoon.0125455.woff浏览器实际加载路径为：xxx/static/css/static/fonts/icomoon.0125455.woff解决方法：webpack 配置问题在 build/webpack.prod.conf.js中 extract :true 改为 fasle即可。12345module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: false &#125;) 真机调试第一种方法:打开package.json添加–host 0.0.0.0&quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --inline --progress --config build/webpack.dev.conf.js&quot; 查看ip地址打开cmd&gt; ipconfig访问 http://192.168.1.101:8080/#/home如果白屏 不支持es6语法的话&gt; npm install babel-polyfill --save 第二种方法打开config/index.js修改host:localhost为ip地址 better-scroll移动端的框架官网例子 文档]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap]]></title>
    <url>%2F2018%2F06%2F16%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[基础什么是响应式布局 Responsive Web Design:响应式/自适应网页设计2010年5月,有Ethan Marcotte 专为改进互联网浏览体验而提出的概念,基本概念:集中创建页面的图片和排版大小,可以智能地根据用户行为使用的设备环境(系统平台,屏幕尺寸,屏幕方向等)进行相应的布局-即一个页面可以兼容各种终端,无需编写多个不同的版本 响应式/自适应网页:一个页面,可以在各种不同的设备下浏览,都有不错的浏览体验.响应式网页的三个特征:1.流式布局2.可伸缩的图片和字体3.CSS3 Media Query Bootstrap Bootstrap( bootcss.com )是一个框架HTML/CSS/JS框架，适用于移动设备优先的响应式网页。 Bootstrap分为五部分：1.起步(Startup)2.全局CSS样式(Global CSS)3.组件(Component)4.插件(Plugin)5.定制(Customize) 起步第一部分：起步 (1)下载Bootstrap (2)安装Bootstrap (3)网页基本模板 123456789101112131415&lt;html lang="zh-CN"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;!--......html代码--&gt;&lt;script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;html lang=&quot;zh-CN&quot;&gt;lang属性的两个作用：(1)告诉浏览器翻译时如何确定当前网页的基础语言 (2)告诉读屏软件当前页面的基础发音 meta name=”viewport”详讲 IE浏览器的兼容性问题 X-UA-Compitable: Cross-UserAgent-Compatible，该元标签只有IE浏览器支持。&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; 设置IE的兼容模式为edge——最新版，尽可能向行业标准看齐。 IE6 IE7 IE8 IE9 IE10 IE11 Windows10 IE彻底被抛弃，新浏览器命名为 Edge html5shiv.js由@afarkas @jdalton @jon_neal @rem编写的一个JS自调用脚本，用于让老IE支持H5新标签。 respond.js由Scott编写的一个JS自调用脚本，用于让老IE浏览器支持CSS3MediaQuery技术，从而实现响应式网页的编写 检查错误工具Bootlint工具:是一个js，由Bootstrap官方提供，用于检测使用Bootstrap的页面中常见的HTML错误、class使用方面的错误——默认情况下浏览器是检查不出来的。123456789/*Bootlint是一个Bootstrap使用方面的错误检测工具*/(function () &#123; var s = document.createElement("script"); s.onload = function () &#123; bootlint.showLintReportForCurrentDocument([]); &#125;; s.src = "https://maxcdn.bootstrapcdn.com/bootlint/latest/bootlint.min.js"; document.body.appendChild(s)&#125;)(); 基本样式h1-h6标题Bootstrap 提供的css Reset 123456789101112* &#123; box-sizing: border-box; &#125;body &#123; font ...; color: #333; background: ...; margin: 0;&#125;h1 &#123; font-size: ; margin-top: 20px; margin-bottom: 10px;&#125;h2 &#123; font-size: ; margin-top: 20px; margin-bottom: 10px;&#125;h3 &#123; font-size: ; margin-top: 20px; margin-bottom: 10px;&#125;h4 &#123; font-size: ; margin-top: 10px; margin-bottom: 10px;&#125; h5 &#123; font-size: ; margin-top: 10px; margin-bottom: 10px;&#125; h6 &#123; font-size: ; margin-top: 10px; margin-bottom: 10px;&#125; a &#123; color:; text-decoration: ;&#125;img &#123; border: 0; vertical-align: middle; &#125;p &#123; margin-bottom:10px; &#125;...... 按钮Bootstrap全局CSS样式——按钮——简单&amp;有趣1234567891011121314151617 .btn &#123; padding:; border: ;&#125; .btn-default &#123; color:; background:; border-color:;&#125;---------------------- .btn-danger .btn-success .btn-warning .btn-info .btn-primary--------------------- .btn-lg 大 .btn-sm 小 .btn-xs 超小---------------------- .btn-block 块按钮---------------------- .pull-left &#123; float: left; &#125; 浮动 .pull-right &#123; float: right; &#125; 浮动 1&lt;button type="button" class="btn btn-default"&gt;（默认样式）Default&lt;/button&gt; disabled=&quot;disabled&quot;为 &lt;button&gt; 元素添加 disabled 属性，使其表现出禁用状态。我们把 .disabled 作为工具类使用，就像 .active 类一样，因此不需要增加前缀。 1&lt;a href="#" class="btn btn-default btn-lg disabled" role="button"&gt;Link&lt;/a&gt; 关闭按钮 1&lt;button type="button" class="close" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; 按钮组123456.btn-group 水平按钮组 .btn-group-vertical 竖直按钮组 .btn-group.btn-group-justified 水平且两端对齐的按钮组 .btn-group-lg .btn-group-sm .btn-group-xs 例子: 1234567891011121314151617 &lt;div class="btn-group"&gt; &lt;a class="btn btn-success" href="#"&gt; &lt;span class="glyphicon glyphicon-fast-backward"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="btn btn-success" href="#"&gt; &lt;span class="glyphicon glyphicon-play"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="btn btn-success" href="#"&gt; &lt;span class="glyphicon glyphicon-pause"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="btn btn-success" href="#"&gt; &lt;span class="glyphicon glyphicon-stop"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="btn btn-success" href="#"&gt; &lt;span class="glyphicon glyphicon-fast-forward"&gt;&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 图片SVG 图像和 IE 8-10在 Internet Explorer 8-10 中，设置为 .img-responsive 的 SVG 图像显示出的尺寸不匀称。为了解决这个问题，在出问题的地方添加 width: 100% \9; 即可。Bootstrap 并没有自动为所有图像元素设置这一属性，因为这会导致其他图像格式出现错乱。 浏览器的兼容请时刻牢记：Internet Explorer 8 不支持 CSS3 中的圆角属性。 1234.img-rounded 加圆角 .img-circle 椭圆 .img-thumbnail 缩略图片/拇指图片 响应式图片 .img-responsive 响应式图片 文本设置文本颜色 123456789101112131415161718192021.text-danger 红 .text-success 绿 .text.warning 黄 .text-info 浅蓝 .text-primary 深蓝 ---------------设置背景颜色 .bg-danger .bg-success .bg-warning .bg-info .bg-primary -------------- .text-left .text-right .text-center .text-justify 文本两端调整对齐(适用英文) --------------------------- .text-uppercase .text-lowercase .text-capitalize 首字大写 列表列表.list-unstyled 没样式 .list-inline 在一行 浮动浮动 代码代码 表单表单 Bootstrap中的表单分为三种： (1)默认表单 123456789101112131415161718 &lt;form&gt;&lt;div class="form-group"&gt; &lt;label class="control-label" for="uname"&gt;用户名：&lt;/label&gt; &lt;input class="form-control" id="uname" type="text"&gt; &lt;span class="help-block"&gt;用户名长度在6~12位之间&lt;/span&gt;&lt;/div&gt;&lt;!--密码....--&gt;&lt;!--Bootstrap编码规范中指定：单选/复选按钮要放在label中--&gt;&lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt;我接受本站的使用条款 &lt;/label&gt;&lt;/div&gt; &lt;div class="form-group"&gt; &lt;input type="submit" class='btn btn-default'&gt; &lt;/div&gt;&lt;/form&gt; (2)行内表单.form-group 行内分布1&lt;form class="form-inline"&gt;....&lt;/form&gt; (3)水平表单 默认的栅格系统：.container &gt; .row &gt; .col-xx水平表单中栅格系统：.form-horizontal &gt; .form-group &gt; .col-xx使用栅格系统来控制label/input/help-block的宽度 123456789101112131415161718&lt;form class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;!--label文字右对齐的写法--&gt; &lt;label class="control-label col-sm-3" for="uname1"&gt;用户名：&lt;/label&gt; &lt;div class="col-sm-6"&gt;&lt;input class="form-control" id="uname1" type="text"&gt;&lt;/div&gt; &lt;span class="help-block col-sm-3"&gt;用户名长度在6~12位之间&lt;/span&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;!--label左对齐的方法--&gt; &lt;div class="col-sm-3"&gt; &lt;label class="control-label" for="upwd1"&gt;密 码：&lt;/label&gt; &lt;/div&gt; &lt;div class="col-sm-6"&gt;&lt;input class="form-control" id="upwd1" type="password"&gt;&lt;/div&gt; &lt;span class="help-block col-sm-3"&gt;密码中必须包含数字、字母&lt;/span&gt; &lt;/div&gt; &lt;form&gt; 下拉组件例子:123456789101112&lt;div class="dropdown"&gt; &lt;!--相对定位的父元素--&gt; &lt;a data-toggle="dropdown" class="btn btn-default" href="#"&gt; 产品大全 &lt;span class="caret"&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;!--绝对定位--&gt; &lt;li&gt;&lt;a href="#"&gt;电视&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;洗衣机&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;冰箱&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;尿不湿&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;奶嘴&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 表格&lt;table class=&quot;table&quot;&gt;&lt;/table&gt; 条纹状表格通过 .table-stripe 类可以给 &lt;tbody&gt; 之内的每一行增加斑马条纹样式条纹状表格是依赖 :nth-child CSS 选择器实现的，而这一功能不被 Internet Explorer 8 支持。&lt;table class=&quot;table table-striped&quot;&gt;&lt;/table&gt; 123456.table .table-bordered 带边框的表格 .table-responsive 响应式表格 注意：使用在table的父元素上，而不是table上 --------- .table-striped 隔行变色的表格 .table-hover 带悬停效果的表格 栅格化系统Web开发中页面布局可以采用的方式： (1)使用TABLE做布局优势：简单不易出错 不足：加载效率 (2)使用DIV+CSS做布局优势：加载速度快、灵活 不足：不易控制 (3)使用Bootstrap提供的栅格(Grid Layout)布局系统优势：加载速度快、灵活、支持响应式功能、容易控制（有行/列的概念，但使用DIV+CSS实现）栅格布局系统的特点： (1)所有的行必须放在容器中： .container或.container-fluid (2)分为多行(row)，一行中平均分为12列(col) (3)网页内容只能放在列(col)中，不能直接放在行(row) (4)可以在col中再嵌套row (5)col分为四大类： col-xs col-sm col-md col-lg (6)col-md-x x值可为1~12，值就为某个列的宽度( x/12 ) (7)可以为一个列指定不同屏幕下的不同宽度 (8) col-lg-x 只对大PC屏幕有效 col-md-x 对普通PC和大PC屏幕都有效 col-sm-x 对平板、PC、大PC屏幕都有效 col-xs-x 对手机、平板、PC大PC屏幕都有效 (9) .hidden-lg 当前列只在大PC屏幕下隐藏.hidden-md 当前列只在PC屏幕下隐藏.hidden-sm 当前列只在平板屏幕下隐藏.hidden-xs 当前列只在手机屏幕下隐藏 (10) .col-md-offset-x——x值可为1~12 偏移量 .container的宽度问题： 当屏幕宽度&gt;1200px（超大PC显示器-lg）： 容器宽1170px 当屏幕宽度&gt;992px（普通PC显示器-md）: 容器宽970px 当屏幕宽度&gt;768px（平板显示器-sm）: 容器宽750px 当屏幕宽度&lt;768px（手机显示器-xs）: 容器宽auto .container-fluid的宽度： width: auto before + after 面试题：Bootstrap布局系统中容器的特点？ (1)宽度做了媒体查询。(2)添加了前置和后置内容生成，可以防止子元素的越界、浮动造成的影响。 使用1234&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-1"&gt;md-1&lt;/div&gt; &lt;/div&gt; offset偏移列的偏移问题(offset)1234.col-xs-offset-1~.col-xs-offset-12 在lg/md/sm/xs屏幕下偏移.col-sm-offset-1~.col-sm-offset-12 在lg/md/sm屏幕下偏移.col-md-offset-1~.col-md-offset-12 在lg/md屏幕下偏移.col-lg-offset-1~.col-lg-offset-12 在lg屏幕下偏移 列偏移栅格布局系统中列的偏移和排序 列偏移（offset）： 用途-在不满的一行中某个列及后续的列向右偏移col-xs/sm/md/lg-offset-*提示：某列偏移后，会影响后续的所有列。 列排序（pull/push）： 用途-在一行中调整某列的位置，且不影响其他列 .col-lg-push-x 在lg屏幕下将列向右推指定的宽度.col-lg-pull-x 在lg屏幕下将列向左拉指定的宽度.col-md-push-x 在md/lg屏幕下将列向右推指定的宽度.col-md-pull-x 在md/lg屏幕下将列向左拉指定的宽度.col-sm-push-x 在sm/md/lg屏幕下将列向右推指定的宽度.col-sm-pull-x 在sm/md/lg屏幕下将列向左拉指定的宽度.col-xs-push-x 在xs/sm/md/lg屏幕下将列向右推指定的宽度.col-xs-pull-x 在xssm/md/lg屏幕下将列向左拉指定的宽度 123456789101112&lt;style&gt; div&#123; border: 1px solid cadetblue; &#125; &lt;/style&gt;&lt;div class="container"&gt;&lt;div class="row"&gt; &lt;div class="col-xs-4 col-xs-push-8"&gt;1.XS-4&lt;/div&gt; &lt;div class="col-xs-2 col-xs-pull-4"&gt;2.XS-2&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 第一列前进8格,第二列在4的位置退4格 导航条1.组件——导航——小重点&amp;简单 提示：此处的导航不是指导航条！ Bootstrap提供了两种形式的导航： (1)标签页式导航&lt;ul class=&quot;nav nav-tabs&quot;&gt;&lt;/ul&gt; 1234567891011&lt;ul class="nav nav-tabs"&gt; &lt;li&gt;&lt;a data-toggle="tab" href="#p1"&gt;十元套餐&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a data-toggle="tab" href="#p2"&gt;二十元套餐&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a data-toggle="tab" href="#p3"&gt;三十元套餐&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--内容切换--&gt;&lt;div class="tab-content"&gt; &lt;div id="p1" class="fade tab-pane"&gt;十元套餐详情&lt;/div&gt; &lt;div id="p2" class="fade in tab-pane active"&gt;二十元套餐详情&lt;/div&gt; &lt;div id="p3" class="fade tab-pane"&gt;三十元套餐详情&lt;/div&gt;&lt;/div&gt; (2)胶囊式导航&lt;ul class=&quot;nav nav-pills nav-justified&quot;&gt;&lt;/ul&gt;.nav-justified 两端对齐显示导航(最好加上栅格) (3)竖直放置的胶囊式导航&lt;ul class=&quot;nav nav-pills nav-stacked&quot;&gt;&lt;/ul&gt; 面包屑 .breadcrumb 12345&lt;ol class="breadcrumb"&gt; &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2013&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;十一月&lt;/li&gt;&lt;/ol&gt; 分页.pagination分页（Pagination）123456789&lt;ul class="pagination"&gt; &lt;li&gt;&lt;a href="#"&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 页头(页面大小标题).page-header 标签.label 徽章(未读信息).badge 巨幕(显示大内容).jumbotron 水井(凹陷内容插图效果的容器) .well 响应式导航条响应式导航条：在PC和平板中默认要显示所有的内容；但在手机中导航条中默认只显示“LOGO/Brand”，以及一个“菜单折叠展开按钮”，只有单击折叠按钮后才显示所有的菜单项。 基础class： .navbar Bootstrap中导航条的按位置：1)顶部导航条2)底部导航条 Bootstrap中导航条的按颜色：1)浅色底深色的字 .navbar-default2)深色底浅色的字 .navbar-inverse Bootstrap中导航条的按定位：1)相对定位position: relative 默认值2)固定定位position: fixed .navbar-fixed-top/bottom 固定定位要加1234body &#123; /*margin-top: 50px;*/ margin-bottom: 50px;&#125; 导航条的结构：123456789101112131415161718 &lt;div class="navbar 颜色 定位"&gt; &lt;div class="container"&gt;&lt;!--导航条的头部：商标+按钮--&gt;&lt;div class="navbar-header"&gt;&lt;a class="navbar-brand"&gt;&lt;img src="img/logo.png" alt="" style="margin-top:-16px;"&gt;&lt;button class="navbar-toggle"&gt;&lt;/div&gt;&lt;!--导航条折叠菜单：菜单、按钮、搜索框、链接、文本...--&gt;&lt;div class="navbar-collapse"&gt;&lt;ul class="nav navbar-nav"&gt;&lt;form class="navbar-form"&gt;&lt;button class="navbar-btn"&gt;&lt;span class="navbar-text"&gt;&lt;a class="navbar-link navbar-text"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; 完整的nav导航栏例子: 移动端显示 完整代码通过添加 .navbar-inverse类可以改变导航条的外观。123456789101112131415161718192021222324252627282930313233343536373839&lt;div class="navbar navbar-default"&gt; &lt;div class="container"&gt; &lt;!--导航条头部--&gt; &lt;div class="navbar-header"&gt; &lt;!--logo/商标--&gt; &lt;a class="navbar-brand" href="#"&gt;TARENA&lt;/a&gt; &lt;!--折叠菜单触发按钮--&gt; &lt;button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#my-collapse"&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;!--导航条折叠部分--&gt; &lt;div class="collapse navbar-collapse" id="my-collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Product&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!--注册和登录--&gt; &lt;a class="navbar-link navbar-text navbar-right" href="#"&gt;REGISTER&lt;/a&gt; &lt;span class="navbar-text navbar-right"&gt;|&lt;/span&gt; &lt;button class="navbar-btn btn btn-success navbar-right" type="button"&gt;LOGIN&lt;/button&gt; &lt;!--搜索部分--&gt; &lt;form class="navbar-form navbar-right" action=""&gt; &lt;div class="form-group has-feedback"&gt;&lt;!--has-feedback输入框中放置的图标，称为“反馈图标”--&gt; &lt;!--Screen Reader Only 仅屏幕阅读软件可见--&gt; &lt;label class="sr-only" for="kw"&gt;搜索：&lt;/label&gt; &lt;input class="form-control" type="text" id="kw" placeholder="Search..."&gt; &lt;span class="form-control-feedback glyphicon glyphicon-search"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 菜单实现折叠效果说明在button标签加入 实现响应菜单下拉1&lt;button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#my-collapse"&gt; 在折叠菜单中加入id=”my-collapse” 和.collapse1&lt;div class="collapse navbar-collapse" id="my-collapse"&gt; 侧边导航affix123456789101112131415161718192021222324252627282930&lt;!--监听body滑动--&gt;&lt;body style="position: relative" data-spy="scroll" data-target="#myaffix"&gt;&lt;div class="container"&gt; &lt;h1&gt;jQuery插件——附加导航/侧方导航(Affix)&lt;/h1&gt; &lt;h2&gt;《西游记》全文&lt;/h2&gt; &lt;div class="row"&gt; &lt;div class="col-md-10"&gt; &lt;h4 id="c1"&gt;第一章 石猴出世&lt;/h4&gt; &lt;p class="text-justify"&gt;第一章内容&lt;/p&gt; &lt;h4 id="c2"&gt;第二章 东海学艺&lt;/h4&gt; &lt;p class="text-justify"&gt;第二章 内容&lt;/p&gt; &lt;h4 id="c3"&gt;第三章 龙宫借宝&lt;/h4&gt; &lt;p class="text-justify"&gt;第三章 内容 &lt;/p&gt; &lt;h4 id="c4"&gt;第四章 大闹天宫&lt;/h4&gt; &lt;p class="text-justify"&gt;第四章 内容&lt;/p&gt; &lt;/div&gt;&lt;!--data-spy="affix" 竖右导航条--&gt; &lt;div class="col-md-2 hidden-sm hidden-xs"&gt; &lt;div data-spy="affix" data-offset-top="100" id="myaffix"&gt; &lt;!--滑动100后不滑动了 联动body--&gt; &lt;ul class="nav nav-pills nav-stacked"&gt; &lt;li&gt;&lt;a href="#c1"&gt;第1章&lt;/a&gt;&lt;/li&gt; &lt;!--自动加.ative和跳转对应id--&gt; &lt;li&gt;&lt;a href="#c2"&gt;第2章&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#c3"&gt;第3章&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#c4"&gt;第4章&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 滚动监听(scrollspy)随着页面内容的滚动，某个导航中的项目，会自动的更改.active位置。 实现思路：(1)页面中必须首先有一个导航菜单(.nav)——其中可以定义一个菜单项为.active(2)导航菜单中的超链接的href属性值必须和页面中的某个锚点名一样(3)为页面添加滚动事件的监听函数1234if(body滚动的距离 === 某个锚点距离顶端的距离)&#123;此锚点对应的超链接的父元素li添加.active； &#125;&#125; 图形字体glyphicons官网 Glyphicons是一套收费的图标字体，提供了Web/移动开发中常用的小图标 Bootstrap中可以免费使用这套字体中的250+个；以服务器端字体形式出现的，即客户端若访问了使用Glyphicons字体的网站，会自动从服务器端下载对应的字体文件。 Glyphicons 字体图标 实现原理12345678910111213@font-face &#123; font-family: 'Glyphicons Halflings'; src: url('../fonts/glyphicons-halflings-regular.eot');&#125;.glyphicon &#123; position: relative; top: 1px; display: inline-block; font-family: 'Glyphicons Halflings'; font-style: normal; font-weight: normal; line-height: 1;&#125; 提示1.图标字体的本质不是图片，而是字体；故凡是可以使用文字的地方都可以使用不同字体2.glyphicon图标字体只能用于“空元素”——不包含任何内容或子元素！如：123&lt;a class="btn btn-info" href="#"&gt; &lt;span class="glyphicon glyphicon-refresh"&gt;&lt;/span&gt; &lt;!--刷新图形字体--&gt;&lt;/a&gt; 插件1.插件——概述 插件 Bootstrap基于jQuery提供了十几个插件函数（类似于jQueryUI插件库），每个插件对应一个.js文件，可以单独引用，也可以整体引用(bootstrap.js)。 调用上述十几个插件可以用两种格式： (1)传统的JS方式调用： $(...).dropdown(); $().tab(...); (2)使用data-*扩展属性方式调用： &lt;a data-toggle=&quot;dropdown&quot;&gt; 2.插件——下拉菜单 (1)$().dropdown( ); (2)&lt;a data-toggle=&quot;dropdown&quot;&gt; 3.插件——标签页(tab) (1) $().tab(); (2) &lt;a data-toggle=&quot;tab&quot;&gt; 弹出框 (1)工具提示框(tooltip) data-toggle=&quot;tooltip&quot; (2)弹出框(popover) data-toggle=&quot;popover&quot; (3)警告框(alert) —— 小重点&lt;div class=&quot;alert alert-四种颜色(danger ...) alert-dismissible&quot;&gt;&lt;span class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/span&gt;内容 (4)模态对话框(modal) —— 小重点模态框定义：在父窗体中弹出一个子窗体，子窗体若不关闭，父窗体就无法获得焦点，同时父子窗体间还可以传递数据。window.alert()/confirm()/prompt()就是典型例子。模态框必需的结构：123456789&lt;div class="modal"&gt; &lt;!--半透明的黑色遮罩层--&gt; &lt;div class="modal-dialog"&gt; &lt;!--宽/定位--&gt; &lt;div class="modal-content"&gt; &lt;!--边框/背景色/阴影--&gt; &lt;div class="modal-header"&gt;头部&lt;/div&gt; &lt;div class="modal-body"&gt;主体&lt;/div&gt; &lt;div class="modal-footer"&gt;尾部&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 工具提示Tooltips 12345678&lt;button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="bottom" title="Tooltip on bottom"&gt;Tooltip on bottom&lt;/button&gt;$(function () &#123; $('[data-toggle="tooltip"]').tooltip()&#125;) 警告框1234567&lt;div class="alert alert-danger alert-dismissible fade in"&gt; &lt;!--可以删除这条信息--&gt; &lt;span class="close" data-dismiss="alert"&gt;&amp;times;&lt;/span&gt; &lt;p&gt; &lt;span class="glyphicon glyphicon-alert"&gt;&lt;/span&gt; 警告：没有更多的好友消息了。 &lt;/p&gt;&lt;/div&gt; 模态框显示一个模态框 &lt;a href=&quot;#模态框ID&quot; data-toggle=&quot;modal&quot;&gt; &lt;button data-toggle=&quot;modal&quot; data-target=&quot;#模态框ID&quot;&gt; 链接模态框11234567891011&lt;a class="btn btn-success" href="#mymodal1" data-toggle="modal"&gt;LOGIN&lt;/a&gt;&lt;!--模态弹出框推荐写在body的最后——fixed定位--&gt;&lt;div id="mymodal1" class="modal fade" tabindex="-1"&gt; &lt;!--半透明的黑色遮罩层 按tab键也无效--&gt; &lt;div class="modal-dialog modal-sm"&gt; &lt;!--宽/高/定位 小 大 modal-lg--&gt; &lt;div class="modal-content"&gt; &lt;!--边框/背景色/阴影--&gt; &lt;div class="modal-header"&gt;头部&lt;/div&gt; &lt;div class="modal-body"&gt;主体&lt;/div&gt; &lt;div class="modal-footer"&gt;尾部&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 模态框2 可关闭123456789101112131415161718192021222324252627282930313233&lt;button class="btn btn-info" type="button" data-toggle="modal" data-target="#mymodal2"&gt;REGISTER&lt;/button&gt; &lt;!--触发--&gt;&lt;div id="mymodal2" class="modal fade" tabindex="-1"&gt; &lt;!--半透明的黑色遮罩层--&gt; &lt;div class="modal-dialog"&gt; &lt;!--宽/位置--&gt; &lt;div class="modal-content"&gt; &lt;!--背景色/边框--&gt; &lt;div class="modal-header"&gt; &lt;span class="close" data-dismiss="modal"&gt;&amp;times;&lt;/span&gt; &lt;h3 class="modal-title"&gt;User Register&lt;/h3&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;form action=""&gt; &lt;div class="form-group"&gt; &lt;label for="uname"&gt;用户名：&lt;/label&gt; &lt;input class="form-control" id="uname" type="text"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="upwd"&gt;密码：&lt;/label&gt; &lt;input class="form-control" id="upwd" type="text"&gt; &lt;/div&gt; &lt;input class="btn btn-success" type="button" value="提交"&gt; &lt;input class="btn btn-info" type="button" value="重置"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;input class="btn btn-success" type="button" value="提交"&gt; &lt;input class="btn btn-danger" data-dismiss="modal" type="button" value="关闭"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 折叠效果折叠效果(collapse) 触发一个折叠效果： &lt;a href=&quot;#折叠元素ID&quot; data-toggle=&quot;collapse&quot;&gt; &lt;button data-toggle=&quot;collapse&quot; data-target=&quot;#折叠元素ID&quot;&gt;&lt;div id=&quot;折叠元素ID&quot; class=&quot;collapse in&quot;&gt;&lt;/div&gt; in 默认显示 opacity:1 1234567891011&lt;a class="btn btn-danger" href="#my-collapse" data-toggle="collapse"&gt;LINK触发折叠效果&lt;/a&gt;&lt;button class="btn btn-info" type="button" data-toggle="collapse" data-target="#my-collapse"&gt;BTN触发折叠效果&lt;/button&gt;&lt;div id="my-collapse" class="collapse in"&gt; &lt;!--in 一开始显示--&gt; &lt;div class="alert alert-success"&gt; 内容... &lt;/div&gt;&lt;/div&gt; 面板.panel(手风琴)折叠组件的两个扩展用途： (1)Accordion（手风琴） (2)响应式导航条在手机屏幕中的效果手风琴 下面一样的代码改id和类.panel-info .panel-warning .panel-default … 例子12345678910111213141516171819202122232425262728293031&lt;div class="panel-group" id="my-accordion"&gt; &lt;div class="panel panel-danger"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt; &lt;a data-parent="#my-accordion" data-toggle="collapse" href="#hlm"&gt;《红楼梦》简介&lt;/a&gt; &lt;/h3&gt; &lt;/div&gt; &lt;!--内容--&gt; &lt;div id="hlm" class="collapse in panel-collapse"&gt; &lt;div class="panel-body"&gt; 《红楼梦》内容... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--加了头部和尾部--&gt; &lt;div class="panel panel-success"&gt; &lt;div class="panel-heading"&gt;头 &lt;h3 class="panel-title"&gt; &lt;a data-parent="#my-accordion" href="#shz" data-toggle="collapse"&gt;《水浒传》简介&lt;/a&gt; &lt;/h3&gt; &lt;/div&gt; &lt;!--触发内容--&gt; &lt;div id="shz" class="collapse panel-collapse"&gt; &lt;div class="panel-body"&gt; 《水浒传》内容... &lt;/div&gt; &lt;div class="panel-footer"&gt;尾部&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 轮播carousel本身结构较复杂，编写时只需要记住根class: .carousel1234567 &lt;div class="carousel"&gt;&lt;div class="carousel-inner"&gt;&lt;div class="item active"&gt;&lt;img&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; 代码 唯一不好 图片有问题12345&lt;style&gt; .carousel &gt; .carousel-inner &gt; .item &gt; img &#123; width: 100%; &#125; &lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;h2&gt;带广告序号指示器(indicator)的轮播广告&lt;/h2&gt;&lt;div class="contianer"&gt;&lt;div id="myad5" class="carousel slide" data-ride="carousel" data-interval="3000"&gt; &lt;div class="carousel-inner"&gt; &lt;div class="item active"&gt; &lt;img src="img/11.jpg" alt=""&gt; &lt;div class="carousel-caption"&gt; &lt;h4&gt;红红火火&lt;/h4&gt; &lt;span&gt;这是一副红红火火的画&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="img/22.jpg" alt=""&gt; &lt;div class="carousel-caption"&gt; &lt;h4&gt;大漠戈壁&lt;/h4&gt; &lt;span&gt;这是一副大漠戈壁的画&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="img/33.jpg" alt=""&gt; &lt;div class="carousel-caption"&gt; &lt;h4&gt;花团锦簇&lt;/h4&gt; &lt;span&gt;这是一副花团锦簇的画&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="img/44.jpg" alt=""&gt; &lt;div class="carousel-caption"&gt; &lt;h4&gt;时光流逝&lt;/h4&gt; &lt;span&gt;这是一副时光流逝的画&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;a class="carousel-control left" data-slide="prev" href="#myad5"&gt; &lt;span class="glyphicon glyphicon-chevron-left"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class="carousel-control right" data-slide="next" href="#myad5"&gt; &lt;span class="glyphicon glyphicon-chevron-right"&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class="carousel-indicators"&gt; &lt;li data-slide-to="0" data-target="#myad5" class="active"&gt;&lt;/li&gt; &lt;li data-slide-to="1" data-target="#myad5"&gt;&lt;/li&gt; &lt;li data-slide-to="2" data-target="#myad5"&gt;&lt;/li&gt; &lt;li data-slide-to="3" data-target="#myad5"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/div&gt; 阅读障碍 行业小知识：盲人、智力低下、行动障碍… H5标签中有两类属性与“无障碍阅读”相关：WAI (1)&lt;ANY role=&quot;&quot;&gt; &lt;b role=&quot;button&quot;&gt;&lt;/b&gt; VDA软件 (2)&lt;ANY aria-*=&quot;&quot;&gt;]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2018%2F06%2F14%2Fajax%2F</url>
    <content type="text"><![CDATA[一.基本内容同步交互和异步交互 同步交互客户端向服务端发送请求,到服务端进行响应,这个过程中,用户不能做任何其他事情(等) 异步交互客户端向服务端发送请求,直到服务端进行响应,这个过程中,用户可以做任何其他事情(不等) 同步与异步的区别 同步交互:1.执行速度慢2.响应的是完整的html页面 异步交互:1.执行的速度相对快2.响应的是部分的数据 ajax定义 Asynchronus JavaScript and Xml 异步的javascript和XML (不严格的定义)客户端与服务端进行交互,而无需刷新当前页面的技术,称为AJAXAjax实现的是B/S架构加载实现异步交互的技术 XMLHttpRequest对象(在服务器中运行)本例在WampServer服务中使用 实现ajax的六部请求(一般为四步)1.创建XMLHttpRequest对象2.建立连接3.发送请求4.注册监听 -onreadystatechange事件5.获取服务器的通信状态 -readyState6.获取服务器的状态码 接收服务器的端的响应数据 使用XMLHttpRequest核心对象的responseText属性 该属性只能接收文本(HTML)格式 问题 解析过程中比较复杂(拆串) 拆串或拼串极容易出错 设置本地服务器wampserver安装教程 设置工作目录1.打开D:\wamp\scripts\config.inc.php文件 2.$wwwDir = $c_installDir.’/www’;改成 $wwwDir = ‘E:/website’; 3.打开D:\wamp\bin\apache\Apache2.4.4\conf\httpd.conf把DocumentRoot “D:/wamp/www”改成DocumentRoot “E:/website” 1&lt;Directory &quot;D:/wamp/www&quot;&gt;改成&lt;Directory &quot;E:/website&quot;&gt; get请求123456789101112131415161718192021222324252627282930313233343536function getXhr()&#123; if(window.XMLHttpRequest)&#123; var xhr =new XMLHttpRequest() &#125;else&#123; var xhr =new ActiveXObject('Microsoft.XMLHttp') //IE6 下兼容 &#125; return xhr&#125;var xhr = getXhr() //1.创建核心对象xhr.open('get','01.php?key=value') //2.与服务器建立连接//xhr.open('get','01.php') //参数(method,url,async) 默认true异步xhr.send(null) //3.客户端向服务端发送请求//如果请求类型为get方式的话,send()方法不能发送数据//应写成xhr.open('get','01.php?key=value') url带参数//xhr.send('key=value') 错误//4.客户端接收服务端请求 2// 监听服务器的通行状态//0 尚未初始化//1 正在接收//2.接收完成//3.正在响应//4.响应完成//服务器的状态吗 200 ok xhr.statusxhr.onreadystatechange=function()&#123; //console.log(xhr.readyState) //通行码 2,3,4 if(xhr.readyState ==4)&#123; //响应数据发送完毕 if(xhr.status==200)&#123; //请求必须成功 //接收服务器的数据 console.log(xhr.responseText) //value成功 &#125; &#125;&#125; 后台服务端:01.php 123456&lt;?php //用户处理客户端的Ajax异步请求 //1.接收客户端发送的请求数据 $key=$_GET['key']; echo $key.'成功'; //2.向客户端进行响应 输出:value成功?&gt; post请求12345//如果设置post请求 //必须在send()方法前使用setRequestHeader(key,value) xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded') xhr.send('name=小明') //请求参数 02.php123456&lt;?php $name =$_POST['name']; //var_dump($name);//带格式打印输出 print_r($name);//打印输出:小明 echo $name; // 响应输出:小明?&gt; XML格式基本格式 HTML,XHTML,DHTML和XML的区别 HTML就是网页====元素定义大小写 XHTML就是严格意义的HTML=======元素定义大小写(v1.0-2.0 更新5-6年 停掉) DHTML======BOM|DOM XML=======配置文件|数据格式 XML文件的定义方式与html非常相似 html的元素预定好的 xml允许自定义元素 xml语法 声明1&lt;?xml version='1.0' encoding='utf-8'?&gt; version -设置当前xml文件的版本 encoding 设置编码格式 1.0版本–目前唯一版本1.1版本–几乎没人使用版本不会更新 定义元素 根元素 必须是起始标签 只能定义一个 定义元素 元素名可以定义分类 起始标签或单标签 定义属性 定义注释 test.xml 123456&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;users&gt; &lt;user&gt; &lt;name&gt;张三&lt;/name&gt; &lt;/user&gt;&lt;/users&gt; 在浏览器中显示 目前不能使用123456789101112131415161718//定义函数-用于封装XML解析器的创建/** w3school 帮助文档已过时 return xmldoc.load(xml)** */function parseXML(xml)&#123; var xmldoc=null; try &#123; xmldoc=new ActiveXObject('Microsoft.XMLDOM'); &#125;catch(e)&#123; xmldoc=document.implementation.createDocument("","",null) &#125; xmldoc.async=false; //load()方法 返回解析后的DOM对象&#125;var xmlDoc=parseXML('test.xml')console.log(xmlDoc) 目前可以使用解析本地XML12345678910111213141516171819202122232425262728/*目前 * IE new ActiveXObject('Microsoft.XMLDOM') * 其他浏览器 var parser=new DOMParser(); * 使用DOM解析器解析XML文件 * var xmloc=parser.parserFromString(xmlFile,'application/xml') * * 当前报错 * 目前主流的浏览器不能读取本地文件 * */ function parseXML(xmlFile)&#123; //创建解析XML后的DOM对象 var xmlDoc=null; //根据不同的浏览器进行解析 if(window.DOMParser)&#123; //其他浏览器 var parser =new DOMParser(); xmlDoc=parser.parseFromString(xmlFile,'application/xml'); &#125;else&#123; //IE浏览器 var parser=new ActiveXObject('Microsoft.XMLDOM'); parser.async=false; xmlDoc=parser.loadXML(xmlFile) &#125; return xmlDoc; &#125; var xmlDoc=parseXML('test.xml'); console.log(xmlDoc) 输出结果: 解析xml 12345678910 //DOM解析XML和解析HTML没有任何区别/*很少使用ById和ByName两个方法* * */ var xmlDoc=parseXML('&lt;user&gt;&lt;name&gt;小明&lt;/name&gt;&lt;/user&gt;') console.log(xmlDoc)// &lt;user&gt;&lt;name&gt;小明&lt;/name&gt;&lt;/user&gt; var userEle=xmlDoc.getElementsByTagName('user')[0]; var nameEle=userEle.getElementsByTagName('name')[0]; var nameTxt=nameEle.childNodes[0].nodeValue console.log(nameTxt); //小明 封装ajax 使用ajax(url, fnSucc, fnFaild) 12345678910111213141516171819202122232425262728293031323334353637function ajax(url, fnSucc, fnFaild)&#123; //1.创建Ajax对象 var oAjax=null; if(window.XMLHttpRequest) &#123; oAjax=new XMLHttpRequest(); &#125; else &#123; oAjax=new ActiveXObject("Microsoft.XMLHTTP"); &#125; //2.连接服务器 oAjax.open('GET', url, true); //3.发送请求 oAjax.send(); //4.接收服务器的返回 oAjax.onreadystatechange=function () &#123; if(oAjax.readyState==4) //完成 &#123; if(oAjax.status==200) //成功 &#123; fnSucc(oAjax.responseText); &#125; else &#123; if(fnFaild) fnFaild(oAjax.status); &#125; &#125; &#125;;&#125; 例子读取本地txt 1234567ajax('abc.txt?t='+new Date().getTime(), function (str)&#123; alert(str);&#125;);//str-&gt;'[1,2,3,4]'//alert(str);var arr=eval(str) //解析字符串 二.jQuery中AjaxjQuery中的AJax $.ajax() 封装第一层 最复杂 $().load() 最简单,局限性最大 $.get() $.post() 特殊用法 $.getScript() 动态读取脚本(JavaScript代码) $.getJSON() 接收JSON格式数据 load()123$().load(url,data,callback)$().load(url,data,function(response,status,xhr)) get方式没有data数据参数 03.php 1234567&lt;?php //路径不能有中文名 $name =$_GET['name']; //get //$name =$_POST['name'];// post // var_dump($name);//格式打印输出 // print_r($name);//打印输出 echo $name."load success"; //小明load success?&gt; 1234567// *load()方法的请求类型// *没有请求数据时,请求为get$('#btn').click(function() &#123; //get请求数据加到div内容 &lt;div&gt;小明load success&lt;/div&gt; $('div').load('03.php?name=小明',function(data)&#123; console.log(data) &#125;) post方式12345var user=&#123;"name":"小明"&#125; //有请求数据时,为post $('div').load('03.php',user,function(data)&#123; console.log(data) &#125;) $.get()1$.get(url,data,callback,type) type:设置服务器响应的数据格式*默认值:html格式 xml json 默认数据请求12345678910 var user = &#123; "name": "小明" &#125; $.get("04.php",user,function(data) &#123; console.log(data) //小明 &#125;)//04.php&lt;?php $name=$_GET['name']; //不加type参数 print_r($name); echo $name?&gt; xml数据请求12345678910 $.get("04.php",function(data) &#123; console.log(data) //&lt;user&gt;&lt;name&gt;小明&lt;/name&gt;&lt;/user&gt; &#125;,'xml')//04.php&lt;?php //xml方法 header("Content-Type:text/xml"); //xml请求头 echo "&lt;user&gt;&lt;name&gt;小明&lt;/name&gt;&lt;/user&gt;"; ?&gt; json数据请求 123456789 $.get("04.php",function(data) &#123; console.log(data) //Object &#123;name: "小红"&#125; //console.log(eval('('+data+')')) //不加json参数 &#125;,'json')//04.php&lt;?php echo '&#123;"name":"小红"&#125;'?&gt; post和get方法相同 $.ajax()1234567891011//textStatus 表示Ajax的状态 success error//error:textStatus 可以得到信息 timeout notmodified$.ajax(&#123; url:'05.php', type:'post', async:true, data:user, success:function(data,textStatus)&#123;&#125;, error:function(XMLHttpRequest,textStatus,errorThrown)&#123;&#125;, dataType:'json'&#125;) 动态加载js12345678910//方法 $.getScript('script.js')$.getScript('05.php',function(data) &#123; console.log(data) //'$('div').text('test')'&#125;)05.php:&lt;?php echo "$('div').text('test')";?&gt; 表单表单序列化$(form).serialize() json字符串 {key:value,key:value…}.serializeArray() json对象 {obj1,odj2…} 表单的必须有name属性12345&lt;form action="1.php" id="myform" name="myform" method="post"&gt; 用户名:&lt;input type="text" id="username" name="username"&gt;&lt;/input&gt;&lt;br&gt; 密码:&lt;input type='text' id="password" name="password"&gt;&lt;br&gt; &lt;input type="button" value="登录" id="btn"&gt;&lt;/form&gt; 123456789101112131415161718192021222324 $('#btn').click(function()&#123; // var user=&#123; // "username":$('#username').val(), // "password":$('#password').val() // &#125; var user=$('#myform').serialize(); console.log(user) //username=admin&amp;password=admin $.post('1.php',user,function(data)&#123; console.log(data); //login success &#125;) &#125;)// 1.php&lt;?php $username=$_POST['username']; $password=$_POST['password']; if($username=='admin'&amp;&amp;$password=='admin') &#123; echo 'login success'; &#125;else&#123; echo 'login fail'; &#125;?&gt; jquery.form插件jquery.form插件 表单的异步提交两个核心的方法1.ajaxForm() 2.ajaxSubmit() 底层机制 表单的提交机制表单的异步提交方式不再使用submit按钮 绑定click事件使用submit按钮,在&lt;form&gt;中绑定onsumbit事件步骤1.表单的序列化2.表单的异步提交 3.阻止表单的默认行为 123456789&lt;script src="../jquery.form.js"&gt;&lt;/script&gt; &lt;!-- version:3.51.0-2014.06.20 --&gt;&lt;form action="2.php" id="myform" name="myform" method="post" onsubmit="return formSubmit();"&gt; 用户名:&lt;input type="text" id="username" name="username"&gt;&lt;/input&gt;&lt;br&gt; 密码:&lt;input type='text' id="password" name="password"&gt;&lt;br&gt;&lt;input type="submit" value="登录" id="btn"&gt;&lt;/form&gt; 123456789101112131415161718192021222324//实现异步提交 ,触发onsubmit事件 function formSubmit()&#123; // $('#myform').ajaxSubmit(&#123; // url:'2.php', // type:'post', // data:'json', // success:function()&#123;&#125; // &#125;) //简单的写法 $('#myform').ajaxSubmit(function(data)&#123; console.log(data) //成功/失败 &#125;) return false; //阻止表单默认提交 &#125;//2.php &lt;?php $username=$_POST['username']; $password=$_POST['password']; if($username=='admin'&amp;&amp;$password=='admin') &#123; echo '成功'; &#125;else&#123; echo '失败'; &#125; ?&gt; 跨域请求理解 跨域:请求了不同域的资源。浏览器的同源策略:同源: 协议相同 域名相同 端口相同http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。 目的:同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据 浏览器同源政策及其规避方法 CSRF:跨站请求伪造 攻击者盗用了你的身份，以你的名义发送恶意请求 CSRF 域名 完全跨域 IP不同跨子域 IP相同 但端口号不同 同源策略默认是不允许行跨域请求的 跨域的解决方法 通过jsonp 跨域2.document.domain+iframe跨域 location.hash+iframe跨域4.window.name+iframe跨域5.postMessage 跨域6.跨域资源共享(CORS)7.nginx代理跨域8.nodejs中间件代理跨域9.WebSCocket协议跨域 nginxnginx正向代理代理位于网站和客户端中间,客户端无法访问某网站,就将请求发送给带服务器,代理从网站取回来再发送给客户端,网站并不知道为谁服务 反向代理客户端访问某个网站的一个页面,但是网站并没有,就偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户,用户不知道真正提供服务的是谁 对于服务器来说,访问的就是同源服务器上的一个url.而nginx通过检测url前缀,把http请求转发到后面真实的物理服务器.并通过rewrite命令把前缀再去掉.这样真实的服务器就可以正确处理请求,并且并不知道这个请求是来自代理服务器的. 简单说,ngnix服务器欺骗了浏览器,让它认为这是同源调用,从而解决了浏览器的跨域问题.又通过重写url,欺骗了真实的服务器,让它以为这个http请求是直接来自于用户浏览器的 jsonp实现跨域使用jsonp形式的回调函数来加载其他网域的json数据 实现方法HTML中的&lt;script&gt;元素具有开放的策略 123456789function jsonpCallback(result) &#123; //请求成功调用该方法 //alert(result); console.log('成功') console.log(result) //json数据 &#125; var JSONP = document.createElement("script"); JSONP.type = "text/javascript"; JSONP.src = 'http://open.iciba.com/dsapi/?callback=jsonpCallback'; //金山词霸api document.getElementsByTagName("head")[0].appendChild(JSONP); $.getJSON()jQuery中的$.getJSON( )方法函数主要用来从服务器加载json编码的数据，它使用的是GET HTTP请求。使用方法如下： 1$.getJSON( url [, data ] [, success(data, textStatus, jqXHR) ] ) 12345678910111213141516171819202122232425262728293031323334 $('#btn').click(function() &#123; //获取本地json数据 $.getJSON('test.json', function(data) &#123; console.log(data) &#125;); //jsonp $.getJSON('3.php?callback=?', function(data) &#123; console.log(data) //&#123;msg: "getJSON"&#125; &#125;) $.getJSON('test.php?callback=?', function(data) &#123; console.log(data) //&#123;a: 1, b: 2, c: 3, d: 4, e: 5&#125; &#125;) &#125;)//3.php 设置数据&lt;?php $callback=$_GET['callback']; echo $callback.'(&#123;"msg":"getJSON"&#125;)'; //jQuery32109263170191061956_1510978699895(&#123;"msg":"getJSON"&#125;) ?&gt;//test.php&lt;?php //服务端返回JSON数据 $arr=array('a'=&gt;1,'b'=&gt;2,'c'=&gt;3,'d'=&gt;4,'e'=&gt;5); // 数组 $result=json_encode($arr); // json化 //echo $_GET['callback'].'("Hello,World!")'; //echo $_GET['callback']."($result)"; //动态执行回调函数 $callback=$_GET['callback']; echo $callback."($result)"; ?&gt;]]></content>
      <categories>
        <category>ajax</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[布局]]></title>
    <url>%2F2018%2F06%2F14%2Fcss%E5%B8%83%E5%B1%80%E5%92%8C%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[几种布局的方法: 布局圣杯与双飞翼 圣杯与双飞翼 特效css特效博客 rem教程JS获取浏览器窗口大小 获取屏幕，浏览器，网页高度宽度（转载） - Window2016 - 博客园rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可。12345678function refreshRem() &#123; var docEl = document.documentElement; var width = docEl.getBoundingClientRect().width; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = window.rem = rem;&#125;window.addEventListener('resize', refreshRem);]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器知识点]]></title>
    <url>%2F2018%2F06%2F14%2Fbrowser%2F</url>
    <content type="text"><![CDATA[Web前端工程师写的页面要跑在浏览器里面，所以面试中也会出现很多跟浏览器相关的面试题目。 知识点梳理 [TOC] 一：加载页面和渲染过程可将加载过程和渲染过程分开说。回答问题的时候，关键要抓住核心的要点，把要点说全面，稍加解析即可，简明扼要不拖沓。 题目：浏览器从加载页面到渲染页面的过程 加载过程要点如下： 浏览器根据 DNS 服务器得到域名的 IP 地址 向这个 IP 的机器发送 HTTP 请求 服务器收到、处理并返回 HTTP 请求 浏览器得到返回内容 例如在浏览器输入http://baidu.com，然后经过 DNS 解析，baidu.com对应的 IP 是220.181.57.216]（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。 sever 端接收到 HTTP 请求，然后经过计算（向不同的用户推荐不同的内容），返回 HTTP 请求。返回的内容是一堆 HTML 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。 渲染过程要点如下： 根据 HTML 结构生成 DOM 树 根据 CSS 生成 CSSOM 将 DOM 和 CSSOM 整合形成 RenderTree 根据 RenderTree 开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 上文中，浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，因此要把 HTML 字符串转化成 DOM 树 —— 树是最基本的数据结构之一。 解析过程中，如果遇到&lt;link href=&quot;...&quot;&gt;和&lt;script src=&quot;...&quot;&gt;这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载来的字符串是 CSS 或者 JS 格式的。 浏览器将 CSS 生成 CSSOM ，再将 DOM 和 CSSOM 整合成 RenderTree，然后针对 RenderTree 即可进行渲染了。大家可以想一下，有 DOM 结构、有样式，此时就能满足渲染的条件了。另外，这里也可以解释一个问题 —— 为何将 CSS 放在 HTML 头部？—— 这样会让浏览器今早拿到 CSS 尽早生成 CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。 最后，渲染过程中，如果遇到&lt;script&gt;就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待&lt;script&gt;内部执行完之后，浏览器继续渲染。最后再思考一个问题 —— 为何将 JS 放在 HTML 底部？ —— JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。 关于浏览器整个流程，百度的多益大神有更加详细的文章，推荐阅读下：《从输入 URL 到页面加载完成的过程中都发生了什么事情？》 二：性能优化性能优化的题目也是面试常考的，这类题目有很大的扩展性，能够扩展出来很多小细节，而且对个人的技术视野和业务能力有很大的挑战。这部分会重点讲下常用的性能优化方案。 题目：总结前端性能优化的解决方案 优化原则和方向性能优化的原则是 以更好的用户体验为标准，具体就是实现下面的目标： 多使用内存、缓存或者其他方法 减少 CPU 和 GPU 计算，更快展现 优化的方向有两个 减少页面体积，提升网络加载 优化页面渲染 减少页面体积，提升网络加载 静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图） 静态资源缓存（资源名称加 MD5 戳） 使用 CDN 让资源加载更快 优化页面渲染 CSS 放前面，JS 放后面 懒加载（图片懒加载、下拉加载更多） 减少 DOM 查询，对 DOM 查询做缓存 减少 DOM 操作，多个操作尽量合并在一起执行（DocumentFragment） 事件节流 尽早执行操作（DOMContentLoaded） 使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间 详细解释静态资源的压缩合并如果不合并，每个都会走一遍之前介绍的请求过程 123&lt;script src="a.js"&gt;&lt;/script&gt;&lt;script src="b.js"&gt;&lt;/script&gt;&lt;script src="c.js"&gt;&lt;/script&gt; 如果合并了，就只走一遍请求过程 1&lt;script src="abc.js"&gt;&lt;/script&gt; 静态资源缓存通过链接名称控制缓存 1&lt;script src="abc_1.js"&gt;&lt;/script&gt; 只有内容改变的时候， 链接名称才会改变 1&lt;script src="abc_2.js"&gt;&lt;/script&gt; 这个名称不用手动改，可通过前端构建工具根据文件内容，为文件名称添加 MD5 后缀。 使用 CDN 让资源加载更快CDN 会提供专业的加载优化方案，静态资源要尽量放在 CDN 上。例如： 1&lt;script src="https://cdn.bootcss.com/zepto/1.0rc1/zepto.min.js"&gt;&lt;/script&gt; 使用 SSR 后端渲染可一次性输出 HTML 内容，不用再页面渲染完成之后，再通过 Ajax 加载数据、再渲染。例如使用 smarty、Vue SSR 等。 CSS 放前面，JS 放后面上文讲述浏览器渲染过程时已经提过，不再赘述。 懒加载一开始先给src赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，preview.png是预览图片，比较小，加载很快，而且很多图片都共用这个preview.png，加载一次即可。待页面下拉，图片显示出来时，再去替换src为data-realsrc的值。 1&lt;img src="preview.png" data-realsrc="abc.png"/&gt; 另外，这里为何要用data-开头的属性值？ —— 所有 HTML 中自定义的属性，都应该用data-开头，因为data-开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。 DOM 查询做缓存两段代码做一下对比： 1234var pList = document.getElementsByTagName('p') // 只查询一个 DOM ，缓存在 pList 中了var ifor (i = 0; i &lt; pList.length; i++) &#123;&#125; 123var ifor (i = 0; i &lt; document.getElementsByTagName('p').length; i++) &#123; // 每次循环，都会查询 DOM ，耗费性能&#125; 总结：DOM 操作，无论查询还是修改，都是非常耗费性能的，应尽量减少。 合并 DOM 插入DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再同一插入 DOM。 12345678910var listNode = document.getElementById('list')// 要插入 10 个 li 标签var frag = document.createDocumentFragment();var x, li;for (x = 0; x &lt; 10; x++) &#123; li = document.createElement('li'); li.innerHTML = 'List item' + x; frag.appendChild(li); // 先放在 frag 中，最后一次性插入到 DOM 结构中&#125;listNode.appendChild(frag); 事件节流例如要在文字改变时触发一个 change 事件，通过 keyup 来监听。使用节流。 12345678910var textarea = document.getElementById('text');var timeoutId;textarea.addEventListener('keyup', function () &#123; if (timeoutId) &#123; clearTimeout(timeoutId) &#125; timeoutId = setTimeout(function () &#123; // 触发 change 事件 &#125;, 100) &#125;) 尽早执行操作123456window.addEventListener('load', function () &#123; // 页面的全部资源加载完才会执行，包括图片、视频等&#125;)document.addEventListener('DOMContentLoaded', function () &#123; // DOM 渲染完即可执行，此时图片、视频还可能没有加载完&#125;) 性能优化怎么做上面提到的都是性能优化的单个点，性能优化项目具体实施起来，应该按照下面步骤推进： 建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过程消耗时间记录下来 分析耗时较长时间段原因，寻找优化点，确定优化目标 开始优化 通过数据收集平台记录优化效果 不断调整优化点和预期目标，循环 2 ~ 4 步骤 性能优化是个长期的事情，不是一蹴而就的，应该本着先摸底、再分析、后优化的原则逐步来做。 三：Web 安全 题目：前端常见的安全问题有哪些 Web 前端的安全问题，能回答出下文的两个问题，这个题目就能基本过关了。开始之前，先说一个最简单的攻击方式 —— SQL 注入。 上学的时候就知道有一个 SQL注入 的攻击方式。例如做一个系统的登录界面，输入用户名和密码，提交之后，后端直接拿到数据就拼接 SQL 语句去查询数据库。如果在输入时进行了恶意的 SQL 拼装，那么最后生成的 SQL 就会有问题。但是现在稍微大型一点的系统，都不会这么做，从提交登录信息到最后拿到授权，要经过层层的验证。因此，SQL 注入都只出现在比较低端的小型的系统上。 XSS （Cross Site Scripting，跨站脚本攻击）这是前端最常见的攻击方式，很多大型网站（如 Facebook）都被 XSS 攻击过。 举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。但是如果我写的是恶意的 JS 脚本，例如获取document.cookie然后传输到自己的服务器上，那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。 其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码被执行了。JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限，例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。 XSS 的危害XSS 的危害相当大，如果页面可以随意执行比人不安全的 JS 代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。 比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。 还有利用获取 cookie 的方式，将 cookie 传入入侵者的服务器上，入侵者就可以模拟 cookie 登录网站，对用户的信息进行篡改。 XSS 的预防那么如何预防 XSS 攻击呢？ —— 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有： 123456&amp; 替换为：&amp;amp;&lt; 替换为：&amp;lt;&gt; 替换为：&amp;gt;” 替换为：&amp;quot;‘ 替换为：&amp;#x27;/ 替换为：&amp;#x2f; 替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。 除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加http-only限制，让 JS 获取不到 cookie 的内容。 CSRF（Cross-site request forgery，跨站请求伪造）CSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。 例如，一个支付类网站，给他人转账的接口是http://buy.com/pay?touid=999&amp;money=100，而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了http://buy.com，在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码&lt;img src=&quot;http://buy.com/pay?touid=999&amp;money=100&quot;/&gt;，他访问了邮件之后，其实就已经完成了购买。 CSRF 的发生其实是借助了一个 cookie 的特性。我们知道，登录了http://buy.com之后，cookie 就会有登录过的标记了，此时请求http://buy.com/pay?touid=999&amp;money=100是会带着 cookie 的，因此 server 端就知道已经登录了。而如果在 http://buy.com去请求其他域名的 API 例如http://abc.com时，是不会带 cookie 的，这是浏览器的同源策略的限制。但是 —— 此时在其他域名的页面中，请求 http://buy.com/pay?touid=999&amp;money=100，会带着 buy.com 的 cookie，这是发生 CSRF 攻击的理论基础。 预防 CSRF 就是加入各个层级的权限验证，例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者指纹才行。除此之外，敏感的接口使用 POST 请求而不是 GET 也是很重要的。 小结本小节总结了前端运行环境（即浏览器）的一些常考知识点，包括页面加载过程、如何性能优化以及需要注意的安全问题。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发环境知识点]]></title>
    <url>%2F2018%2F06%2F14%2Fdevelop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[工程师的开发环境决定其开发效率，常用的开发环境配置也是面试考查点之一。 知识点梳理 [TOC] 一：IDE 题目：你平时都使用什么 IDE 编程？有何提高效率的方法？ 前端最常用的 IDE 有 webstorm、Sublime、Atom 和 VSCode，我们可以分别去它们的官网看一下。 Webstorm 是最强大的编辑器，因为它拥有各种强大的插件和功能。跟面试官聊到 Webstorm 的时候，没用过没事儿，但一定要知道它：第一，强大；第二，收费。 Sublime 第一它免费，第二它轻量、高效，第三它插件非常多。用 Sublime 一定要安装各种插件配合使用，可以去网上搜一下“sublime”常用插件的安装以及用法，还有它的各种快捷键，并且亲自使用它。这里就不一一演示了，网上的教程也很傻瓜式。 Atom 是 GitHub 出品的编辑器，跟 Sublime 差不多，免费并且插件丰富，而且跟 Sublime 相比风格上还有些小清新。但是它打开的时候会比较慢，卡一下才打开。当然总体来说也是很好用的，只是个人习惯问题。 VSCode 是微软出品的轻量级（相对于 Visual Studio 来说）编辑器，微软做 IDE 那是出了名的好，出了名的大而全，因此 VSCode 也有上述 Sublime 和 Atom 的各种优点。 总结一下： 如果你要走大牛、大咖、逼格的路线，就用 Webstorm 如果你走普通、屌丝、低调路线，就用 Sublime 如果你走小清新、个性路线，就用 VSCode 或者 Atom 如果你面试，最好有一个用的熟悉，其他都会一点 最后注意：千万不要说你使用 Dreamweaver 或者 notepad++ 写前端代码，会被人鄙视的。如果你不做 .NET 也不要用 Visual Studio，不做 Java 也不要用 Eclipse。 二：Git你此前做过的项目一定要用过 Git，而且必须是命令行，如果没用过，你自己也得恶补一下。对 Git 的基本应用比较熟悉的同学，可以跳过这一部分了。macOS 自带 Git，Windows 需要安装 Git 客户端，去 Git 官网下载即可。 国内比较好的 Git 服务商有 coding.net，国外有大名鼎鼎的 Github，但是有时会有网络问题，因此建议大家注册一个 coding.net 账号然后创建项目，来练练手。 题目：常用的 Git 命令有哪些？如何使用 Git 多人写作开发？ 常用的 Git 命令首先，通过git clone &lt;项目远程地址&gt;下载下来最新的代码，例如git clone git@git.coding.net:username/project-name.git，默认会下载master分支。 然后修改代码，修改过程中可以通过git status看到自己的修改情况，通过git diff &lt;文件名&gt;可查阅单个文件的差异。 最后，将修改的内容提交到远程服务器，做如下操作 123git add .git commit -m "xxx"git push origin master 如果别人也提交了代码，你想同步别人提交的内容，执行git pull origin master即可。 如何做人协作开发多人协作开发，就不能使用master分支了，而是要每一个开发者单独拉一个分支，使用git checkout -b &lt;branchname&gt;，运行git branch可以看到本地所有的分支名称。 自己的分支，如果想同步master分支的内容，可运行git merge master。切换分支可使用git checkout &lt;branchname&gt;。 在自己的分支上修改了内容，可以将自己的分支提交到远程服务器 123git add .git commit -m "xxx"git push origin &lt;branchname&gt; 最后，待代码测试没问题，再将自己分支的内容合并到master分支，然后提交到远程服务器。 123git checkout mastergit merge &lt;branchname&gt;git push origin master 关于 SVN关于 SVN，面试的时候可能会问到，但你只要熟悉了 Git 的操作，面试官不会因为你不熟悉 SVN 而为难你。前提是你要知道一点 SVN 的基本命令，自己上网一查就行。 不过 SVN 和 Git 的区别你得了解。SVN 是每一步操作都离不开服务器，创建分支、提交代码都需要链接服务器。而 Git 就不一样了，你可以在本地创建分支、提交代码，最后再一起 push 到服务器上。因此，Git 又有 SVN 的所有功能，但是却比 SVN 强大得多。（Git 是 Linux 的创始人 Linus 发明的东西，因此也倍得推崇。） 三：Linux 基础命令目前互联网公司的线上服务器都是用 Linux 系统，测试环境为了保证和线上一致，肯定也是使用 Linux 系统，而且都是命令行的，没有桌面，不能用鼠标操作。因此，掌握基础的 Linux 命令是非常必要的。下面总结一些最常见的 Linux 命令，建议大家在真实的 Linux 系统下亲自试一下。 关于如何得到 Linux 系统，有两个选择：第一，在自己电脑的虚拟机中安装一个 Linux 系统，例如 Ubuntu/CentOS 等，下载这些都不用花钱；第二，花钱去阿里云等云服务商租一个最便宜的 Linux 虚拟机。推荐第二种。一般正式入职之后，公司都会给你分配开发机或者测试机，给你账号和密码，你自己可以远程登录。 题目：常见 linux 命令有哪些？ 登录入职之前，一般会有现有的用户名和密码给你，你拿来之后直接登录就行。运行sshname@server然后输入密码即可登录。 目录操作 创建目录mkdir &lt;目录名称&gt; 删除目录rm &lt;目录名称&gt; 定位目录cd &lt;目录名称&gt; 查看目录文件ls ll 修改目录名mv &lt;目录名称&gt; &lt;新目录名称&gt; 拷贝目录cp &lt;目录名称&gt; &lt;新目录名称&gt; 文件操作 创建文件touch &lt;文件名称&gt; vi &lt;文件名称&gt; 删除文件rm &lt;文件名称&gt; 修改文件名mv &lt;文件名称&gt; &lt;新文件名称&gt; 拷贝文件cp &lt;文件名称&gt; &lt;新文件名称&gt; 文件内容操作 查看文件cat &lt;文件名称&gt; head &lt;文件名称&gt; tail &lt;文件名称&gt; 编辑文件内容vi &lt;文件名称&gt; 查找文件内容grep &#39;关键字&#39; &lt;文件名称&gt; 四：前端构建工具构建工具是前端工程化中不可缺少的一环，非常重要，而在面试中却又其特殊性 —— 面试官会通过询问构建工具的作用、目的来询问你对构建工具的了解，只要这些你都知道，不会再追问细节。因为，在实际工作中，真正能让你编写构建工具配置文件的机会非常少，一个项目就配置一次，后面就很少改动了。而且，如果是大众使用的框架（如 React、Vue等），还会直接有现成的脚手架工具，一键创建开发环境，不用手动配置。 题目：前端为何要使用构建工具？它解决了什么问题？ 何为构建工具“构建”也可理解为“编译”，就是将开发环境的代码转换成运行环境代码的过程。开发环境的代码是为了更好地阅读，而运行环境的代码是为了更快地执行，两者目的不一样，因此代码形式也不一样。例如，开发环境写的 JS 代码，要通过混淆压缩之后才能放在线上运行，因为这样代码体积更小，而且对代码执行不会有任何影响。总结一下需要构建工具处理的几种情况： 处理模块化：CSS 和 JS 的模块化语法，目前都无法被浏览器兼容。因此，开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如，使用 webpack、Rollup 等处理 JS 模块化。 编译语法：编写 CSS 时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等。这些标准目前也都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。 代码压缩：将 CSS、JS 代码混淆压缩，为了让代码体积更小，加载更快。 构建工具介绍最早普及使用的构建工具是 Grunt，不久又被 Gulp 给追赶上。Gulp 因其简单的配置以及高效的性能而被大家所接受，如果你做一些简单的 JS 开发，可以考虑使用。 如果你的项目比较复杂，而且是多人开发，那么你就需要掌握目前构建工具届的神器 —— webpack。不过神器也有一个缺点，就是学习成本比较高，需要拿出专门的时间来专心学习，而不是三言两语就能讲完的。我们下面就演示一下 webpack 最简单的使用，全面的学习还得靠大家去认真查阅相关文档，或者参考专门讲解 webpack 的教程。 webpack 演示接下来我们演示一下 webpack 处理模块化和混淆压缩代码这两个基本功能。 首先，你需要安装 Node.js，没有安装的可以去 Node.js官网 下载并安装。安装完成后运行如下命令来验证是否安装成功。 12node -vnpm -v 然后，新建一个目录，进入该目录，运行npm init，按照提示输入名称、版本、描述等信息。完成之后，该目录下出现了一个package.json文件，是一个 JSON 文件。 接下来，安装 webpack，运行npm i --save-dev webpack。然后编写源代码，在该目录下创建src文件夹，并在其中创建app.js和dt.js两个文件，文件内容分别是： 12345678910// dt.js 内容module.exports = &#123; getDateNow: function () &#123; return Date.now() &#125;&#125;// app.js 内容var dt = require('.dt.js')alert(dt.getDateNow()) 然后，再返回上一层目录，新建index.html文件（该文件和 src 属于同一层级），内容是 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;test&lt;/div&gt; &lt;script src='./dist/bundle.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后编写 webpack 配置文件，新建webpack.config.js，内容是 1234567891011121314151617181920const path = require('path');const webpack = require('webpack');module.exports = &#123; context: path.resolve(__dirname, './src'); entry: &#123; app: './app.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; //supresses warnings, usually from module minification warnings: false &#125; &#125;) ]&#125; 总结一下，目前项目的文件目录是： 123456src +-- app.js +-- dt.jsindex.htmlpackage.jsonwebpack.config.js 接下来，打开package.json，然后修改其中scripts的内容为： 123"scripts": &#123; "starts": "webpack"&#125; 在命令行运行npm start，即可看到编译的结果，最后在浏览器中打开index.html，即可弹出Date.now()的值。 最后再次强调，深刻理解构建工具存在的价值，比你多会一些配置代码更加有意义，特别是对于应对面试来说。 五：调试方法调试方法这块被考查最多的就是如何进行抓包 题目：如何抓取数据？如何使用工具来配置代理？ PC 端的网页，我们可以通过 Chrome、Firefox 等浏览器自带的开发者工具来查看网页的所有网络请求，以帮助排查 bug。这种监听、查看网络请求的操作称为抓包。 针对移动端的抓包工具，Mac 系统下推荐使用 Charles 这个工具。Windows 系统推荐使用 Fiddler。两者使用基本一致，下面以 Charles 为例介绍。 接下来，将安装好的 Charles 的电脑和要抓包的手机，连接到同一个网络（一般为公司统一提供的内网，由专业网络工程师搭建），保证 IP 段相同。然后，将手机设置网络代理（不会的到网上查一下），代理的 IP 为电脑的 IP，代理的端口为8888。然后，Charles 可能会有一个弹框提示是否允许连接代理，这里选择 “允许” 即可。这样，使用手机端访问的网页或者联网的请求，Charles 就能监听到了。 在开发过程中，经常用到抓包工具来做代理，将线上的地址代理到测试环境，Charles 和 Fiddler 都可实现这个功能。以 Charles 为例，点击菜单栏中的 Tools 菜单，然后二级菜单中点击 Map Remote，会弹出配置框。首先，选中 Enable Map Remote 复选框，然后点击 Add 按钮，添加一个待立项。例如，如果要将线上的https://www.aaa.com/api/getuser?name=xxx这个地址代理到测试地址http://168.1.1.100:8080/api/getuser?name=xxx，配置如下图 小结本小节总结了前端开发环境常考查的知识，这些知识也是前端程序员必须掌握的，否则会影响开发效率。]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从容应对算法题目]]></title>
    <url>%2F2018%2F06%2F14%2Falgorithm%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[由冯·诺依曼机组成我们知道：数据存储和运算时计算机工作的主要内容。程序=数据结构+算法，所以计算机类工程师必须掌握一定的数据结构和算法知识。 知识点梳理 [TOC] 一：数据结构数据结构决定了数据存储的空间和事件效率问题，数据的写入和提取速度要求也决定了应该选择怎样的数据结构。 根据对场景需求的不同，我们设计不同的数据结构，比如： 读得多的数据结构，应该想办法提高数据的读取效率，比如 IP 数据库，只需要写一次，剩下的都是读取 读写都多的数据结构，要兼顾两者的需求平衡，比如 LRU Cache 算法 算法是数据加工处理的方式，一定的算法会提升数据的处理效率。比如有序数组的二分查找，要比普通的顺序查找快很多，尤其是在处理大量数据的时候。 数据结构和算法是程序开发的通用技能，所以在任何面试中都可能会遇见。随着近几年 AI、大数据、小游戏越来越火，Web 前端职位难免会跟数据结构和算法打交道，面试中也会出现越来越多的算法题目。学习数据结构和算法也能够帮助我们打开思路，突破技能瓶颈。 二：前端常遇见的数据结构问题现在我们来梳理下前端常遇见的数据结构： 简单数据结构（必须理解掌握） 有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小） 无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快） 复杂数据结构 树、堆 图 对于简单数据结构，在 ES 中对应的是数组（Array）和对象（Object）。可以想一下，数组的存储是有序的，对象的存储是无序的，但是我要在对象中根据key找到一个值时立即返回的，数组则需要查找的过程。 这里通过一个真实面试题目来说明介绍下数据结构设计。 题目：使用 ECMAScript 代码实现一个事件类Event，包含下面功能：绑定事件、解绑事件和派发事件 在稍微复杂点的页面中，比如组件化开发的页面，同一个页面由两三个人来开发，为了保证组件的独立性和降低组件间耦合度，我们往往使用 订阅发布模式，即组件间通信使用事件监听和派发的方式，而不是直接互相调用组件方法，这就是题目要求写的Event类。 这个题目的核心是一个事件类型对应回调函数的数据设计。为了实现绑定事件，我们需要一个_cache对象来记录绑定了哪些事件。而事件发生的时候，我们需要从_cache中读取出来事件回调，依次执行它们。一般页面中事件派发（读）要比事件绑定（写）多。所以我们设计的数据结构应该尽量地能够在事件发生时，更加快速地找到对应事件的回调函数，然后执行。 经过这样一番思考，简单写了下代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Event &#123; constructor() &#123; // 存储事件的数据结构 // 为了查找迅速，使用了对象（字典） this._cache = &#123;&#125; &#125; // 绑定 on(type, callback) &#123; // 为了按类查找方便和节省空间 // 将同一类型事件放在一个数组中 // 这里的数组是队列，遵循先进先出 // 即先绑定的事件先触发 let fns = (this._cache[type] = this._cache[type] || []); if (fns.indexOf(callback) === -1) &#123; fns.push(callback); &#125; return this; &#125; // 触发 trigger(type, data) &#123; let fns = this._cache[type]; if (Array.isArray(fns)) &#123; fns.forEach((fn) =&gt; &#123; fn(data); &#125;); &#125; return this; &#125; // 解绑 off(type, callback) &#123; let fns = this._cache[type]; if (Array.isArray(fns)) &#123; if (callback) &#123; let index = fns.indexOf(callback); if (index !== -1) &#123; fns.splice(index, 1) &#125; &#125; else &#123; // 全部清空 fns.length =0; &#125; &#125; return this; &#125;&#125;// 测试用例const event = new Event();event.on('test', (a) =&gt; &#123; console.log(a);&#125;);event.trigger('test', 'hello world');event.off('test');event.trigger('test', 'hello world'); 类似于树、堆、图这些高级数据结构，前端一般也不会考查太多，但是它们的查找方法却常考，后面介绍。高级数据应该平时多积累，好好理解，比如理解了堆是什么样的数据结构，在面试中遇到 查找堆大的 K 个数 这类算法问题，就会迎刃而解。 三：算法的效率是通过算法复杂度来衡量的算法的好坏可以通过算法的复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估量、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查的不多。 常见的事件复杂度有： 常数阶 O(1) 对数阶 O(logN) 线性阶 O(n) 线性对数阶 O(nlogN) 平方阶 O(n^2) 立方阶 O(n^3) !k次方阶 O(n^k) 指数阶O(2^n) 随着问题规模 n 的不断增大，上述事件复杂度不断增大，算法的执行效率越低。 一般做算法复杂度分析的时候，遵循下面的技巧： 看看有几重循环，一般来说一重就是O(n),两重就是O(n^2)，以此类推 如果有二分，则为O(logN) 保留最高项，去除常数项 题目：分析下面代码的算法复杂度（为了方便，注释中加入了代码分析） 12345let i =0; // 语句执行一次 while (i &lt; n) &#123; // 语句执行 n 次 console.log(`Current i is $&#123;i&#125;`); //语句执行 n 次 i++; // 语句执行 n 次&#125; 根据注释可以得到，算法复杂度为1 + n + n + n = 1 + 3n，去除常数项，为O(n)。 1234let number = 1; // 语句执行一次 while (number &lt; n) &#123; // 语句执行 logN 次 number *= 2; // 语句执行 logN 次&#125; 上面代码while的跳出判断条件是number&lt;n，而循环体内number增长速度是(2^n)，所以循环代码实际执行logN次，复杂度为：1 + 2 * logN = O(logN) 12345for (let i = 0; i &lt; n; i++) &#123;// 语句执行 n 次 for (let j = 0; j &lt; n; j++) &#123;// 语句执行 n^2 次 console.log('I am here!'); // 语句执行 n^2 次 &#125;&#125; 上面代码是两个for循环嵌套，很容易得出复杂度为：O(n^2) 四：人人都要掌握的基础算法枚举和递归是最最简单的算法，也是复杂算法的基础，人人都应该掌握！枚举相对比较简单，我们重点说下递归。 递归由下面两部分组成： 递归主体，就是要循环解决问题的代码 递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出 关于递归有个经典的面试题目是： 实现 JS 对象的深拷贝 什么是深拷贝深拷贝就是在拷贝数据的时候，将数据的所有 引用结构 都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又互相独立的数据，将引用类型进行复制，而不是只复制其引用关系。 分析下怎么做深拷贝： 首先假设深拷贝这个方法已经完成，为 deepClone 要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复 1234567891011121314151617181920function deepClone(o1, o2) &#123; for (let k in o2) &#123; if (typeof o2[k] === 'object') &#123; o1[k] = &#123;&#125;; deepClone(o1[k], o2[k]); &#125; else &#123; o1[k] = o2[k]; &#125; &#125;&#125;// 测试用例let obj = &#123; a: 1, b: [1, 2, 3], c: &#123;&#125;&#125;;let emptyObj = Object.create(null);deepClone(emptyObj, obj);console.log(emptyObj.a == obj.a);console.log(emptyObj.b == obj.b); 递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过for或者while来代替递归。 我们在使用递归的时候，要注意做到优化，比如下面的题目。 题目：求斐波那契数列 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项 下面的代码中count记录递归的次数，我们看下两种差异性的代码中的count的值： 12345678910111213141516171819202122232425262728293031let count = 0;function fn(n) &#123; let cache = &#123;&#125;; function _fn(n) &#123; if (cache[n]) &#123; return cache[n]; &#125; count++; if (n == 1 || n == 2) &#123; return 1; &#125; let prev = _fn(n - 1); cache[n - 1] = prev; let next = _fn(n - 2); cache[n - 2] = next; return prev + next; &#125; return _fn(n);&#125;let conut2 = 0;function fn2(n) &#123; count2++; if (n == 1 || n == 2) &#123; return 1; &#125; return fn2(n - 1) + fn2(n - 2);&#125;console.log(fn(20), count);console.log(fn2(20), count2); 五：快排和二分查找前端中面试排序和查找的可能性比较小，因为 JS 引擎已经把这些常用操作优化得很好了，可能项目中你费尽写的一个排序方法，都不如Array.sort速度快且代码少。因此，掌握快排和二分查找就可以了。 快排和二分查找都基于一种叫做 分治 的算法思想，通过对数据进行分类处理，不断降低数量级，实现O(logN)（对数级别，比O(n)这种线性复杂度更低的一种，快排核心是二分法的O(logN)，实际复杂度为O(N*logN)）的复杂度。 快速排序快排大概的流程是： 随机选择数组中的一个数 A，以这个数为基准 其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边 经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的 这时候将左边和右边的数再递归上面的过程 具体代码如下： 1234567891011121314151617181920const Arr = [85, 24, 63, 45, 17, 31, 96, 50];function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let pivotIndex = Math.floor(arr.length / 2); let pivot = arr.splice(pivotIndex, 1)[0]; let left = []; let right = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; // 递归 return quickSort(left).concat([pivot], quickSort(right));&#125;console.log(quickSort(Arr)); 二分查找二分查找法主要是解决 在一堆有序的数中找出指定的数 这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。 二分查找是一种 分治 思想的算法，大概流程如下： 数组中排在中间的数字 A，与要找的数字比较大小 因为数组是有序的，所以 : a) A 较大则说明要查找的数字应该从前半部分查找 b) A 较小则说明应该从查找数字的后半部分查找 这样不断查找缩小数量级（扔掉一般数据），知道找完数组为止 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数 12345678910111213141516171819202122function Find(target, array) &#123; let i = 0; let j = array[i].length - 1; while (i &lt; array.length &amp;&amp; j &gt;= 0) &#123; if (array[i][j] &lt; target) &#123; i++; &#125; else if (array[i][j] &gt; target) &#123; j--; &#125; else &#123; return true; &#125; &#125; return false;&#125;//测试用例console.log(Find(10, [ [1, 2, 3, 4], [5, 9, 10, 11], [13, 20, 21, 23] ])); 题目：现在我有一个 1 ~ 1000 区间中的正整数，需要你猜下这个数字是几，你只能问一个问题：大了还是小了？问需要猜几次才能猜对？ 猜几次呢？其实这个问题就是个二分查找的算法事件复杂度问题，二分查找的时间复杂度是O(logN)，所以求log1000的解就是猜的次数。我们知道2^10=1024，所以可以快速估算出：log1000约等于 10，所以，最多问 10 次就能猜到这个数。 六：面试遇见不会的算法题怎么办面试时，在遇见算法题目的时候，应该揣摩面试官的意图，听好关键词，比如：有序的数列做查找、要求算法复杂度是O(logN)这类一般就是用二分的思想。 一般来说算法题的解题思路分以下四步： 先降低数量级，拿可以计算出来的情况（数据）来构思解题步骤 根据解题步骤编写程序，优先将特殊情况做好判断处理，比如一个大数组的问题，如果数组为两个数长度的情况 检验程序正确性 是否可以优化（由浅到深），有能力的话可以故意预留优化点，这样可以体现个人技术能力 七：正则匹配解题很多算法题目利用 ES 语法的特性来回答更加简单，比如正则匹配就是常用的一种方式。下面简单通过几个真题来汇总下正则的知识点。 题目：字符串中第一个出现一次的字符 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g 。当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l 。 这个如果用纯算法来解答需要遍历字符串，统计每个字符出现的次数，然后按照字符串的顺序来找出第一次出现一次的字符，整个过程比较繁琐，如果用正则就简单多了。 12345678910function find(str) &#123; for (var i = 0; i &lt; str.length; i++) &#123; let char = str[i]; let reg = new RegExp(char, 'g'); let l = str.match(reg).length; if (l === 1) &#123; return char &#125; &#125;&#125; 当然，使用indexOf/lastIndexOf也是一个取巧的方式。再来看一个千分位问题。 题目：将 1234567 变成 1，234，567 ，即千分位标注 这个题目可以用算法直接来解，如果我们用正则来回答，这样主动展现了自己其他方面的优势，即使不是算法解答出来的，面试官一般也不会太难为我们。这道题目可以利用正则的 零宽断言(?=exp)，意思是它断言自身出现的位置的后面能匹配表达式 exp。数字千分位的特点是，第一个逗号后面数字的个数是 3 的倍数，正则：/(\d{3})+$/；第一个都好前最多可以有 1 ~ 3 个数字，正则：/\d{1,3}/。加起来就是/\d{1,3}(\d{3})+$/，分隔符要从前往后加。 对于零宽断言的详细介绍可以阅读 零宽断言这篇文章。 12345678910111213function exchange(num) &#123; num += ''; // 转成字符串 if (num.length &lt;= 3) &#123; return num; &#125; num = num.replace(/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g, (v) =&gt; &#123; console.log(v) return v + ','; &#125;) return num;&#125;console.log(exchange(1234567)); 当然上面降到的多数是算法题目取巧的方式，下面这个题目是纯正则考查。 题目：请写出下面的代码执行结果 12345var str = 'google';var reg = /o/g;console.log(reg.test(str))console.log(reg.test(str))console.log(reg.test(str)) 代码执行后，会发现，最后一个不是为true，而是false，这是因为reg这个正则有个g，即global全局的属性，这种情况下lastIndex就发挥作用了，可以看下面的代码执行结果就明白了 。 123console.log(reg.test(str), reg.lastIndex)console.log(reg.test(str), reg.lastIndex)console.log(reg.test(str), reg.lastIndex) 实际开发中也会犯这样的错误，比如为了减少变量每次都重新定义，会把用到的变量提前定义好，这样在使用的时候容易掉进坑里，比如下面代码： 1234567891011(function()&#123; const reg = /o/g; function isHasO(str)&#123; // reg.lastIndex = 0; 这样就可以避免这种情况 return reg.test(str) &#125; var str = 'google'; console.log(isHasO(str)) console.log(isHasO(str)) console.log(isHasO(str))&#125;()) 小结本小节介绍了数据结构和算法的关系，作为普通的前端也应该学习数据结构和算法知识，并且顺带介绍了下正则匹配。具体来说，本小节梳理了以下几部分数据结构和算法知识点： 经常用到的数据结构有哪些，它们的特点有哪些 递归和枚举是最基础的算法，必须牢牢掌握 排序里面理解并掌握快速排序算法，其他排序算法可以根据个人实际情况大概了解 有序查找用二分查找 遇见不会的算法问题，先缩小数量级，然后分析推导 当然算法部分还有很多知识，比如动态规划这些算法思想，还有图和树常用到的广度优先搜索和深度优先搜索。这些知识在前端面试和项目中遇见得不多，感兴趣的读者可以在梳理知识点的时候根据个人情况自行决定是否复习。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM和DOM知识点]]></title>
    <url>%2F2018%2F06%2F14%2FBOM-DOM%2F</url>
    <content type="text"><![CDATA[除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。 知识点梳理 [TOC] 一：BOMBOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。 navigator screen location history 这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3cschool 这种网站一查就明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例。 获取浏览器特性（即俗称的 UA）然后识别客户端，例如判断是不是 Chrome 浏览器 123var ua = navigator.userAgentvar isChrome = ua.indexOf('Chrome')console.log(isChrome) 获取屏幕的宽度和高度 12console.log(screen.width)console.log(screen.height) 获取网址、协议、path、参数、hash 等 12345console.log(location.href) // 获取网址console.log(location.protocol) // 获取协议console.log(location.pathname) // 获取 pathconsole.log(location.search) // 获取参数console.log(location.hash) // 获取 hash 另外，还有调用浏览器的前进、后退功能等 12history.back()history.forward() 二：DOM 题目：DOM 和 HTML 的区别和联系 什么是 DOM讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的书，它是一棵树。 1234567891011&lt;?xml version="1.0" encoding="UTF-8"&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body &lt;other&gt; &lt;a&gt;&lt;/a&gt; &lt;b&gt;&lt;/b&gt; &lt;/other&gt;&lt;/note&gt; HTML 是一个既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;this is p&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们开发完的 HTML 代码会保存到一个文档中（一般以 .html 或者 .htm 结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。 但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。 基于以上需求，浏览器就需要把 HTML 转化成 DOM， HTML 是一棵树， DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。 获取 DOM 节点最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例： 12345678910111213// 通过 id 获取var div1 = doucment.getElementById('div1') // 元素// 通过 tagname 获取var divList = document.getElementsByTagName('div') // 集合console.log(divList.length)console.log(divList[0])// 通过 class 获取var containerList = document.getElementsByClassName('container') // 集合// 通过 CSS 选择器获取var pList = document.querySelectorAll('p') // 集合 题目：property 和 attribute 的区别是什么 propertyDOM 节点符合之前讲述的对象的特征——可扩展属性，因为 DOM 节点本质上是一个 JS 对象。因此，如下代码所示，p 可以有 style 属性，有 className、nodeName、nodeType 属性。注意，这些都是 JS 范畴的属性，符合 JS 语法标准的。 12345678910var pList = document.querySelectorAll('p')var p = pList[0]console.log(p.style.width) // 获取样式p.style.width = '100px' // 修改样式console.log(p.className) // 获取 classp.className = 'p1' // 修改 class// 获取 nodeName 和 nodeTypeconsole.log(p.nodeName)console.log(p.nodeType) attributeproperty 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。 attribute 就是对 HTML 属性的 get、set，和 DOM 节点 JS 范畴的 property 没有关系。 123456var pList = document.querySelectorAll('p')var p = pList[0]p.getAttribute('data-name')p.setAttribute('date-name', 'xiaomi')p.getAttribute('style')p.setAttribute('style', 'font-size: 30px') 而且， get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。 题目：DOM 操作的基本 API 有哪些 新增节点 12345678910var div1 = document.getElementById('div1')// 添加新节点var p1 = document.createElement('p')p1.innerHTML = 'this is p1'div1.appendChild(p1) // 添加新创建的元素// 移动已有节点。注意，这里是“移动”，不是拷贝var p2 = document.getElementById('p2')div1.appendChild(p2) 获取父元素 12var div1 = document.getElementById('div1')var parent = div1.parentElement 获取子元素 12var div1 = document.getElementById('div1')var child = div1.childNodes 删除节点 123var div1 = document.getElementById('div1')var child = div1.childNodesdiv1.remooveChild(child[0]) 还有其他操作的API，例如获取前一个节点，获取后一个节点等，但是面试过程中经常考到的就是上面几个。 三：事件事件绑定普通的事件绑定写法如下： 123456var btn = document.getElementById('btn1')btn.addEventListener('click', function (event) &#123; // event.preventDefault() 阻止默认行为 // event.stopPropagation 阻止冒泡 console.log('clicked')&#125;) 为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。 12345678910// 通用的事件绑定函数function bindEvent (elem, type, fn) &#123; elem.addEventListener(type, fn)&#125;var a = document.getElementById('link1')// 写起来更加简单了bindEvent(a, 'click', function (e) &#123; e.preventDefault() // 阻止默认行为 alert('clicked')&#125;) 最后， 如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会。 现在互联网流量都在 App 上，IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。 题目：什么是事件冒泡 事件冒泡123456789101112&lt;body&gt; &lt;div id="div1"&gt; &lt;p id="p1"&gt;激活&lt;/p&gt; &lt;p id="p2"&gt;取消&lt;/p&gt; &lt;p id="p3"&gt;取消&lt;/p&gt; &lt;p id="p4"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id="div2"&gt; &lt;p id="p5"&gt;取消&lt;/p&gt; &lt;p id="p6"&gt;取消&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 对于以上 HTML 代码结构，要求点击 p1 时候进入激活状态，点击其他任何 都取消激活状态，如何实现？代码如下，注意看注释： 1234567891011var body = document.bodybindEvent(body, 'click', function (e) &#123; // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡 alert('取消')&#125;)var p1 = document.getElementById('p1')bindEvent(p1, 'click', function (e) &#123; e.stopPropagation() // 阻止冒泡 alert('激活')&#125;) 如果我们在 p1、div1、body 中绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用 e.stopPropagation() 就可以阻止冒泡 题目：如何使用事件代理？有何好处？ 事件代理我们设定一种场景，如下代码，一个 &lt;div&gt; 中包含了若干个 &lt;a&gt;，而且还能继续增加。那如何快捷方便地为所有 &lt;a&gt; 绑定事件呢？ 1234567&lt;div id="div1"&gt; &lt;a href="#"&gt;a1&lt;/a&gt; &lt;a href="#"&gt;a2&lt;/a&gt; &lt;a href="#"&gt;a3&lt;/a&gt; &lt;a href="#"&gt;a4&lt;/a&gt;&lt;/div&gt;&lt;button&gt;点击增加一个 a 标签&lt;/button&gt; 这里就会用到事件代理。我们要监听 &lt;a&gt; 的事件，但要把具体的事件绑定到 &lt;div&gt; 上，然后看事件的触发点是不是 &lt;a&gt;。 123456789var div1 = document.getElementById('div1')div1.addEventListener('click', function (e) &#123; // e.target 可以监听到触发点击事件的元素是哪一个 var target = e.target if (target.nodeName === 'A') &#123; // 点击的是 &lt;a&gt; 元素 alert(target.innerHTML) &#125;&#125;) 我们现在完善一下之前写的通用事件绑定函数，加上事件代理。 123456789101112131415161718192021222324function bindEvent(elem, type, selector, fn) &#123; // 这样处理，可接收两种调用方式 bindEvent(div1, 'click', 'a', function () &#123;...&#125;) 和 bindEvent(div1, 'click', function () &#123;...&#125; 这两种) if (fn == null) &#123; fn = selector selector = null &#125; // 绑定事件 elem.addEventListener(type, function (e) &#123; var target if (selector) &#123; // 有 selector 说明需要做事件处理 // 获取触发事件的元素，即 e.target target = e.tagget // 看是否符合 selector 这个条件 if (target.matches(selector)) &#123; fn.call(target, e) &#125; &#125; else &#123; // 无 selector 说明不需要事件代理 fn(e) &#125; &#125;)&#125; 然后这样使用，简单很多 1234567891011// 使用代理，bindEvent 多一个 'a' 参数var div1 = document.getElementById('div1')bindEvent(div1, 'cilck', 'a', function (e) &#123; console.log(this.innerHTML)&#125;)// 不使用代理var a = document.getElementById('a1')bindEvent(div1, 'click', function (e) &#123; console.log(a.innerHTML)&#125;) 最后，使用代理的优点如下： 使代码简洁 减少浏览器的内存占用 四：AjaxXMLHttpRequest 题目：手写 XMLHttpRequest 不借助任何库 这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。 1234567891011var xhr = new XMLHttpRequest()xhr.onreadystatechange = function () &#123; // 这里的函数异步执行，可参考之前 JS 基础中的异步模块 if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText) &#125; &#125;&#125;xhr.open('GET', '/api', false)xhr.send(null) 当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不在赘述。 状态码说明上述代码中，有两处状态码需要说明。xhr.readyState 是浏览器判断请求过程中各个阶段的，xhr.status 是 HTTP 协议中规定的不同结果的返回状态说明。 xhr.readyState 的状态码说明： 0 -代理被创建，但尚未调用 open() 方法 1 - open() 方法已经被调用 2 - open() 方法已经被调用，并且头部和状态已经可获得 3 -下载中， responseText 属性已经包含部分数据 4 -下载操作已完成 题目：HTTP 协议中，response 的状态码，常见的有哪些？ xhr.status 即 HTTP 状态码，有 2xx、3xx、4xx、5xx 这几种，比较常见的有以下几种： 200 正常 3xx 301 永久重定向。如 http://xxx.com 这个 GET 请求（最后没有 /），就会被 301 到http://xxx.com/ （最后是 /） 302 临时重定向。临时的，不是永久的 304 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有 If-Modified-Since:xxxx（要求返回更新时间是 xxx 时间之后的资源），如果此时服务器端资源未更新，则会返回 304 ，即不符合要求 404 找不到资源 5xx 服务器端出错了 看完要明白，为何上述代码中要同时满足 xhr.readyState == 4 和 xhr.status == 200。 Fetch API目前已经有一个获取 HTTP 请求更加方便的 API： Fetch，通过 Fetch 提供的 fetch() 这个全局函数方法可以很简单地发起异步请求，并且支持 Promise 的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 caniuse，看下其他浏览器兼容情况。 看一个简单的例子： 12345678fetch('some/api/data.json', &#123; method: 'POST', // 请求类型 GET POST header: &#123;&#125;, // 请求头信息，形式为 Headers 对象或 ByteString body: &#123;&#125;, // 请求主体（get 或 head 方法中不能包含 body） mode: '', // 请求的模式，是否跨域等，如 cors、no-cors 或 same-origin credenttials: '', // cookie 的跨域策略，如 omit、same-origin 或 include cache: '' // 请求的 cache 模式：default、no-store、reload、no-cache、force-cache 或 only-if-cached&#125;).then(function(response) &#123;...&#125;); Fetch 支持 headers 定义，通过 headers 自定义可以方便地实现多种请求方法（PUT、GET、POST等）、请求头（包括跨域）和 cache 策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和 formData 等。 跨域 题目：如何实现跨域 浏览器中有 同源策略，即一个域下的页面，无法通过 Ajax 获取到其他域的接口。例如有一个接口 http://baidu.com/course/ajaxcoursecom?cid=123，你自己的一个页面 http://xxx.com/page1.html 中的 Ajax 无法获取这个接口。这正是命中了 “同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。 url 哪些地方不同算作跨域？ 协议 域名 端口 但是 HTML 中几个标签能逃避过同源策略——&lt;script src=&quot;xxx&quot;&gt;、&lt;img src=&quot;xxx&quot;&gt;、&lt;link href=&quot;xxx&quot;&gt;，这三个标签的 src/href 可以加载其他域的资源，不受同源策略影响。 因此，这使得这三个标签可以做一些特殊的事情。 &lt;img&gt; 可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。出了能跨域之外，&lt;img&gt; 几乎没有浏览器兼容问题，它是一个非常古老的标签。 &lt;script&gt; 和 &lt;link&gt; 可以使用 CDN，CDN 基本都是其他域的链接。 另外 &lt;script&gt; 还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。 但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。 解决跨域 - JSONP首先，有一个概念你要明白，例如访问 http://baidu.com/classindex.html的时候，服务器端就一定有一个 classindex.html 文件吗？不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。同理，&lt;script src=&quot;http://baidu.com/api.js&quot;&gt; 也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。 例如我们的网站和百度肯定不是一个域。我们需要百度提供一个接口，供我们来获取。首先，我们在自己的页面这样定义 123456&lt;script&gt; window.onload = function (data) &#123; // 这是我们跨域得到信息 console.log(data) &#125;&lt;/script&gt; 然后百度给我们提供了一个 http://baidu.com/api.js ，内容如下（之前说过，服务器可动态生成内容） 1callback(&#123;x: 100, y: 200&#125;) 最后我们在页面中加入 &lt;script src=&quot;http://baidu.com/api.js&quot;&gt;&lt;script&gt;，那么这个 js 加载之后，就会执行内容，我们就得到内容了。 解决跨域 - 服务器端设置 http header这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单很多。 123456response.setHeader("Access-Control-Allow-Origin", "http://baidu.com"); // 第二个参数填写允许跨域的域名称，不建议直接写 “*”response.setHeader("Access-Control-Allow-Headers", "X-Requested-With");response.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");// 接收跨域的 cookieresponse.setHeader("Access-Control-Allow-Credentials", "true"); 五：存储 题目：cookie 和 localStorage 有何区别 cookiecookie 本身不是用来做服务器端存储的（计算机领域有很多这种 “狗拿耗子” 的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。 使用起来也非常简单，document.cookie = ... 即可。 但是 cookie 有它致命的缺点： 存储量太小，只有 4KB 所有 HTTP 请求都带着，会影响获取资源的效率 API 简单，需要封装才能用 locationStorage 和 sessionStorage后来，HTML5 标准就带来了 sessionStorage 和 localStorage，先拿 localStorage 来说，它是专门为了浏览器端缓存而设计的。其优点有： 存储量增大到 5MB 不会带到 HTTP 请求中 API 适用于数据存储 localStorage.setItem(key, value) localStorage.getItem(key) sessionStorage 的区别就在于它是根据 session 过去时间而实现，而 localStorage 会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在 sessionStorage 中，一些不重要但是不经常设置的信息，放在 localStorage 中。 另外告诉大家一个小技巧，针对 localStorage.setItem ，使用时尽量加入到 try-catch 中，某些浏览器是金庸这个 API 的，要注意。 小结本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。]]></content>
      <categories>
        <category>BOM和DOM</category>
      </categories>
      <tags>
        <tag>BOM,DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript知识点]]></title>
    <url>%2F2018%2F06%2F14%2FJs%2F</url>
    <content type="text"><![CDATA[JavaScript 是 ECMAScript 规范的一种实现，本文重点梳理下 ECMAScript 中的常考知识点，然后就一些容易出现的题目进行解析。 知识点梳理 [TOC] 一：变量类型JavaScript是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。 ECMAScript中定义了6种原始类型： Boolean String Number Null Undefined Symbol（ES6新定义） 注意：原始类型不包含Object。 题目：类型判断用到哪些方法？ 1.typeof typeof xxx 得到的值有以下几种类型：undefined、boolean、number、string、object、function、symbol，这里需要注意三点： typeof null 结果是 object，实际这是 typeof 的一个 bug，null 是原始值，非引用类型 typeof [1, 2] 结果是 object，结果中没有 array 这一项，引用类型除了 function，其他的全部都是 object typeof symbol() 用 typeof 获取 symbol 类型的值得到的是 symbol，这是ES6新增的知识点 2.instanceof 用于实例和构造函数的对应。例如判断一个变量是否是数组，使用 typeof 无法判断，但可以使用[1, 2] instanceof Array 来判断。因为 [1, 2] 是数组，它的构造函数就是 Array。同理： 12345function Foo(name) &#123; this.name = name&#125;var foo = new Foo('bar')console.log(foo instanceof Foo) //true 题目：值类型和引用类型的区别 值类型vs引用类型 除了原始类型，ES 还有引用类型，上文提到的 typeof 识别出来的类型中，只有 object 和 function 是引用类型，其他都是值类型。 根据 JavaScript 中的变量类型传递方式，又分为值类型和引用类型，值类型包括 Boolean、String、Number、Undefined、Null，引用类型包括了 Object 类的所有，如 Date、Array、Function等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。 下面通过一个小题目，来看两者的主要区别，以及实际开发中需要注意的地方。 123456// 值类型var a = 10var b = a b = 20console.log(a) // 10console.log(b) // 20 上述代码中，a 和 b 都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子： 1234567// 引用类型var a = &#123;x: 10, y: 20&#125;var b = ab.x = 100b.y = 200console.log(a) // &#123;x: 100, y: 200&#125;console.log(b) // &#123;x: 100, y: 200&#125; 上述代码中，a 和 b 都是引用类型。在执行了 b = a 之后，修改 b 的属性值，a 的也跟着变化。因为 a 和 b 都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此 b 修改属性时，a 的值随之改动。 再借助题目进一步讲解以下。 说出下面代码的执行结果，并分析其原因 123456789101112function foo(a) &#123; a = a * 10;&#125;function bar(b) &#123; b.value = 'new';&#125;var a = 1;var b = &#123;value: 'old'&#125;;foo(a);bar(b);console.log(a); // 1console.log(b); // value: old 通过代码执行会发现： a 的值没有发生改变 而 b 的值发生了改变 这就是因为 Number 类型的 a 是按值传递的，而 Object 类型的 b 是按共享传递的。 JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这种类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值，保证过大的对象不会因为不停复制内容而造成内存的浪费。 引用类型经常会在代码中按照下面的写法使用，或者说容易不知不觉造成错误！ 123456789var obj = &#123; a: 1, b: [1, 2, 3]&#125;var a = obj.a var b = obj.bvar a = 2b.push(4)console.log(obj, a, b) 虽然 obj 本身是个引用类型的变量（对象），但是内部的 a 和 b 一个是值类型，一个是引用类型，a 的赋值不会改变 obj.a，但是 b 的操作却会反映到 obj 对象上。 二：原型和原型链JavaScript是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript的原型概念。 题目：如何理解 JavaScript 中的原型 对于这个问题，可以从下面这几个要点来理解和回答，下面几条必须记住并且理解 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（null除外） 所有的引用类型（数组、对象、函数），都有一个__proto__属性，属性值是一个普通的对象 所有的函数，都有一个 prototype 属性，属性值也是一个普通的对象 所有的引用类型（数组、对象、函数），__proto__属性值指向它的构造函数 prototype 属性值 通过代码解释一下，大家可自行运行代码，看结果。 123456789101112131415161718// 要点一：自由扩展属性var obj = &#123;&#125;;obj.a = 100;var arr = [];arr.a = 100;function fn () &#123;&#125;fn.a = 100;// 要点二：__proto__console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__);// 要点三：函数有 prototypeconsole.log(fn.prototype)// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值console.log(obj.__proto__ === Object.prototype) 原型先写一个简单的代码示例。 123456789101112131415// 构造函数function Foo(name, age) &#123; this.name = name&#125;Foo.prototype.alertName = function () &#123; alert(this.name)&#125;// 创建实例var f = new Foo('zhangsan')f.printName = function () &#123; console.log(this.name)&#125;// 测试f.printName()f.alertName() 执行 printName 时很好理解，但是执行 alertName 时发生了什么？这里再记住一个重点 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 __proto__（即它的构造函数的 prototype）中寻找，因此 f.alertName 就会找到 Foo.prototyoe.alertName。 那么如何判断这个属性是不是对象本身的属性呢？使用 hasOwnProperty，常用的地方是遍历一个对象的时候。 1234567var item for (item in f) &#123; // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性 if (f.hasOwnProperty(item)) &#123; console.log(item) &#125;&#125; 题目：如何理解JS中的原型链 原型链还是接着上面的示例，如果执行 f.toString() 时，又发生了什么？ 123456// 省略N行// 测试f.printName()f.alertName()f.toString() 因为 f 本身没有 toString()，并且 f.__proto__（即Foo.prototype）中也没有 toString。这个问题还是得拿出刚才那句话——当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的 prototype）中寻找。 如果在f.__proto__中没有找到 toString，那么就继续去 f.__proto__.__proto__中寻找，因为f.__proto__就是一个普通的对象而已。 f.__proto__即 Foo.prototype，没有找到 toString，继续往上找 f.__proto__.__proto__即 Foo.prototype.__proto__。Foo.prototype 就是一个普通的对象，因此 Foo.prototype.__proto__就是 Object.prototype，在这里可以找到 toString 因此， f.toString 最终对应到了 Object.prototype.toString 这样一直往上找，你会发现一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回 undefined。最上层是什么——Object.prototype.__proto__ === null 原型链中的this所有从原型或更高级原型中得到、执行的方法，其中的 this 在执行时，就指向了当前这个触发事件执行的对象。因此 printName 和 alertName 中的 this 都是 f。 三：作用域和闭包作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目： 题目：现在有个HTML片段，要求编写代码，点击编号为几的链接就 alert 弹出其编号 1234567&lt;ul&gt; &lt;li&gt;编号1，点击我请弹出1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; 一般不知道这个题目用闭包的话，会写出下面的代码： 12345678var list = document.getElementsByTagName('li');for (var i = 0; i &lt; list.length; i++) &#123; list[i].addEventListener('click', function(i) &#123; return function() &#123; alert(i + 1) &#125; &#125;(i), true)&#125; 要理解闭包，就需要我们从 执行上下文 开始讲起。 执行上下文先讲一个关于 变量提升 的知识点，面试中可能会遇见下面的问题，很多候选人都回答错误： 题目：说出下面执行的结果 12345678910111213console.log(a) // undefinedvar a = 100fn('zhangsan') // 'zhangsan' 20function fn(name) &#123; age = 20 console.log(name, age) var age&#125;console.log(b); // 这里报错// Uncaught ReferenceError: b is not definedb = 100; 在一段 JS 脚本（即一个&lt;script&gt;标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 全局执行上下文 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为 dundefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。 我们来看一下上面的题目，为什么 a 是 undefined，而 b 却报错了，实际 JS 在代码执行之前，要全文解析，发现 var a ，知道有个 a 的变量，存入了执行上下文，而 b 没有找到 var 关键字，这时候没有在执行上下文提前占位，所以代码执行的时候，提前报到的 a 是有记录的，只不过值暂时还没有赋值，即为 undefined，而 b 在执行上下文没有找到，自然会报错（没有找到 b 的引用）。 另外，一个函数在执行之前，也会创建一个 函数执行上下文 环境，跟 全局上下文 差不多，不过 函数执行上下文 中会多出 this 、arguments 和函数的参数。参数和 arguments 好理解，这里的 this 咱们需要专门讲解。 总结一下： 范围：一段&lt;script&gt;、js文件或者一个函数 全局上下文：变量定义，函数声明 函数上下文：变量定义，函数声明，this，arguments this先搞明白一个很重要的概念——this的值是在执行的时候才能确认，定义的时候不能确认！为什么呢——因为 this 是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子： 12345678910var a = &#123; name: 'A', fn: function () &#123; console.log(this.name) &#125;&#125;a.fn() // this === aa.fn.call(&#123;name: 'B'&#125;) // this === &#123;name: 'B'&#125;var fn1 = a.fnfn1() // this === window this 执行会有不同，主要集中在这几个场景中 作为构造函数执行，构造函数中 作为对象属性执行，上述代码中 a.fn() 作为普通函数执行，上述代码中 fn1() 用于 call、apply、bind，上述代码中 a.fn.call({name: ‘B’}) 下面再来讲解下什么是作用域和作用域链，作用域和作用域链也是常考的题目。 题目：如何理解 JS 的作用域和作用域链 作用域ES6 之前 JS 没有块级作用域。例如 1234if (true) &#123; var name = 'zhangsan'&#125;console.log(name) 从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的 name 就被暴露出去了，因此， JS 没有块级作用域，只有全局作用域和函数作用域。 1234567var a = 100function fn() &#123; var a = 200 console.log('fn', a)&#125;console.log('global', a)fn() 全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。 1234// 张三写的代码中var data = &#123;a: 100&#125;// 李四写的代码中var data = &#123;x: true&#125; 这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在(function(){....})()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。 作用域链首先认识一下什么叫做 自由变量。如下代码中， console.log(a)要得到 a 变量，但是在当前的作用域中没有定义 a （可对比一下 b）。当前作用域没有定义的变量，这称为 自由变量。自由变量如何得到——向父级作用域寻找。 1234567var a = 100function fn() &#123; var b = 200 console.log(a) console.log(b)&#125;fn() 如果父级也没有呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。 123456789101112var a = 100function F1() &#123; var b = 200 function F2() &#123; var c = 300 console.log(a) // 自由变量，顺着作用域链向父作用域找 console.log(b) // 自由变量，顺着作用域链向父作用域找 console.log(c) // 本作用域的变量 &#125; F2()&#125;F1() 闭包讲完这些内容，我们再来看一个例子，通过例子来理解闭包。 123456789function F1() &#123; var a = 100 return function () &#123; console.log(a) &#125;&#125;var f1 = F1()var a = 200f1() 自由变量将从作用域链中去寻找，但是 依据的是函数定义时的作用域链，而不是函数执行时，以上这个例子就是闭包。闭包主要有两个应用场景： 函数作为返回值，上面的例子就是 函数作为参数传递，看以下例子 123456789101112function F1() &#123; var a = 100 return function () &#123; console.log(a) &#125;&#125;function F2(f1) &#123; var a = 200 console.log(f1())&#125;var f1 = F1()F2(f1) 至此，对应着 作用域和闭包 这部分一开始的点击弹出 alert 的代码再看闭包，就很好理解了。 四：异步同步和异步也是面试中常考的内容，下面来讲解同步和异步的区别。 同步 vs 异步先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印 100, 1秒钟之后打印 200，最后打印 300.但是实际运行根本不是那么回事。 12345console.log(100)setTimeout(function () &#123; console.log(200)&#125;, 1000)console.log(300) 再对比以下程序。先打印 100，再弹出 200（等待用户确认），最后打印 300。这个运行效果就符合预期要求。 123console.log(100)alert(200) // 1秒钟之后点击确认console.log(300) 这俩到底有何区别——第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 异步（后面这个叫做 同步），即 不会阻塞后面程序的运行。 异步和单线程JS 需要异步的根本原因就是 JS 是单线程运行的，即在同一时间只能做一件事，不能“一心二用”。 一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了。异步的话，就好很多了， 5 秒钟等待就等待了，其他事情不耽误做，至于那 5 秒钟是网速太慢，不是因为 JS 的原因。 讲到单线程，我们再来看个真题： 题目：讲解下面代码的执行过程和结果 1234567var a = true;setTimeout(function () &#123; a = false;&#125;, 100)while (a) &#123; console.log('while执行了')&#125; 这是一个很有迷惑性的题目，不少人认为 100ms 之后，由于 a 变成了 false，所以 while 就中止了，实际不是这样，因为 JS 是单线程的，所以进入 while 循环之后，没有 时间（线程）去跑定时器了，所以这个代码跑起来是个死循环。 前端异步的场景 定时 setTimeout、setInterval 网络请求，如 Ajax、&lt;img&gt; 加载 Ajax 代码示例 12345console.log('start')$.get('./data1.json', function (data1) &#123; console.log(data1)&#125;)cosnole.log('end') img 代码示例（常用于打点统计） 123456789console.log('start')var img = document.createElemenr('img')// 或者 img = new Image()img.onload = function () &#123; console.log('loaded') img.onload = null&#125;img.src = './xxx.jpg'console.log('end') 五：ES6/7 新标准的考查 题目：ES6 箭头函数中的 this 和普通函数中的有什么不同 箭头函数箭头函数是 ES6 中心的函数定义形式，function name(arg1, arg2) {...}可以使用(arg1, arg2) =&gt; {...}来定义。示例如下： 123456789101112// 普通函数var arr = [1, 2, 3]arr.map(function (item) &#123; console.log(index) return item + 1&#125;)// ES6 箭头函数const arr = [1, 2, 3]arr.map((item, index) =&gt; &#123; console.log(index) return item + 1&#125;) 箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中 this 是全局变量的问题，看如下代码： 123456789101112131415function fn() &#123; console.log('real', this) // &#123;a: 100&#125; 该作用域下的 this 的真实的值 var arr = [1, 2, 3] // 普通 JS arr.map(function (item) &#123; console.log('js', this) // window 普通的函数。这里打印出来的是全局变量 return item + 1 &#125;) // 箭头函数 arr.map(item =&gt; &#123; console.log('es6', this) // &#123;a: 100&#125; 箭头函数，这里打印的就是父作用域的 this return item + 1 &#125;)&#125;fn.call(&#123;a: 100&#125;) 题目：ES6 模块化如何使用？ ModuleES6 中模块化语法更加简洁，直接看示例。 如果只是输出一个唯一的对象，使用 export default即可，代码如下 1234567// 创建 utill.js 文件，内容如export default &#123; a: 100&#125;// 创建 index.js 文件，内容如import obj from './utill.js'console.log(obj) 如果需要输出多个对象，就不能用 default 了，并且 import 时要加 {…}，代码如下： 1234567891011// 创建 util2.js 文件，内容如export function fn1() &#123; alert('fn1')&#125;export function fn2() &#123; alert('fn2')&#125;// 创建 index.js 文件，内容如import &#123; fn1, fn2 &#125; from './util2.js'fn1()fn2() 题目：ES6 class 和普通构造函数的区别 classclass 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6。ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如： JS构造函数的写法 123456789function MathHandle(x, y) &#123; this.x = x; this.y = y;&#125;MathHandle.prototype.add = function () &#123; return this.x + this.y;&#125;var m = new MathHandle(1, 2);console.log(m.add()) 用 ES6 class 的写法 1234567891011class MathHandle &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; add() &#123; return this.x + this.y &#125;&#125;const m = new MathHandle(1, 2)console.log(m.add()) 注意以下几点，全都是关于 class 语法的： class 是一种新的语法形式，是 class Name {...}这种形式，和函数的写法完全不一样 两者相比，构造函数函数体的内容要放在 class 中的 constructor函数中，constructor即构造器，初始化实例时默认执行 class 中函数的写法是 add() {...}这种形式，并没有 function关键字 使用 class 来实现集成就更加简单了，至少比构造函数实现继承简单很多。看下面例子 JS 构造函数实现继承 123456789101112131415// 动物function Animal() &#123; this.eat = function () &#123; console.log('animal eat') &#125;&#125;// 狗function Dog() &#123; this.bark = function () &#123; console.log('dog bark') &#125;&#125;Dog.prototype = new Animal()// 哈士奇var hashiqi = new Dog() ES6 class 实现继承 1234567891011121314151617181920class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat`) &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name) this.name = name &#125; say() &#123; console.log(`$&#123;this.name&#125; say`) &#125;&#125;const dog = new Dog('哈士奇')dog.say()dog.eat() 注意以下两点 使用 extends 即可实现继承，更加符合经典面向对象语言的写法，如 Java 子类的 constructor 一定要执行 super()，以调用父类的 constructor 题目：ES6 中新增的数据类型有哪些？ Set 和 MapSet 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方： Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复 Map 类似于对象，但普通对象的 key 必须是字符串或数字，而 Map 的 key 可以是任何数据类型 SetSet 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过 add 添加元素，元素不能重复，重复的会被忽略。 12345678910// 例 1const set = new Set([1, 2, 3, 4, 4])console.log(set) // Set(4) &#123;1, 2, 3, 4&#125;// 例 2const set = new Set();[2, 3, 5, 4, 5, 8, 8].forEach(item =&gt; set.add(item));for (let item of set) &#123; console.log(item);&#125;// 2 3 5 4 8 Set 实例的属性和方法有 size： 获取元素数量 add(value)： 添加元素，返回 Set 实例本身 delete(value)： 删除元素，返回一个布尔值，表示删除是否成功 has(value)： 返回一个布尔值，表示该值是否是 Set 实例的元素 clear()： 清除所有元素，没有返回值 1234567891011121314const s = new Set();s.add(1).add(2).add(2); // 添加元素s.size // 2s.has(1); // trues.has(2); // trues.has(3); // falses.delete(2);s.has(2); // falses.clear();console.log(s); // Set(0) &#123;&#125; Set 实例的遍历，可使用如下方法 keys()： 返回键名的遍历器 values()：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys() 和 values() 返回结果一致 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 1234567891011121314151617181920212223let set = new Set(['aaa', 'bbb', 'ccc']);for (let item of set.keys()) &#123; console.log(item);&#125;// aaa// bbb// cccfor (let item of set.values()) &#123; console.log(item);&#125;// aaa// bbb// cccfor (let item of set.entries()) &#123; console.log(item);&#125;// ['aaa', 'aaa']// ['bbb', 'bbb']// ['ccc', 'ccc']set.forEach((value, key) =&gt; console.log(key + ':' + value))// aaa : aaa// bbb : bbb// ccc : ccc MapMap 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。 123456789const map = new Map();const obj = &#123;p: 'Hello World'&#125;;map.set(obj, 'OK')map.get(obj) // 'OK'map.has(obj) // truemap.delete(obj) // truemap.has(obj) // false 需要使用 new Map() 初始化一个实例，下面代码中 set、get、has、delete 顾名即可思义。其中，map.set(obj, &#39;OK&#39;) 就是用对象作为的 kye（不光可以是对象，任何数据类型都可以），并且后面通过 map.get(obj) 正确获取了。 Map 实例的属性和方法如下： size： 获取成员的数量 set：设置成员 key 和 value get： 获取成员属性值 has： 判断成员是否存在 delete： 删除成员 clear： 清空所有 1234567891011121314const map = new Map();map.set('aaa', 100);map.set('bbb', 200);map.size // 2map.get('aaa') // 100map.has('aaa') // truemap.delete('aaa')map.has('aaa') // falsemap.clear() Map 实例的遍历方法有： keys()： 返回键名的遍历器 values()： 返回键值的遍历器 entries()： 返回所有成员的遍历器 forEach()： 遍历 Map 的所有成员 12345678910111213141516171819202122const map = new Map();map.set('aaa', 100);map.set('bbb', 200);for (let key of map.keys()) &#123; console.log(key);&#125;// 'aaa'// 'bbb'for (let value of map.values()) &#123; console.log(value);&#125;// 100// 200// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// aaa 100// bbb 200 PromisePromise 是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。 Promise 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。 简单归纳下 Promise： 三个状态、两个过程、一个方法，快速记忆方法： 3-2-1 三个状态：pending、fulfilled、rejected 两个过程： pending→fulfilled（resolve） pending→rejected（reject） 一个方法： then 当然还有其他概念，如 catch、Promise.all/race，这里就不展开了。 关于 ES6/7 的考查内容还有很多，这里就不逐一介绍了，如果想继续深入学习，可以点击查看《ES6入门》 小结 本文主要总结了 ES 基础语法中面试经常考查的知识点，包括之前就考查较多的原型、异步、作用域，以及 ES6 的一些新内容，这些知识点希望大家都要掌握。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解http]]></title>
    <url>%2F2018%2F06%2F14%2Fhttp%2F</url>
    <content type="text"><![CDATA[开始 输入URL打开网页 AJAX获取数据 img标签加载图片 ….. 输入url,按回车后redirect(浏览器记录判断跳转到新的地址了) 看App cache是否缓存了 DNS解析,查找到对应的服务器的ip地址 TCP链接,三次握手 发送请求和接收响应 网络协议分层 低三层 物理层:主要作用是定义物理设备如何传输数据(硬件相关:网卡 端口 网线 光缆….) 数据链路层:在通信的实体间建立数据链路连接(01 基本的数据传输) 网络层:为数据在结点之间传输创建逻辑链路(如寻找服务器的逻辑地址) 传输层 向用户提供端到端(End-to-End)的服务 传输层向高层屏蔽了下层数据通信的细节 应用层 为应用软件提供了很多服务 构建于TCP协议之上 屏蔽网络传输相关的细节 ……….未完待续]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技术 博客文章、书籍 积累]]></title>
    <url>%2F2018%2F06%2F10%2Fnecessary%2F</url>
    <content type="text"><![CDATA[总结 前端资源分享-只为更好前端 前端模块化（CommonJs,AMD和CMD) HTML和CSS 前端工程师必备实用网站 Box Shadow(阴影)-Css3演示 面试 前端面试宝典 原型链示意图 调试 JavaScript调试技巧 jQueryfullPage.jsjQuery全屏滚动插件fullPage.js]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>必备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-HTML知识点]]></title>
    <url>%2F2018%2F06%2F09%2FCSS-HTML%2F</url>
    <content type="text"><![CDATA[CSS 和 HTML 是网页开发中布局相关的组成部分，涉及的内容比较多和杂乱，本小节重点介绍下常考的知识点。 知识点梳理 一：选择器的权重和优先级CSS 选择器有很多，不同的选择器的权重和优先级不一样，对于一个元素，如果存在多个选择器，那么就需要根据权重来计算其优先级。 权重分为四级，分别是： 代表内联样式，如 style=&quot;xxx&quot;，权重为 1000 代表 ID 选择器，如 #content，权重为 100 代表类、伪类和属性选择器，如 .content、:hover、[attribute]，权重为 10 代表元素选择器和伪元素选择器，如 div、p，权重为 1 需要注意的是：通用选择器（*）、子选择器（&gt;）和相邻选择器（+）并不在这四个等级中，所以他们的权重都为 0 。权重值大的选择器其优先级也高，相同权重的优先级又遵循后定义覆盖前面定义的情况。 二：盒模型什么是 “盒子”初学 CSS 的小伙伴，一开始学 CSS 基础知识的时候一定学过 padding、margin和border，即内边距、外边距和边框。它们三者就构成了一个 “盒子”。就像我们收到的快递，本来买了一部小小的手机，收到的却是那么大一个盒子。因为手机的包装盒和手机之间有间隔层（内边距），手机盒子有厚度（边框），盒子和快递箱子之间还有一层泡沫板（外边距）。 题目：盒子模型的宽度如何计算 固定宽度的盒子1234&lt;div style="padding:10px; border:5px solid blue; margin: 10px; width:300px;"&gt; 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》， 文章言简意赅的介绍的浏览器的工作过程，web前端&lt;/div&gt; 如上代码，放在浏览器运行，发现文字内容的宽度刚好是 300px，也就是我们设置的宽度。 因此， 在盒子模型中，我们设置的宽度都是内容的宽度，不是整个盒子的宽度。而整个盒子的宽度是：（内容宽度 + border 宽度 + padding 宽度 + margin 宽度）之和。这样我们改四个钟的其中一个，都会导致盒子宽度的改变。这对我们来说不友好。 充满父容器的盒子默认情况下，div 是 display:block，宽度会充满整个父容器。但是别忘记，这个 div 是个盒子模型，它的整个宽度包括（内容宽度 + border 宽度 + padding 宽度 + margin 宽度），整个宽度充满父容器。 问题就在这里。如果父容器宽度不变，我们手动增大 margin、border 和padding 其中一项的宽度值，都会导致内容宽度的减少。极端情况下，如果内容的宽度压缩到不能再压缩了（例如一个字的宽度），那么浏览器会强迫增加父容器的宽度。这可不是我们想要看到的。 包裹内容的盒子这种情况下比较简单，内容的宽度按照内容计算，盒子的宽度将在内容宽度的基础上再增加（padding 宽度 + border 宽度 + margin 宽度）之和。 box-sizing:border-box前面提到，为盒子模型设置宽度，结果只是设置了内容的宽度，这个不合理。如何解决这一问题？答案就是为盒子指定样式：box-sizing；border-box。 1234&lt;div style="padding:10px; border:5px solid blue; margin: 10px; width:300px; box-sizing:border-box"&gt; 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》， 文章言简意赅的介绍的浏览器的工作过程，web前端&lt;/div&gt; 以上代码，为 div 设置了 box-sizing:border-box之后，300px 的 宽度是内容 + padding + 边框的宽度（不包括 margin），这样就比较符合我们的实际要求了。建议大家在为系统写 CSS 的时候，第一个样式是： 1* &#123;box-sizing: border-box&#125; 大名鼎鼎的 Bootstrap 也把 box-sizing:border-box 加入到它的 * 选择器中，我们为什么不这样做呢？ 纵向 margin 重叠这里提到 margin，那就不得不提一下 margin 的这一特性——纵向重叠。如&lt;p&gt;的纵向 margin 是 16px，那么两个&lt;p&gt;之间纵向的距离是多少？按常理来说应该是 16 + 16 = 32px，但是答案仍然是 16px。因为纵向的 margin 是会重叠的，如果两个不一样大的话，大的会把小的 “吃掉”。 三：浮动 floatfloat 用于网页布局比较多，使用起来也比较简单，这里总结了一些比较重要、需要注意的知识点，供大家参考。 误解和误用float 被设计出来的初衷是用于 文字环绕效果，即一个图片一段文字，图片 float:left之后，文字会环绕图片。 但是，后来大家发现结合 float + div 可以实现之前通过 table实现的网页布局，因此就被 “误用” 于网页布局了。 题目：为何 float 会导致父元素塌陷？ 破坏性float 的 破坏性——float 破坏了父标签的原本结构，使得父标签出现了坍塌现象。导致这一现象的最根本原因在于： 被设置了 float 的元素会脱离文档流。其根本原因在于 float 的设计初衷是解决文字环绕图片的问题。大家要记住 float 的这个影响。 包裹性包裹性也是 float 的一个非常重要的特性，大家用 float 时一定要熟知这一特性。咱们还是先从一个小例子看起： 如上图，普通的 div 如果没有设置宽度，它会撑满整个屏幕，在之前的盒子模型那一节也讲到过。而如果给 div 增加 float:left 之后，它突然变得紧凑了，宽度发生了变化，把内容中的三个字包裹了——这就是包裹性。为 div 设置了 float 之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。 注意，此时 div 虽然体现了包裹性，但是它的 display 样式是没有变化的，还是display:block。 float 为什么要具有包裹性？其实答案还是得从 float 的设计初衷来寻找，float 是被设计用于实现文字环绕效果的。文字环绕图片比较好理解，但是如果想要让文字环绕一个 div 呢？此时 div 不被 “包裹” 起来的话，就无法实现环绕效果了。 清空格float 还有一个大家可能不是很熟悉的特性——清空格。按照惯例，咱还是先举例说明（自己准备图片,查看添加 float:left 前后的效果）。 123456&lt;div style="border: 2px solid blue; padding:3px; float:left;"&gt; &lt;img src="image/1.png"/&gt; &lt;img src="image/2.png"/&gt; &lt;img src="image/3.png"/&gt; &lt;img src="image/4.png"/&gt;&lt;/div&gt; 在没有添加 float:left 之前，正常的 img 中间是会有空格的，因为多个 img 标签会换行，而浏览器识别换行为空格，这也是很正常的。 在添加了 float:left 之后，就使得 img 之间没有了空格，4 个 img 紧紧挨着。 如果大家之前没注意，现在想想之前写过的程序，是不是有这个特性。为什么 float 适合用于网页排版（俗称 “砌砖头”）？就是因为 float 排版出来的网页严丝合缝，中间连个苍蝇都飞不进去。 “清空格” 这一特性的根本原因是 float 会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没了关系，它就尽量往一边靠拢，能靠多近就靠多近，这就是清空格的本质。 题目：手写 clearfix clearfix清除浮动的影响，一般使用的样式如下，统称 clearfix 代码。所有 float 元素的父容器，一般情况下都应该加 clearfix 这个 class。 12345678.clearfix:after &#123; content: ''; display: table; clear: both;&#125;.clearfix &#123; *zoom: 1; /* 兼容 IE 低版本 */&#125; 1234&lt;div class="clearfix"&gt; &lt;img src="image/1.png" style="float: left"/&gt; &lt;img src="image/2.png" style="float: left"/&gt;&lt;/div&gt; 小结float 的设计初衷是解决文字环绕图片的问题，后来误打误撞用于做布局，因此有许多不合适或者需要注意的地方，上文基本都降到了需要的知识点。如果刚开始接触 float 的同学，学完上面的基础知识后，还应该做一些练习实战一下——经典的 “圣杯布局” 和 “双飞翼布局”。这里就不再展开讲了，网上资料非常多，例如 浅谈面试中常考的两种经典布局。 四：定位 positionposition 用于网页元素的定位，可设置 static/relative/absolute/fixed 这些值，其中 static 是默认值，不用介绍。 relative相对定位 relative 可以用一个例子很轻松的演示出来。例如我们写 4 个 &lt;p&gt;，出来的样子大家不用看也能知道。 1234&lt;p&gt;第一段文字&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;p&gt;第三段文字&lt;/p&gt;&lt;p&gt;第四段文字&lt;/p&gt; 然后我们在第三个 &lt;p&gt; 上面，加上 position:relative 并且设置 left 和 top 值，看这个 &lt;p&gt; 有什么变化 1234&lt;p&gt;第一段文字&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;p style="position:relative; top: 10px; left: 10px"&gt;第三段文字&lt;/p&gt;&lt;p&gt;第四段文字&lt;/p&gt; 通过浏览器运行的结果，大家应该要识别出两个信息（相信大部分人会忽略第二个信息） 第三个&lt;p&gt;发生了位置变化，分别向右向下移动了 10px 其他的三个&lt;p&gt;位置没有发生变化，这一点也很重要 可见，relative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小。这是 relative 的要点之一。还有第二个要点，就是 relative 产生一个新的定位上下文。 absolute还是先写一个基本的 demo 1234&lt;p&gt;第一段文字&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;p style="background: yellow"&gt;第三段文字&lt;/p&gt;&lt;p&gt;第四段文字&lt;/p&gt; 然后，我们把第三个&lt;p&gt;改为position:absolute;，看看会发生什么变化。从浏览器运行的结果中，我们能看出几点信息： absolute 元素脱离了文档结构。和 relative 不同，其他三个元素的位置重新排列了。只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌。（此时你应该能立刻想起来，float 元素也会脱离文档结构。） absolute 元素具有 “包裹性”。之前&lt;p&gt;的宽度是撑满整个屏幕的，而此时&lt;p&gt;的宽度刚好是内容的宽度 absolute 元素具有 “跟随性”。虽然 absolute 元素脱离了文档结构，但是它的位置并没有发生变化，还是老老实实地待在它原本的位置，因为我们此时没有设置 top、left 的值 absolute 元素会悬浮在页面上方，会遮挡住下方的页面内容 最后，通过给 absolute 元素设置 top、left 值，可自定义其内容，这个都是平时比较常用的。这里需要注意的是，设置了 top、left 值时，元素是相对于最近的定位上下文来定位的，而不是相对于浏览器定位。 fixed其实 fixed 和 absolute 是一样的，唯一的区别在于 :absolute 元素是根据最近的定位上下文确定位置，而 fixed 根据 window（或者 iframe）确定位置。 题目：relative、absolute 和 fixed 分别依据谁来定位？ 定位上下文relative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。 fixed 元素的定位是相对于 window（或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。 absolute 的定位相对于前两者要复杂许多。如果 absolute 设置了 top、left，浏览器会根据什么区确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了position:relative/absolute/fixed的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。 五：flex 布局布局的传统解决方案基于盒模型，依赖display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中（下文会专门讲解）就不容易实现。在目前主流的移动端页面中，使用 flex 布局能更好地完成需求，因此 flex 布局的知识是必须要掌握的。 基本使用任何一个容器都可以使用 flex 布局，代码也很简单（请到浏览器查看结果）。 12345678910111213141516&lt;style type="text/css"&gt; .container &#123; display: flex; &#125; .item &#123; border: 1px solid #000; flex: 1; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="item"&gt;aaa&lt;/div&gt; &lt;div class="item" style="flex: 2"&gt;bbb&lt;/div&gt; &lt;div class="item"&gt;ccc&lt;/div&gt; &lt;div class="item"&gt;ddd&lt;/div&gt;&lt;/div&gt; 注意，第三个&lt;div&gt;的flex:2，其他的&lt;div&gt;的flex:1，这样第二个&lt;div&gt;的宽度就是其他的&lt;div&gt;的两倍。 设计原理设置了display:flex的元素，我们称为 “容器”（flex container），其所有的子节点我们称为 “成员”（flex item）。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 将以上文字和图片结合起来，再详细看一遍，这样就能理解 flex 的设计原理，才能更好地实际使用。 设置主轴的方向flex-direction可决定主轴的方向，有四个可选项： row（默认值）：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 123.box &#123; flex-direction: column-reverse | column | row | row-reverse;&#125; 以上代码设置的主轴方向，将以此对应下图： 设置主轴的对齐方式justify-content属性定义了项目在主轴上的对齐方式，值如下： flex-start（默认值）：向主轴开始方向对齐 flex-end：向主轴结束方向对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 123.box &#123; justify-content: flex-start | flex-end | center |space-between | space-around;&#125; 交叉轴的对齐方式align-item属性定义项目在交叉轴上如何对齐，值如下： flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。 123.box &#123; align-item: flex-start | flex-end | center | baseline | stretch;&#125; 六：如何实现居中对齐？ 题目：如何实现水平居中 水平居中inline 元素用text-align:center;即可，如下： 123.container &#123; text-align: center;&#125; block 元素可使用margin: auto;，PC 时代的很多网站都这么搞。 1234567.container &#123; text-align: center;&#125;.item &#123; width: 1000px; margin: auto;&#125; 绝对定位元素可结合left和margin实现，但是必须知道宽度。 1234567891011.container &#123; position: relative; width: 500px;&#125;.item &#123; width: 300px; height: 100px; position: absolute; left: 50%; margin: -150px;&#125; 题目：如何实现垂直居中？ inline 元素可以设置line-height的值等于height值，如单行文字垂直居中： 1234.container &#123; height: 50px; line-height: 50px;&#125; 绝对定位元素，可结合left和margin实现，但是必须知道尺寸。 优点：兼容性好 缺点：需要提前知道尺寸 12345678910111213.container &#123; position: relative; height: 200px;&#125;.item &#123; width: 80px; height: 40px; position: absolute; left: 50%; top: 50%; margin-top: -20px; margin-left: -40px;&#125; 绝对定位可结合transform实现居中。 优点：不需要提前知道尺寸 缺点：兼容性不好 123456789101112.container &#123; position: relative; height: 200px;&#125;.item &#123; width: 80px; height: 40px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; 绝对定位结合margin: auto，不需要提前知道尺寸，兼容性好。 1234567891011121314.container &#123; position: relative; height: 300px;&#125;.item &#123; width: 100px; height: 50px; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;&#125; 其他的解决方案还有，不过没必要掌握太多，能说出上文的这几个解决方案即可。 七：理解语义化 题目：如何理解 HTML 语义化？ 所谓 “语义” 就是为了更容易读懂，这要分两部分： 让人（写程序、读程序）更易读懂 让机器（浏览器、搜索引擎）更易读懂 让人更易读懂对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，定义 CSS class 的时候也一样，例如length、list等，而不是使用a b这种谁都看不懂的名称。 不过我们平常考查的 “语义化” 并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。 让机器更易读懂HTML 符合 XML 标准，但又和 XML 不一样——HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。问题就在这里——HTML 为何要自己规定那么多标签名称呢，例如p div h1 ul等——就是为了语义化。其实，如果你精通 CSS 的话，你完全可以全部用&lt;div&gt;标签来实现所有的网页效果，其他的p h1 ul 等标签可以一个都不用。但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。 拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好的去理解网页的内容呢？就是根据 HTML 既定的标签，h1标签就代表是标题；p里面的就是段落详细内容，权重肯定没有标题高；ul里面就是列表；strong就是加粗的强调的内容。如果我们不按照 HTML 语义化来写，全部都用&lt;div&gt;标签，那搜索引擎将很难理解我们网页的内容。 为了加强 HTML 语义化，HTML5 标准中又增加了header section artical等标签。因此，书写 HTML 时，语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。 八：CSS3 动画CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。 首先，使用@keyframes定义一个动画，名称为testAnimation，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。 12345678@keyframes testAnimation&#123; 0% &#123;background: red; left:0; top:0;&#125; 25% &#123;background: yellow; left:200px; top:0;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0; top:200px;&#125; 100% &#123;background: red; left:0; top:0;&#125;&#125; 然后，针对一个 CSS 选择器来设置动画，例如针对div元素设置动画，如下 1234567div &#123; width: 100px; height: 50px; position: absolute; animation-name: testAnimation; animation-duration: 5s;&#125; animation-name对应到动画名称，animation-duration是动画时长，还有其他属性： animation-timing-function：规定动画的速度曲线，默认是ease animation-delay：规定动画何时开始，默认是 0 animation-iterationcount：规定动画被播放的次数，默认是 1 animation-direction：规定动画是否在下一周期逆向地播放，默认是 normal animation-play-state：规定动画是否正在运行或暂停，默认是 running animation-fill-mode：规定动画执行之前和之后如何给动画的目标应用，默认是none，保留在最后一帧可以用forwards 题目：CSS 的 transition和animation有何区别 首先transition和animation都可以做动效，从语义上来理解，transition是过渡，由一个状态过渡到另一个状态，比如高度100px过渡到200px；而animation是动画，即更专业做动效的，animation有帧的概念，可以设置关键帧keyframe，一个动画可以由多个关键帧多个状态过渡组成。 九：重绘和回流重绘和回流也是面试经常考的题目，也是性能优化当中应该注意的点，下面简单介绍下。 重绘：指的是当页面中的元素不脱离文档流，而简单地进行样式的变化，比如修改颜色、背景等，浏览器重新绘制样式 回流：指的是处于文档流中 DOM 的尺寸大小，位置或者某些属性发生变化时，导致浏览器重新渲染部分或全部文档的情况 相比之下，回流要比重绘消耗性能开支更大。另外，一些属性的读取也会引起回流，比如读取某个 DOM 的高度和宽度，或者使用getComputedStyle方法。在写代码的时候要避免回流和重绘。比如在笔试中可能会遇见下面的题目： 题目：找出下面代码的优化点，并且优化它 12345var data = ['string1', 'string2', 'string3'];for (var i = 0; i &lt; data.length; i++) &#123; var dom = document.getElementById('list'); dom.innerHTML += '&lt;li&gt;' + data[i] + '&lt;/li&gt;';&#125; 上面的代码在循环中每次都获取dom，然后对其内部的 HTML 进行累加li，每次都会操作 DOM 结构，可以改成使用documentFragment或者先遍历组成 HTML 的字符串，最后操作一次 innerHTML。 小结本小节总结了 CSS 和 HTML 常考的知识点，包括 CSS 中比较重要的定位、布局的知识，也介绍了 CSS3 的知识点概念和题目，以及 HTML 的语义化。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
