<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[布局]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[几种布局的方法: 经典 圣杯与双飞翼]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器知识点]]></title>
    <url>%2F2018%2F06%2F14%2Fbrowser%2F</url>
    <content type="text"><![CDATA[Web前端工程师写的页面要跑在浏览器里面，所以面试中也会出现很多跟浏览器相关的面试题目。 知识点梳理 [TOC] 一：加载页面和渲染过程可将加载过程和渲染过程分开说。回答问题的时候，关键要抓住核心的要点，把要点说全面，稍加解析即可，简明扼要不拖沓。 题目：浏览器从加载页面到渲染页面的过程 加载过程要点如下： 浏览器根据 DNS 服务器得到域名的 IP 地址 向这个 IP 的机器发送 HTTP 请求 服务器收到、处理并返回 HTTP 请求 浏览器得到返回内容 例如在浏览器输入http://baidu.com，然后经过 DNS 解析，baidu.com对应的 IP 是220.181.57.216]（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。 sever 端接收到 HTTP 请求，然后经过计算（向不同的用户推荐不同的内容），返回 HTTP 请求。返回的内容是一堆 HTML 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。 渲染过程要点如下： 根据 HTML 结构生成 DOM 树 根据 CSS 生成 CSSOM 将 DOM 和 CSSOM 整合形成 RenderTree 根据 RenderTree 开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 上文中，浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，因此要把 HTML 字符串转化成 DOM 树 —— 树是最基本的数据结构之一。 解析过程中，如果遇到&lt;link href=&quot;...&quot;&gt;和&lt;script src=&quot;...&quot;&gt;这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载来的字符串是 CSS 或者 JS 格式的。 浏览器将 CSS 生成 CSSOM ，再将 DOM 和 CSSOM 整合成 RenderTree，然后针对 RenderTree 即可进行渲染了。大家可以想一下，有 DOM 结构、有样式，此时就能满足渲染的条件了。另外，这里也可以解释一个问题 —— 为何将 CSS 放在 HTML 头部？—— 这样会让浏览器今早拿到 CSS 尽早生成 CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。 最后，渲染过程中，如果遇到&lt;script&gt;就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待&lt;script&gt;内部执行完之后，浏览器继续渲染。最后再思考一个问题 —— 为何将 JS 放在 HTML 底部？ —— JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。 关于浏览器整个流程，百度的多益大神有更加详细的文章，推荐阅读下：《从输入 URL 到页面加载完成的过程中都发生了什么事情？》 二：性能优化性能优化的题目也是面试常考的，这类题目有很大的扩展性，能够扩展出来很多小细节，而且对个人的技术视野和业务能力有很大的挑战。这部分会重点讲下常用的性能优化方案。 题目：总结前端性能优化的解决方案 优化原则和方向性能优化的原则是 以更好的用户体验为标准，具体就是实现下面的目标： 多使用内存、缓存或者其他方法 减少 CPU 和 GPU 计算，更快展现 优化的方向有两个 减少页面体积，提升网络加载 优化页面渲染 减少页面体积，提升网络加载 静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图） 静态资源缓存（资源名称加 MD5 戳） 使用 CDN 让资源加载更快 优化页面渲染 CSS 放前面，JS 放后面 懒加载（图片懒加载、下拉加载更多） 减少 DOM 查询，对 DOM 查询做缓存 减少 DOM 操作，多个操作尽量合并在一起执行（DocumentFragment） 事件节流 尽早执行操作（DOMContentLoaded） 使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间 详细解释静态资源的压缩合并如果不合并，每个都会走一遍之前介绍的请求过程 123&lt;script src="a.js"&gt;&lt;/script&gt;&lt;script src="b.js"&gt;&lt;/script&gt;&lt;script src="c.js"&gt;&lt;/script&gt; 如果合并了，就只走一遍请求过程 1&lt;script src="abc.js"&gt;&lt;/script&gt; 静态资源缓存通过链接名称控制缓存 1&lt;script src="abc_1.js"&gt;&lt;/script&gt; 只有内容改变的时候， 链接名称才会改变 1&lt;script src="abc_2.js"&gt;&lt;/script&gt; 这个名称不用手动改，可通过前端构建工具根据文件内容，为文件名称添加 MD5 后缀。 使用 CDN 让资源加载更快CDN 会提供专业的加载优化方案，静态资源要尽量放在 CDN 上。例如： 1&lt;script src="https://cdn.bootcss.com/zepto/1.0rc1/zepto.min.js"&gt;&lt;/script&gt; 使用 SSR 后端渲染可一次性输出 HTML 内容，不用再页面渲染完成之后，再通过 Ajax 加载数据、再渲染。例如使用 smarty、Vue SSR 等。 CSS 放前面，JS 放后面上文讲述浏览器渲染过程时已经提过，不再赘述。 懒加载一开始先给src赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，preview.png是预览图片，比较小，加载很快，而且很多图片都共用这个preview.png，加载一次即可。待页面下拉，图片显示出来时，再去替换src为data-realsrc的值。 1&lt;img src="preview.png" data-realsrc="abc.png"/&gt; 另外，这里为何要用data-开头的属性值？ —— 所有 HTML 中自定义的属性，都应该用data-开头，因为data-开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。 DOM 查询做缓存两段代码做一下对比： 1234var pList = document.getElementsByTagName('p') // 只查询一个 DOM ，缓存在 pList 中了var ifor (i = 0; i &lt; pList.length; i++) &#123;&#125; 123var ifor (i = 0; i &lt; document.getElementsByTagName('p').length; i++) &#123; // 每次循环，都会查询 DOM ，耗费性能&#125; 总结：DOM 操作，无论查询还是修改，都是非常耗费性能的，应尽量减少。 合并 DOM 插入DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再同一插入 DOM。 12345678910var listNode = document.getElementById('list')// 要插入 10 个 li 标签var frag = document.createDocumentFragment();var x, li;for (x = 0; x &lt; 10; x++) &#123; li = document.createElement('li'); li.innerHTML = 'List item' + x; frag.appendChild(li); // 先放在 frag 中，最后一次性插入到 DOM 结构中&#125;listNode.appendChild(frag); 事件节流例如要在文字改变时触发一个 change 事件，通过 keyup 来监听。使用节流。 12345678910var textarea = document.getElementById('text');var timeoutId;textarea.addEventListener('keyup', function () &#123; if (timeoutId) &#123; clearTimeout(timeoutId) &#125; timeoutId = setTimeout(function () &#123; // 触发 change 事件 &#125;, 100) &#125;) 尽早执行操作123456window.addEventListener('load', function () &#123; // 页面的全部资源加载完才会执行，包括图片、视频等&#125;)document.addEventListener('DOMContentLoaded', function () &#123; // DOM 渲染完即可执行，此时图片、视频还可能没有加载完&#125;) 性能优化怎么做上面提到的都是性能优化的单个点，性能优化项目具体实施起来，应该按照下面步骤推进： 建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过程消耗时间记录下来 分析耗时较长时间段原因，寻找优化点，确定优化目标 开始优化 通过数据收集平台记录优化效果 不断调整优化点和预期目标，循环 2 ~ 4 步骤 性能优化是个长期的事情，不是一蹴而就的，应该本着先摸底、再分析、后优化的原则逐步来做。 三：Web 安全 题目：前端常见的安全问题有哪些 Web 前端的安全问题，能回答出下文的两个问题，这个题目就能基本过关了。开始之前，先说一个最简单的攻击方式 —— SQL 注入。 上学的时候就知道有一个 SQL注入 的攻击方式。例如做一个系统的登录界面，输入用户名和密码，提交之后，后端直接拿到数据就拼接 SQL 语句去查询数据库。如果在输入时进行了恶意的 SQL 拼装，那么最后生成的 SQL 就会有问题。但是现在稍微大型一点的系统，都不会这么做，从提交登录信息到最后拿到授权，要经过层层的验证。因此，SQL 注入都只出现在比较低端的小型的系统上。 XSS （Cross Site Scripting，跨站脚本攻击）这是前端最常见的攻击方式，很多大型网站（如 Facebook）都被 XSS 攻击过。 举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。但是如果我写的是恶意的 JS 脚本，例如获取document.cookie然后传输到自己的服务器上，那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。 其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码被执行了。JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限，例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。 XSS 的危害XSS 的危害相当大，如果页面可以随意执行比人不安全的 JS 代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。 比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。 还有利用获取 cookie 的方式，将 cookie 传入入侵者的服务器上，入侵者就可以模拟 cookie 登录网站，对用户的信息进行篡改。 XSS 的预防那么如何预防 XSS 攻击呢？ —— 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有： 123456&amp; 替换为：&amp;amp;&lt; 替换为：&amp;lt;&gt; 替换为：&amp;gt;” 替换为：&amp;quot;‘ 替换为：&amp;#x27;/ 替换为：&amp;#x2f; 替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。 除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加http-only限制，让 JS 获取不到 cookie 的内容。 CSRF（Cross-site request forgery，跨站请求伪造）CSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。 例如，一个支付类网站，给他人转账的接口是http://buy.com/pay?touid=999&amp;money=100，而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了http://buy.com，在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码&lt;img src=&quot;http://buy.com/pay?touid=999&amp;money=100&quot;/&gt;，他访问了邮件之后，其实就已经完成了购买。 CSRF 的发生其实是借助了一个 cookie 的特性。我们知道，登录了http://buy.com之后，cookie 就会有登录过的标记了，此时请求http://buy.com/pay?touid=999&amp;money=100是会带着 cookie 的，因此 server 端就知道已经登录了。而如果在 http://buy.com去请求其他域名的 API 例如http://abc.com时，是不会带 cookie 的，这是浏览器的同源策略的限制。但是 —— 此时在其他域名的页面中，请求 http://buy.com/pay?touid=999&amp;money=100，会带着 buy.com 的 cookie，这是发生 CSRF 攻击的理论基础。 预防 CSRF 就是加入各个层级的权限验证，例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者指纹才行。除此之外，敏感的接口使用 POST 请求而不是 GET 也是很重要的。 小结本小节总结了前端运行环境（即浏览器）的一些常考知识点，包括页面加载过程、如何性能优化以及需要注意的安全问题。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发环境知识点]]></title>
    <url>%2F2018%2F06%2F14%2Fdevelop%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[工程师的开发环境决定其开发效率，常用的开发环境配置也是面试考查点之一。 知识点梳理 [TOC] 一：IDE 题目：你平时都使用什么 IDE 编程？有何提高效率的方法？ 前端最常用的 IDE 有 webstorm、Sublime、Atom 和 VSCode，我们可以分别去它们的官网看一下。 Webstorm 是最强大的编辑器，因为它拥有各种强大的插件和功能。跟面试官聊到 Webstorm 的时候，没用过没事儿，但一定要知道它：第一，强大；第二，收费。 Sublime 第一它免费，第二它轻量、高效，第三它插件非常多。用 Sublime 一定要安装各种插件配合使用，可以去网上搜一下“sublime”常用插件的安装以及用法，还有它的各种快捷键，并且亲自使用它。这里就不一一演示了，网上的教程也很傻瓜式。 Atom 是 GitHub 出品的编辑器，跟 Sublime 差不多，免费并且插件丰富，而且跟 Sublime 相比风格上还有些小清新。但是它打开的时候会比较慢，卡一下才打开。当然总体来说也是很好用的，只是个人习惯问题。 VSCode 是微软出品的轻量级（相对于 Visual Studio 来说）编辑器，微软做 IDE 那是出了名的好，出了名的大而全，因此 VSCode 也有上述 Sublime 和 Atom 的各种优点。 总结一下： 如果你要走大牛、大咖、逼格的路线，就用 Webstorm 如果你走普通、屌丝、低调路线，就用 Sublime 如果你走小清新、个性路线，就用 VSCode 或者 Atom 如果你面试，最好有一个用的熟悉，其他都会一点 最后注意：千万不要说你使用 Dreamweaver 或者 notepad++ 写前端代码，会被人鄙视的。如果你不做 .NET 也不要用 Visual Studio，不做 Java 也不要用 Eclipse。 二：Git你此前做过的项目一定要用过 Git，而且必须是命令行，如果没用过，你自己也得恶补一下。对 Git 的基本应用比较熟悉的同学，可以跳过这一部分了。macOS 自带 Git，Windows 需要安装 Git 客户端，去 Git 官网下载即可。 国内比较好的 Git 服务商有 coding.net，国外有大名鼎鼎的 Github，但是有时会有网络问题，因此建议大家注册一个 coding.net 账号然后创建项目，来练练手。 题目：常用的 Git 命令有哪些？如何使用 Git 多人写作开发？ 常用的 Git 命令首先，通过git clone &lt;项目远程地址&gt;下载下来最新的代码，例如git clone git@git.coding.net:username/project-name.git，默认会下载master分支。 然后修改代码，修改过程中可以通过git status看到自己的修改情况，通过git diff &lt;文件名&gt;可查阅单个文件的差异。 最后，将修改的内容提交到远程服务器，做如下操作 123git add .git commit -m "xxx"git push origin master 如果别人也提交了代码，你想同步别人提交的内容，执行git pull origin master即可。 如何做人协作开发多人协作开发，就不能使用master分支了，而是要每一个开发者单独拉一个分支，使用git checkout -b &lt;branchname&gt;，运行git branch可以看到本地所有的分支名称。 自己的分支，如果想同步master分支的内容，可运行git merge master。切换分支可使用git checkout &lt;branchname&gt;。 在自己的分支上修改了内容，可以将自己的分支提交到远程服务器 123git add .git commit -m "xxx"git push origin &lt;branchname&gt; 最后，待代码测试没问题，再将自己分支的内容合并到master分支，然后提交到远程服务器。 123git checkout mastergit merge &lt;branchname&gt;git push origin master 关于 SVN关于 SVN，面试的时候可能会问到，但你只要熟悉了 Git 的操作，面试官不会因为你不熟悉 SVN 而为难你。前提是你要知道一点 SVN 的基本命令，自己上网一查就行。 不过 SVN 和 Git 的区别你得了解。SVN 是每一步操作都离不开服务器，创建分支、提交代码都需要链接服务器。而 Git 就不一样了，你可以在本地创建分支、提交代码，最后再一起 push 到服务器上。因此，Git 又有 SVN 的所有功能，但是却比 SVN 强大得多。（Git 是 Linux 的创始人 Linus 发明的东西，因此也倍得推崇。） 三：Linux 基础命令目前互联网公司的线上服务器都是用 Linux 系统，测试环境为了保证和线上一致，肯定也是使用 Linux 系统，而且都是命令行的，没有桌面，不能用鼠标操作。因此，掌握基础的 Linux 命令是非常必要的。下面总结一些最常见的 Linux 命令，建议大家在真实的 Linux 系统下亲自试一下。 关于如何得到 Linux 系统，有两个选择：第一，在自己电脑的虚拟机中安装一个 Linux 系统，例如 Ubuntu/CentOS 等，下载这些都不用花钱；第二，花钱去阿里云等云服务商租一个最便宜的 Linux 虚拟机。推荐第二种。一般正式入职之后，公司都会给你分配开发机或者测试机，给你账号和密码，你自己可以远程登录。 题目：常见 linux 命令有哪些？ 登录入职之前，一般会有现有的用户名和密码给你，你拿来之后直接登录就行。运行sshname@server然后输入密码即可登录。 目录操作 创建目录mkdir &lt;目录名称&gt; 删除目录rm &lt;目录名称&gt; 定位目录cd &lt;目录名称&gt; 查看目录文件ls ll 修改目录名mv &lt;目录名称&gt; &lt;新目录名称&gt; 拷贝目录cp &lt;目录名称&gt; &lt;新目录名称&gt; 文件操作 创建文件touch &lt;文件名称&gt; vi &lt;文件名称&gt; 删除文件rm &lt;文件名称&gt; 修改文件名mv &lt;文件名称&gt; &lt;新文件名称&gt; 拷贝文件cp &lt;文件名称&gt; &lt;新文件名称&gt; 文件内容操作 查看文件cat &lt;文件名称&gt; head &lt;文件名称&gt; tail &lt;文件名称&gt; 编辑文件内容vi &lt;文件名称&gt; 查找文件内容grep &#39;关键字&#39; &lt;文件名称&gt; 四：前端构建工具构建工具是前端工程化中不可缺少的一环，非常重要，而在面试中却又其特殊性 —— 面试官会通过询问构建工具的作用、目的来询问你对构建工具的了解，只要这些你都知道，不会再追问细节。因为，在实际工作中，真正能让你编写构建工具配置文件的机会非常少，一个项目就配置一次，后面就很少改动了。而且，如果是大众使用的框架（如 React、Vue等），还会直接有现成的脚手架工具，一键创建开发环境，不用手动配置。 题目：前端为何要使用构建工具？它解决了什么问题？ 何为构建工具“构建”也可理解为“编译”，就是将开发环境的代码转换成运行环境代码的过程。开发环境的代码是为了更好地阅读，而运行环境的代码是为了更快地执行，两者目的不一样，因此代码形式也不一样。例如，开发环境写的 JS 代码，要通过混淆压缩之后才能放在线上运行，因为这样代码体积更小，而且对代码执行不会有任何影响。总结一下需要构建工具处理的几种情况： 处理模块化：CSS 和 JS 的模块化语法，目前都无法被浏览器兼容。因此，开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如，使用 webpack、Rollup 等处理 JS 模块化。 编译语法：编写 CSS 时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等。这些标准目前也都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。 代码压缩：将 CSS、JS 代码混淆压缩，为了让代码体积更小，加载更快。 构建工具介绍最早普及使用的构建工具是 Grunt，不久又被 Gulp 给追赶上。Gulp 因其简单的配置以及高效的性能而被大家所接受，如果你做一些简单的 JS 开发，可以考虑使用。 如果你的项目比较复杂，而且是多人开发，那么你就需要掌握目前构建工具届的神器 —— webpack。不过神器也有一个缺点，就是学习成本比较高，需要拿出专门的时间来专心学习，而不是三言两语就能讲完的。我们下面就演示一下 webpack 最简单的使用，全面的学习还得靠大家去认真查阅相关文档，或者参考专门讲解 webpack 的教程。 webpack 演示接下来我们演示一下 webpack 处理模块化和混淆压缩代码这两个基本功能。 首先，你需要安装 Node.js，没有安装的可以去 Node.js官网 下载并安装。安装完成后运行如下命令来验证是否安装成功。 12node -vnpm -v 然后，新建一个目录，进入该目录，运行npm init，按照提示输入名称、版本、描述等信息。完成之后，该目录下出现了一个package.json文件，是一个 JSON 文件。 接下来，安装 webpack，运行npm i --save-dev webpack。然后编写源代码，在该目录下创建src文件夹，并在其中创建app.js和dt.js两个文件，文件内容分别是： 12345678910// dt.js 内容module.exports = &#123; getDateNow: function () &#123; return Date.now() &#125;&#125;// app.js 内容var dt = require('.dt.js')alert(dt.getDateNow()) 然后，再返回上一层目录，新建index.html文件（该文件和 src 属于同一层级），内容是 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;test&lt;/div&gt; &lt;script src='./dist/bundle.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后编写 webpack 配置文件，新建webpack.config.js，内容是 1234567891011121314151617181920const path = require('path');const webpack = require('webpack');module.exports = &#123; context: path.resolve(__dirname, './src'); entry: &#123; app: './app.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; //supresses warnings, usually from module minification warnings: false &#125; &#125;) ]&#125; 总结一下，目前项目的文件目录是： 123456src +-- app.js +-- dt.jsindex.htmlpackage.jsonwebpack.config.js 接下来，打开package.json，然后修改其中scripts的内容为： 123"scripts": &#123; "starts": "webpack"&#125; 在命令行运行npm start，即可看到编译的结果，最后在浏览器中打开index.html，即可弹出Date.now()的值。 最后再次强调，深刻理解构建工具存在的价值，比你多会一些配置代码更加有意义，特别是对于应对面试来说。 五：调试方法调试方法这块被考查最多的就是如何进行抓包 题目：如何抓取数据？如何使用工具来配置代理？ PC 端的网页，我们可以通过 Chrome、Firefox 等浏览器自带的开发者工具来查看网页的所有网络请求，以帮助排查 bug。这种监听、查看网络请求的操作称为抓包。 针对移动端的抓包工具，Mac 系统下推荐使用 Charles 这个工具。Windows 系统推荐使用 Fiddler。两者使用基本一致，下面以 Charles 为例介绍。 接下来，将安装好的 Charles 的电脑和要抓包的手机，连接到同一个网络（一般为公司统一提供的内网，由专业网络工程师搭建），保证 IP 段相同。然后，将手机设置网络代理（不会的到网上查一下），代理的 IP 为电脑的 IP，代理的端口为8888。然后，Charles 可能会有一个弹框提示是否允许连接代理，这里选择 “允许” 即可。这样，使用手机端访问的网页或者联网的请求，Charles 就能监听到了。 在开发过程中，经常用到抓包工具来做代理，将线上的地址代理到测试环境，Charles 和 Fiddler 都可实现这个功能。以 Charles 为例，点击菜单栏中的 Tools 菜单，然后二级菜单中点击 Map Remote，会弹出配置框。首先，选中 Enable Map Remote 复选框，然后点击 Add 按钮，添加一个待立项。例如，如果要将线上的https://www.aaa.com/api/getuser?name=xxx这个地址代理到测试地址http://168.1.1.100:8080/api/getuser?name=xxx，配置如下图 小结本小节总结了前端开发环境常考查的知识，这些知识也是前端程序员必须掌握的，否则会影响开发效率。]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从容应对算法题目]]></title>
    <url>%2F2018%2F06%2F14%2Falgorithm%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[由冯·诺依曼机组成我们知道：数据存储和运算时计算机工作的主要内容。程序=数据结构+算法，所以计算机类工程师必须掌握一定的数据结构和算法知识。 知识点梳理 [TOC] 一：数据结构数据结构决定了数据存储的空间和事件效率问题，数据的写入和提取速度要求也决定了应该选择怎样的数据结构。 根据对场景需求的不同，我们设计不同的数据结构，比如： 读得多的数据结构，应该想办法提高数据的读取效率，比如 IP 数据库，只需要写一次，剩下的都是读取 读写都多的数据结构，要兼顾两者的需求平衡，比如 LRU Cache 算法 算法是数据加工处理的方式，一定的算法会提升数据的处理效率。比如有序数组的二分查找，要比普通的顺序查找快很多，尤其是在处理大量数据的时候。 数据结构和算法是程序开发的通用技能，所以在任何面试中都可能会遇见。随着近几年 AI、大数据、小游戏越来越火，Web 前端职位难免会跟数据结构和算法打交道，面试中也会出现越来越多的算法题目。学习数据结构和算法也能够帮助我们打开思路，突破技能瓶颈。 二：前端常遇见的数据结构问题现在我们来梳理下前端常遇见的数据结构： 简单数据结构（必须理解掌握） 有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小） 无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快） 复杂数据结构 树、堆 图 对于简单数据结构，在 ES 中对应的是数组（Array）和对象（Object）。可以想一下，数组的存储是有序的，对象的存储是无序的，但是我要在对象中根据key找到一个值时立即返回的，数组则需要查找的过程。 这里通过一个真实面试题目来说明介绍下数据结构设计。 题目：使用 ECMAScript 代码实现一个事件类Event，包含下面功能：绑定事件、解绑事件和派发事件 在稍微复杂点的页面中，比如组件化开发的页面，同一个页面由两三个人来开发，为了保证组件的独立性和降低组件间耦合度，我们往往使用 订阅发布模式，即组件间通信使用事件监听和派发的方式，而不是直接互相调用组件方法，这就是题目要求写的Event类。 这个题目的核心是一个事件类型对应回调函数的数据设计。为了实现绑定事件，我们需要一个_cache对象来记录绑定了哪些事件。而事件发生的时候，我们需要从_cache中读取出来事件回调，依次执行它们。一般页面中事件派发（读）要比事件绑定（写）多。所以我们设计的数据结构应该尽量地能够在事件发生时，更加快速地找到对应事件的回调函数，然后执行。 经过这样一番思考，简单写了下代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Event &#123; constructor() &#123; // 存储事件的数据结构 // 为了查找迅速，使用了对象（字典） this._cache = &#123;&#125; &#125; // 绑定 on(type, callback) &#123; // 为了按类查找方便和节省空间 // 将同一类型事件放在一个数组中 // 这里的数组是队列，遵循先进先出 // 即先绑定的事件先触发 let fns = (this._cache[type] = this._cache[type] || []); if (fns.indexOf(callback) === -1) &#123; fns.push(callback); &#125; return this; &#125; // 触发 trigger(type, data) &#123; let fns = this._cache[type]; if (Array.isArray(fns)) &#123; fns.forEach((fn) =&gt; &#123; fn(data); &#125;); &#125; return this; &#125; // 解绑 off(type, callback) &#123; let fns = this._cache[type]; if (Array.isArray(fns)) &#123; if (callback) &#123; let index = fns.indexOf(callback); if (index !== -1) &#123; fns.splice(index, 1) &#125; &#125; else &#123; // 全部清空 fns.length =0; &#125; &#125; return this; &#125;&#125;// 测试用例const event = new Event();event.on('test', (a) =&gt; &#123; console.log(a);&#125;);event.trigger('test', 'hello world');event.off('test');event.trigger('test', 'hello world'); 类似于树、堆、图这些高级数据结构，前端一般也不会考查太多，但是它们的查找方法却常考，后面介绍。高级数据应该平时多积累，好好理解，比如理解了堆是什么样的数据结构，在面试中遇到 查找堆大的 K 个数 这类算法问题，就会迎刃而解。 三：算法的效率是通过算法复杂度来衡量的算法的好坏可以通过算法的复杂度来衡量，算法复杂度包括时间复杂度和空间复杂度两个。时间复杂度由于好估量、好评估等特点，是面试中考查的重点。空间复杂度在面试中考查的不多。 常见的事件复杂度有： 常数阶 O(1) 对数阶 O(logN) 线性阶 O(n) 线性对数阶 O(nlogN) 平方阶 O(n^2) 立方阶 O(n^3) !k次方阶 O(n^k) 指数阶O(2^n) 随着问题规模 n 的不断增大，上述事件复杂度不断增大，算法的执行效率越低。 一般做算法复杂度分析的时候，遵循下面的技巧： 看看有几重循环，一般来说一重就是O(n),两重就是O(n^2)，以此类推 如果有二分，则为O(logN) 保留最高项，去除常数项 题目：分析下面代码的算法复杂度（为了方便，注释中加入了代码分析） 12345let i =0; // 语句执行一次 while (i &lt; n) &#123; // 语句执行 n 次 console.log(`Current i is $&#123;i&#125;`); //语句执行 n 次 i++; // 语句执行 n 次&#125; 根据注释可以得到，算法复杂度为1 + n + n + n = 1 + 3n，去除常数项，为O(n)。 1234let number = 1; // 语句执行一次 while (number &lt; n) &#123; // 语句执行 logN 次 number *= 2; // 语句执行 logN 次&#125; 上面代码while的跳出判断条件是number&lt;n，而循环体内number增长速度是(2^n)，所以循环代码实际执行logN次，复杂度为：1 + 2 * logN = O(logN) 12345for (let i = 0; i &lt; n; i++) &#123;// 语句执行 n 次 for (let j = 0; j &lt; n; j++) &#123;// 语句执行 n^2 次 console.log('I am here!'); // 语句执行 n^2 次 &#125;&#125; 上面代码是两个for循环嵌套，很容易得出复杂度为：O(n^2) 四：人人都要掌握的基础算法枚举和递归是最最简单的算法，也是复杂算法的基础，人人都应该掌握！枚举相对比较简单，我们重点说下递归。 递归由下面两部分组成： 递归主体，就是要循环解决问题的代码 递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出 关于递归有个经典的面试题目是： 实现 JS 对象的深拷贝 什么是深拷贝深拷贝就是在拷贝数据的时候，将数据的所有 引用结构 都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又互相独立的数据，将引用类型进行复制，而不是只复制其引用关系。 分析下怎么做深拷贝： 首先假设深拷贝这个方法已经完成，为 deepClone 要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复 1234567891011121314151617181920function deepClone(o1, o2) &#123; for (let k in o2) &#123; if (typeof o2[k] === 'object') &#123; o1[k] = &#123;&#125;; deepClone(o1[k], o2[k]); &#125; else &#123; o1[k] = o2[k]; &#125; &#125;&#125;// 测试用例let obj = &#123; a: 1, b: [1, 2, 3], c: &#123;&#125;&#125;;let emptyObj = Object.create(null);deepClone(emptyObj, obj);console.log(emptyObj.a == obj.a);console.log(emptyObj.b == obj.b); 递归容易造成爆栈，尾部调用可以解决递归的这个问题，Chrome 的 V8 引擎做了尾部调用优化，我们在写代码的时候也要注意尾部调用写法。递归的爆栈问题可以通过将递归改写成枚举的方式来解决，就是通过for或者while来代替递归。 我们在使用递归的时候，要注意做到优化，比如下面的题目。 题目：求斐波那契数列 1,1,2,3,5,8,13,21,34,55,89…中的第 n 项 下面的代码中count记录递归的次数，我们看下两种差异性的代码中的count的值： 12345678910111213141516171819202122232425262728293031let count = 0;function fn(n) &#123; let cache = &#123;&#125;; function _fn(n) &#123; if (cache[n]) &#123; return cache[n]; &#125; count++; if (n == 1 || n == 2) &#123; return 1; &#125; let prev = _fn(n - 1); cache[n - 1] = prev; let next = _fn(n - 2); cache[n - 2] = next; return prev + next; &#125; return _fn(n);&#125;let conut2 = 0;function fn2(n) &#123; count2++; if (n == 1 || n == 2) &#123; return 1; &#125; return fn2(n - 1) + fn2(n - 2);&#125;console.log(fn(20), count);console.log(fn2(20), count2); 五：快排和二分查找前端中面试排序和查找的可能性比较小，因为 JS 引擎已经把这些常用操作优化得很好了，可能项目中你费尽写的一个排序方法，都不如Array.sort速度快且代码少。因此，掌握快排和二分查找就可以了。 快排和二分查找都基于一种叫做 分治 的算法思想，通过对数据进行分类处理，不断降低数量级，实现O(logN)（对数级别，比O(n)这种线性复杂度更低的一种，快排核心是二分法的O(logN)，实际复杂度为O(N*logN)）的复杂度。 快速排序快排大概的流程是： 随机选择数组中的一个数 A，以这个数为基准 其他数字跟这个数进行比较，比这个数小的放在其左边，大的放到其右边 经过一次循环之后，A 左边为小于 A 的，右边为大于 A 的 这时候将左边和右边的数再递归上面的过程 具体代码如下： 1234567891011121314151617181920const Arr = [85, 24, 63, 45, 17, 31, 96, 50];function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let pivotIndex = Math.floor(arr.length / 2); let pivot = arr.splice(pivotIndex, 1)[0]; let left = []; let right = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; // 递归 return quickSort(left).concat([pivot], quickSort(right));&#125;console.log(quickSort(Arr)); 二分查找二分查找法主要是解决 在一堆有序的数中找出指定的数 这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。 二分查找是一种 分治 思想的算法，大概流程如下： 数组中排在中间的数字 A，与要找的数字比较大小 因为数组是有序的，所以 : a) A 较大则说明要查找的数字应该从前半部分查找 b) A 较小则说明应该从查找数字的后半部分查找 这样不断查找缩小数量级（扔掉一般数据），知道找完数组为止 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数 12345678910111213141516171819202122function Find(target, array) &#123; let i = 0; let j = array[i].length - 1; while (i &lt; array.length &amp;&amp; j &gt;= 0) &#123; if (array[i][j] &lt; target) &#123; i++; &#125; else if (array[i][j] &gt; target) &#123; j--; &#125; else &#123; return true; &#125; &#125; return false;&#125;//测试用例console.log(Find(10, [ [1, 2, 3, 4], [5, 9, 10, 11], [13, 20, 21, 23] ])); 题目：现在我有一个 1 ~ 1000 区间中的正整数，需要你猜下这个数字是几，你只能问一个问题：大了还是小了？问需要猜几次才能猜对？ 猜几次呢？其实这个问题就是个二分查找的算法事件复杂度问题，二分查找的时间复杂度是O(logN)，所以求log1000的解就是猜的次数。我们知道2^10=1024，所以可以快速估算出：log1000约等于 10，所以，最多问 10 次就能猜到这个数。 六：面试遇见不会的算法题怎么办面试时，在遇见算法题目的时候，应该揣摩面试官的意图，听好关键词，比如：有序的数列做查找、要求算法复杂度是O(logN)这类一般就是用二分的思想。 一般来说算法题的解题思路分以下四步： 先降低数量级，拿可以计算出来的情况（数据）来构思解题步骤 根据解题步骤编写程序，优先将特殊情况做好判断处理，比如一个大数组的问题，如果数组为两个数长度的情况 检验程序正确性 是否可以优化（由浅到深），有能力的话可以故意预留优化点，这样可以体现个人技术能力 七：正则匹配解题很多算法题目利用 ES 语法的特性来回答更加简单，比如正则匹配就是常用的一种方式。下面简单通过几个真题来汇总下正则的知识点。 题目：字符串中第一个出现一次的字符 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g 。当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l 。 这个如果用纯算法来解答需要遍历字符串，统计每个字符出现的次数，然后按照字符串的顺序来找出第一次出现一次的字符，整个过程比较繁琐，如果用正则就简单多了。 12345678910function find(str) &#123; for (var i = 0; i &lt; str.length; i++) &#123; let char = str[i]; let reg = new RegExp(char, 'g'); let l = str.match(reg).length; if (l === 1) &#123; return char &#125; &#125;&#125; 当然，使用indexOf/lastIndexOf也是一个取巧的方式。再来看一个千分位问题。 题目：将 1234567 变成 1，234，567 ，即千分位标注 这个题目可以用算法直接来解，如果我们用正则来回答，这样主动展现了自己其他方面的优势，即使不是算法解答出来的，面试官一般也不会太难为我们。这道题目可以利用正则的 零宽断言(?=exp)，意思是它断言自身出现的位置的后面能匹配表达式 exp。数字千分位的特点是，第一个逗号后面数字的个数是 3 的倍数，正则：/(\d{3})+$/；第一个都好前最多可以有 1 ~ 3 个数字，正则：/\d{1,3}/。加起来就是/\d{1,3}(\d{3})+$/，分隔符要从前往后加。 对于零宽断言的详细介绍可以阅读 零宽断言这篇文章。 12345678910111213function exchange(num) &#123; num += ''; // 转成字符串 if (num.length &lt;= 3) &#123; return num; &#125; num = num.replace(/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g, (v) =&gt; &#123; console.log(v) return v + ','; &#125;) return num;&#125;console.log(exchange(1234567)); 当然上面降到的多数是算法题目取巧的方式，下面这个题目是纯正则考查。 题目：请写出下面的代码执行结果 12345var str = 'google';var reg = /o/g;console.log(reg.test(str))console.log(reg.test(str))console.log(reg.test(str)) 代码执行后，会发现，最后一个不是为true，而是false，这是因为reg这个正则有个g，即global全局的属性，这种情况下lastIndex就发挥作用了，可以看下面的代码执行结果就明白了 。 123console.log(reg.test(str), reg.lastIndex)console.log(reg.test(str), reg.lastIndex)console.log(reg.test(str), reg.lastIndex) 实际开发中也会犯这样的错误，比如为了减少变量每次都重新定义，会把用到的变量提前定义好，这样在使用的时候容易掉进坑里，比如下面代码： 1234567891011(function()&#123; const reg = /o/g; function isHasO(str)&#123; // reg.lastIndex = 0; 这样就可以避免这种情况 return reg.test(str) &#125; var str = 'google'; console.log(isHasO(str)) console.log(isHasO(str)) console.log(isHasO(str))&#125;()) 小结本小节介绍了数据结构和算法的关系，作为普通的前端也应该学习数据结构和算法知识，并且顺带介绍了下正则匹配。具体来说，本小节梳理了以下几部分数据结构和算法知识点： 经常用到的数据结构有哪些，它们的特点有哪些 递归和枚举是最基础的算法，必须牢牢掌握 排序里面理解并掌握快速排序算法，其他排序算法可以根据个人实际情况大概了解 有序查找用二分查找 遇见不会的算法问题，先缩小数量级，然后分析推导 当然算法部分还有很多知识，比如动态规划这些算法思想，还有图和树常用到的广度优先搜索和深度优先搜索。这些知识在前端面试和项目中遇见得不多，感兴趣的读者可以在梳理知识点的时候根据个人情况自行决定是否复习。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM和DOM知识点]]></title>
    <url>%2F2018%2F06%2F14%2FBOM-DOM%2F</url>
    <content type="text"><![CDATA[除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。 知识点梳理 [TOC] 一：BOMBOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。 navigator screen location history 这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3cschool 这种网站一查就明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例。 获取浏览器特性（即俗称的 UA）然后识别客户端，例如判断是不是 Chrome 浏览器 123var ua = navigator.userAgentvar isChrome = ua.indexOf('Chrome')console.log(isChrome) 获取屏幕的宽度和高度 12console.log(screen.width)console.log(screen.height) 获取网址、协议、path、参数、hash 等 12345console.log(location.href) // 获取网址console.log(location.protocol) // 获取协议console.log(location.pathname) // 获取 pathconsole.log(location.search) // 获取参数console.log(location.hash) // 获取 hash 另外，还有调用浏览器的前进、后退功能等 12history.back()history.forward() 二：DOM 题目：DOM 和 HTML 的区别和联系 什么是 DOM讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的书，它是一棵树。 1234567891011&lt;?xml version="1.0" encoding="UTF-8"&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body &lt;other&gt; &lt;a&gt;&lt;/a&gt; &lt;b&gt;&lt;/b&gt; &lt;/other&gt;&lt;/note&gt; HTML 是一个既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;this is p&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们开发完的 HTML 代码会保存到一个文档中（一般以 .html 或者 .htm 结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。 但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。 基于以上需求，浏览器就需要把 HTML 转化成 DOM， HTML 是一棵树， DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。 获取 DOM 节点最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例： 12345678910111213// 通过 id 获取var div1 = doucment.getElementById('div1') // 元素// 通过 tagname 获取var divList = document.getElementsByTagName('div') // 集合console.log(divList.length)console.log(divList[0])// 通过 class 获取var containerList = document.getElementsByClassName('container') // 集合// 通过 CSS 选择器获取var pList = document.querySelectorAll('p') // 集合 题目：property 和 attribute 的区别是什么 propertyDOM 节点符合之前讲述的对象的特征——可扩展属性，因为 DOM 节点本质上是一个 JS 对象。因此，如下代码所示，p 可以有 style 属性，有 className、nodeName、nodeType 属性。注意，这些都是 JS 范畴的属性，符合 JS 语法标准的。 12345678910var pList = document.querySelectorAll('p')var p = pList[0]console.log(p.style.width) // 获取样式p.style.width = '100px' // 修改样式console.log(p.className) // 获取 classp.className = 'p1' // 修改 class// 获取 nodeName 和 nodeTypeconsole.log(p.nodeName)console.log(p.nodeType) attributeproperty 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。 attribute 就是对 HTML 属性的 get、set，和 DOM 节点 JS 范畴的 property 没有关系。 123456var pList = document.querySelectorAll('p')var p = pList[0]p.getAttribute('data-name')p.setAttribute('date-name', 'xiaomi')p.getAttribute('style')p.setAttribute('style', 'font-size: 30px') 而且， get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。 题目：DOM 操作的基本 API 有哪些 新增节点 12345678910var div1 = document.getElementById('div1')// 添加新节点var p1 = document.createElement('p')p1.innerHTML = 'this is p1'div1.appendChild(p1) // 添加新创建的元素// 移动已有节点。注意，这里是“移动”，不是拷贝var p2 = document.getElementById('p2')div1.appendChild(p2) 获取父元素 12var div1 = document.getElementById('div1')var parent = div1.parentElement 获取子元素 12var div1 = document.getElementById('div1')var child = div1.childNodes 删除节点 123var div1 = document.getElementById('div1')var child = div1.childNodesdiv1.remooveChild(child[0]) 还有其他操作的API，例如获取前一个节点，获取后一个节点等，但是面试过程中经常考到的就是上面几个。 三：事件事件绑定普通的事件绑定写法如下： 123456var btn = document.getElementById('btn1')btn.addEventListener('click', function (event) &#123; // event.preventDefault() 阻止默认行为 // event.stopPropagation 阻止冒泡 console.log('clicked')&#125;) 为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。 12345678910// 通用的事件绑定函数function bindEvent (elem, type, fn) &#123; elem.addEventListener(type, fn)&#125;var a = document.getElementById('link1')// 写起来更加简单了bindEvent(a, 'click', function (e) &#123; e.preventDefault() // 阻止默认行为 alert('clicked')&#125;) 最后， 如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会。 现在互联网流量都在 App 上，IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。 题目：什么是事件冒泡 事件冒泡123456789101112&lt;body&gt; &lt;div id="div1"&gt; &lt;p id="p1"&gt;激活&lt;/p&gt; &lt;p id="p2"&gt;取消&lt;/p&gt; &lt;p id="p3"&gt;取消&lt;/p&gt; &lt;p id="p4"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id="div2"&gt; &lt;p id="p5"&gt;取消&lt;/p&gt; &lt;p id="p6"&gt;取消&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 对于以上 HTML 代码结构，要求点击 p1 时候进入激活状态，点击其他任何 都取消激活状态，如何实现？代码如下，注意看注释： 1234567891011var body = document.bodybindEvent(body, 'click', function (e) &#123; // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡 alert('取消')&#125;)var p1 = document.getElementById('p1')bindEvent(p1, 'click', function (e) &#123; e.stopPropagation() // 阻止冒泡 alert('激活')&#125;) 如果我们在 p1、div1、body 中绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用 e.stopPropagation() 就可以阻止冒泡 题目：如何使用事件代理？有何好处？ 事件代理我们设定一种场景，如下代码，一个 &lt;div&gt; 中包含了若干个 &lt;a&gt;，而且还能继续增加。那如何快捷方便地为所有 &lt;a&gt; 绑定事件呢？ 1234567&lt;div id="div1"&gt; &lt;a href="#"&gt;a1&lt;/a&gt; &lt;a href="#"&gt;a2&lt;/a&gt; &lt;a href="#"&gt;a3&lt;/a&gt; &lt;a href="#"&gt;a4&lt;/a&gt;&lt;/div&gt;&lt;button&gt;点击增加一个 a 标签&lt;/button&gt; 这里就会用到事件代理。我们要监听 &lt;a&gt; 的事件，但要把具体的事件绑定到 &lt;div&gt; 上，然后看事件的触发点是不是 &lt;a&gt;。 123456789var div1 = document.getElementById('div1')div1.addEventListener('click', function (e) &#123; // e.target 可以监听到触发点击事件的元素是哪一个 var target = e.target if (target.nodeName === 'A') &#123; // 点击的是 &lt;a&gt; 元素 alert(target.innerHTML) &#125;&#125;) 我们现在完善一下之前写的通用事件绑定函数，加上事件代理。 123456789101112131415161718192021222324function bindEvent(elem, type, selector, fn) &#123; // 这样处理，可接收两种调用方式 bindEvent(div1, 'click', 'a', function () &#123;...&#125;) 和 bindEvent(div1, 'click', function () &#123;...&#125; 这两种) if (fn == null) &#123; fn = selector selector = null &#125; // 绑定事件 elem.addEventListener(type, function (e) &#123; var target if (selector) &#123; // 有 selector 说明需要做事件处理 // 获取触发事件的元素，即 e.target target = e.tagget // 看是否符合 selector 这个条件 if (target.matches(selector)) &#123; fn.call(target, e) &#125; &#125; else &#123; // 无 selector 说明不需要事件代理 fn(e) &#125; &#125;)&#125; 然后这样使用，简单很多 1234567891011// 使用代理，bindEvent 多一个 'a' 参数var div1 = document.getElementById('div1')bindEvent(div1, 'cilck', 'a', function (e) &#123; console.log(this.innerHTML)&#125;)// 不使用代理var a = document.getElementById('a1')bindEvent(div1, 'click', function (e) &#123; console.log(a.innerHTML)&#125;) 最后，使用代理的优点如下： 使代码简洁 减少浏览器的内存占用 四：AjaxXMLHttpRequest 题目：手写 XMLHttpRequest 不借助任何库 这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。 1234567891011var xhr = new XMLHttpRequest()xhr.onreadystatechange = function () &#123; // 这里的函数异步执行，可参考之前 JS 基础中的异步模块 if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText) &#125; &#125;&#125;xhr.open('GET', '/api', false)xhr.send(null) 当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不在赘述。 状态码说明上述代码中，有两处状态码需要说明。xhr.readyState 是浏览器判断请求过程中各个阶段的，xhr.status 是 HTTP 协议中规定的不同结果的返回状态说明。 xhr.readyState 的状态码说明： 0 -代理被创建，但尚未调用 open() 方法 1 - open() 方法已经被调用 2 - open() 方法已经被调用，并且头部和状态已经可获得 3 -下载中， responseText 属性已经包含部分数据 4 -下载操作已完成 题目：HTTP 协议中，response 的状态码，常见的有哪些？ xhr.status 即 HTTP 状态码，有 2xx、3xx、4xx、5xx 这几种，比较常见的有以下几种： 200 正常 3xx 301 永久重定向。如 http://xxx.com 这个 GET 请求（最后没有 /），就会被 301 到http://xxx.com/ （最后是 /） 302 临时重定向。临时的，不是永久的 304 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有 If-Modified-Since:xxxx（要求返回更新时间是 xxx 时间之后的资源），如果此时服务器端资源未更新，则会返回 304 ，即不符合要求 404 找不到资源 5xx 服务器端出错了 看完要明白，为何上述代码中要同时满足 xhr.readyState == 4 和 xhr.status == 200。 Fetch API目前已经有一个获取 HTTP 请求更加方便的 API： Fetch，通过 Fetch 提供的 fetch() 这个全局函数方法可以很简单地发起异步请求，并且支持 Promise 的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 caniuse，看下其他浏览器兼容情况。 看一个简单的例子： 12345678fetch('some/api/data.json', &#123; method: 'POST', // 请求类型 GET POST header: &#123;&#125;, // 请求头信息，形式为 Headers 对象或 ByteString body: &#123;&#125;, // 请求主体（get 或 head 方法中不能包含 body） mode: '', // 请求的模式，是否跨域等，如 cors、no-cors 或 same-origin credenttials: '', // cookie 的跨域策略，如 omit、same-origin 或 include cache: '' // 请求的 cache 模式：default、no-store、reload、no-cache、force-cache 或 only-if-cached&#125;).then(function(response) &#123;...&#125;); Fetch 支持 headers 定义，通过 headers 自定义可以方便地实现多种请求方法（PUT、GET、POST等）、请求头（包括跨域）和 cache 策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和 formData 等。 跨域 题目：如何实现跨域 浏览器中有 同源策略，即一个域下的页面，无法通过 Ajax 获取到其他域的接口。例如有一个接口 http://baidu.com/course/ajaxcoursecom?cid=123，你自己的一个页面 http://xxx.com/page1.html 中的 Ajax 无法获取这个接口。这正是命中了 “同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。 url 哪些地方不同算作跨域？ 协议 域名 端口 但是 HTML 中几个标签能逃避过同源策略——&lt;script src=&quot;xxx&quot;&gt;、&lt;img src=&quot;xxx&quot;&gt;、&lt;link href=&quot;xxx&quot;&gt;，这三个标签的 src/href 可以加载其他域的资源，不受同源策略影响。 因此，这使得这三个标签可以做一些特殊的事情。 &lt;img&gt; 可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。出了能跨域之外，&lt;img&gt; 几乎没有浏览器兼容问题，它是一个非常古老的标签。 &lt;script&gt; 和 &lt;link&gt; 可以使用 CDN，CDN 基本都是其他域的链接。 另外 &lt;script&gt; 还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。 但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。 解决跨域 - JSONP首先，有一个概念你要明白，例如访问 http://baidu.com/classindex.html的时候，服务器端就一定有一个 classindex.html 文件吗？不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。同理，&lt;script src=&quot;http://baidu.com/api.js&quot;&gt; 也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。 例如我们的网站和百度肯定不是一个域。我们需要百度提供一个接口，供我们来获取。首先，我们在自己的页面这样定义 123456&lt;script&gt; window.onload = function (data) &#123; // 这是我们跨域得到信息 console.log(data) &#125;&lt;/script&gt; 然后百度给我们提供了一个 http://baidu.com/api.js ，内容如下（之前说过，服务器可动态生成内容） 1callback(&#123;x: 100, y: 200&#125;) 最后我们在页面中加入 &lt;script src=&quot;http://baidu.com/api.js&quot;&gt;&lt;script&gt;，那么这个 js 加载之后，就会执行内容，我们就得到内容了。 解决跨域 - 服务器端设置 http header这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单很多。 123456response.setHeader("Access-Control-Allow-Origin", "http://baidu.com"); // 第二个参数填写允许跨域的域名称，不建议直接写 “*”response.setHeader("Access-Control-Allow-Headers", "X-Requested-With");response.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");// 接收跨域的 cookieresponse.setHeader("Access-Control-Allow-Credentials", "true"); 五：存储 题目：cookie 和 localStorage 有何区别 cookiecookie 本身不是用来做服务器端存储的（计算机领域有很多这种 “狗拿耗子” 的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。 使用起来也非常简单，document.cookie = ... 即可。 但是 cookie 有它致命的缺点： 存储量太小，只有 4KB 所有 HTTP 请求都带着，会影响获取资源的效率 API 简单，需要封装才能用 locationStorage 和 sessionStorage后来，HTML5 标准就带来了 sessionStorage 和 localStorage，先拿 localStorage 来说，它是专门为了浏览器端缓存而设计的。其优点有： 存储量增大到 5MB 不会带到 HTTP 请求中 API 适用于数据存储 localStorage.setItem(key, value) localStorage.getItem(key) sessionStorage 的区别就在于它是根据 session 过去时间而实现，而 localStorage 会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在 sessionStorage 中，一些不重要但是不经常设置的信息，放在 localStorage 中。 另外告诉大家一个小技巧，针对 localStorage.setItem ，使用时尽量加入到 try-catch 中，某些浏览器是金庸这个 API 的，要注意。 小结本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。]]></content>
      <categories>
        <category>BOM和DOM</category>
      </categories>
      <tags>
        <tag>BOM,DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript知识点]]></title>
    <url>%2F2018%2F06%2F14%2FJs%2F</url>
    <content type="text"><![CDATA[JavaScript 是 ECMAScript 规范的一种实现，本文重点梳理下 ECMAScript 中的常考知识点，然后就一些容易出现的题目进行解析。 知识点梳理 [TOC] 一：变量类型JavaScript是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。 ECMAScript中定义了6种原始类型： Boolean String Number Null Undefined Symbol（ES6新定义） 注意：原始类型不包含Object。 题目：类型判断用到哪些方法？ 1.typeof typeof xxx 得到的值有以下几种类型：undefined、boolean、number、string、object、function、symbol，这里需要注意三点： typeof null 结果是 object，实际这是 typeof 的一个 bug，null 是原始值，非引用类型 typeof [1, 2] 结果是 object，结果中没有 array 这一项，引用类型除了 function，其他的全部都是 object typeof symbol() 用 typeof 获取 symbol 类型的值得到的是 symbol，这是ES6新增的知识点 2.instanceof 用于实例和构造函数的对应。例如判断一个变量是否是数组，使用 typeof 无法判断，但可以使用[1, 2] instanceof Array 来判断。因为 [1, 2] 是数组，它的构造函数就是 Array。同理： 12345function Foo(name) &#123; this.name = name&#125;var foo = new Foo('bar')console.log(foo instanceof Foo) //true 题目：值类型和引用类型的区别 值类型vs引用类型 除了原始类型，ES 还有引用类型，上文提到的 typeof 识别出来的类型中，只有 object 和 function 是引用类型，其他都是值类型。 根据 JavaScript 中的变量类型传递方式，又分为值类型和引用类型，值类型包括 Boolean、String、Number、Undefined、Null，引用类型包括了 Object 类的所有，如 Date、Array、Function等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。 下面通过一个小题目，来看两者的主要区别，以及实际开发中需要注意的地方。 123456// 值类型var a = 10var b = a b = 20console.log(a) // 10console.log(b) // 20 上述代码中，a 和 b 都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子： 1234567// 引用类型var a = &#123;x: 10, y: 20&#125;var b = ab.x = 100b.y = 200console.log(a) // &#123;x: 100, y: 200&#125;console.log(b) // &#123;x: 100, y: 200&#125; 上述代码中，a 和 b 都是引用类型。在执行了 b = a 之后，修改 b 的属性值，a 的也跟着变化。因为 a 和 b 都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此 b 修改属性时，a 的值随之改动。 再借助题目进一步讲解以下。 说出下面代码的执行结果，并分析其原因 123456789101112function foo(a) &#123; a = a * 10;&#125;function bar(b) &#123; b.value = 'new';&#125;var a = 1;var b = &#123;value: 'old'&#125;;foo(a);bar(b);console.log(a); // 1console.log(b); // value: old 通过代码执行会发现： a 的值没有发生改变 而 b 的值发生了改变 这就是因为 Number 类型的 a 是按值传递的，而 Object 类型的 b 是按共享传递的。 JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这种类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值，保证过大的对象不会因为不停复制内容而造成内存的浪费。 引用类型经常会在代码中按照下面的写法使用，或者说容易不知不觉造成错误！ 123456789var obj = &#123; a: 1, b: [1, 2, 3]&#125;var a = obj.a var b = obj.bvar a = 2b.push(4)console.log(obj, a, b) 虽然 obj 本身是个引用类型的变量（对象），但是内部的 a 和 b 一个是值类型，一个是引用类型，a 的赋值不会改变 obj.a，但是 b 的操作却会反映到 obj 对象上。 二：原型和原型链JavaScript是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript的原型概念。 题目：如何理解 JavaScript 中的原型 对于这个问题，可以从下面这几个要点来理解和回答，下面几条必须记住并且理解 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（null除外） 所有的引用类型（数组、对象、函数），都有一个__proto__属性，属性值是一个普通的对象 所有的函数，都有一个 prototype 属性，属性值也是一个普通的对象 所有的引用类型（数组、对象、函数），__proto__属性值指向它的构造函数 prototype 属性值 通过代码解释一下，大家可自行运行代码，看结果。 123456789101112131415161718// 要点一：自由扩展属性var obj = &#123;&#125;;obj.a = 100;var arr = [];arr.a = 100;function fn () &#123;&#125;fn.a = 100;// 要点二：__proto__console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__);// 要点三：函数有 prototypeconsole.log(fn.prototype)// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值console.log(obj.__proto__ === Object.prototype) 原型先写一个简单的代码示例。 123456789101112131415// 构造函数function Foo(name, age) &#123; this.name = name&#125;Foo.prototype.alertName = function () &#123; alert(this.name)&#125;// 创建实例var f = new Foo('zhangsan')f.printName = function () &#123; console.log(this.name)&#125;// 测试f.printName()f.alertName() 执行 printName 时很好理解，但是执行 alertName 时发生了什么？这里再记住一个重点 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 __proto__（即它的构造函数的 prototype）中寻找，因此 f.alertName 就会找到 Foo.prototyoe.alertName。 那么如何判断这个属性是不是对象本身的属性呢？使用 hasOwnProperty，常用的地方是遍历一个对象的时候。 1234567var item for (item in f) &#123; // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性 if (f.hasOwnProperty(item)) &#123; console.log(item) &#125;&#125; 题目：如何理解JS中的原型链 原型链还是接着上面的示例，如果执行 f.toString() 时，又发生了什么？ 123456// 省略N行// 测试f.printName()f.alertName()f.toString() 因为 f 本身没有 toString()，并且 f.__proto__（即Foo.prototype）中也没有 toString。这个问题还是得拿出刚才那句话——当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的 prototype）中寻找。 如果在f.__proto__中没有找到 toString，那么就继续去 f.__proto__.__proto__中寻找，因为f.__proto__就是一个普通的对象而已。 f.__proto__即 Foo.prototype，没有找到 toString，继续往上找 f.__proto__.__proto__即 Foo.prototype.__proto__。Foo.prototype 就是一个普通的对象，因此 Foo.prototype.__proto__就是 Object.prototype，在这里可以找到 toString 因此， f.toString 最终对应到了 Object.prototype.toString 这样一直往上找，你会发现一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回 undefined。最上层是什么——Object.prototype.__proto__ === null 原型链中的this所有从原型或更高级原型中得到、执行的方法，其中的 this 在执行时，就指向了当前这个触发事件执行的对象。因此 printName 和 alertName 中的 this 都是 f。 三：作用域和闭包作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目： 题目：现在有个HTML片段，要求编写代码，点击编号为几的链接就 alert 弹出其编号 1234567&lt;ul&gt; &lt;li&gt;编号1，点击我请弹出1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; 一般不知道这个题目用闭包的话，会写出下面的代码： 12345678var list = document.getElementsByTagName('li');for (var i = 0; i &lt; list.length; i++) &#123; list[i].addEventListener('click', function(i) &#123; return function() &#123; alert(i + 1) &#125; &#125;(i), true)&#125; 要理解闭包，就需要我们从 执行上下文 开始讲起。 执行上下文先讲一个关于 变量提升 的知识点，面试中可能会遇见下面的问题，很多候选人都回答错误： 题目：说出下面执行的结果 12345678910111213console.log(a) // undefinedvar a = 100fn('zhangsan') // 'zhangsan' 20function fn(name) &#123; age = 20 console.log(name, age) var age&#125;console.log(b); // 这里报错// Uncaught ReferenceError: b is not definedb = 100; 在一段 JS 脚本（即一个&lt;script&gt;标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 全局执行上下文 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为 dundefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。 我们来看一下上面的题目，为什么 a 是 undefined，而 b 却报错了，实际 JS 在代码执行之前，要全文解析，发现 var a ，知道有个 a 的变量，存入了执行上下文，而 b 没有找到 var 关键字，这时候没有在执行上下文提前占位，所以代码执行的时候，提前报到的 a 是有记录的，只不过值暂时还没有赋值，即为 undefined，而 b 在执行上下文没有找到，自然会报错（没有找到 b 的引用）。 另外，一个函数在执行之前，也会创建一个 函数执行上下文 环境，跟 全局上下文 差不多，不过 函数执行上下文 中会多出 this 、arguments 和函数的参数。参数和 arguments 好理解，这里的 this 咱们需要专门讲解。 总结一下： 范围：一段&lt;script&gt;、js文件或者一个函数 全局上下文：变量定义，函数声明 函数上下文：变量定义，函数声明，this，arguments this先搞明白一个很重要的概念——this的值是在执行的时候才能确认，定义的时候不能确认！为什么呢——因为 this 是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子： 12345678910var a = &#123; name: 'A', fn: function () &#123; console.log(this.name) &#125;&#125;a.fn() // this === aa.fn.call(&#123;name: 'B'&#125;) // this === &#123;name: 'B'&#125;var fn1 = a.fnfn1() // this === window this 执行会有不同，主要集中在这几个场景中 作为构造函数执行，构造函数中 作为对象属性执行，上述代码中 a.fn() 作为普通函数执行，上述代码中 fn1() 用于 call、apply、bind，上述代码中 a.fn.call({name: ‘B’}) 下面再来讲解下什么是作用域和作用域链，作用域和作用域链也是常考的题目。 题目：如何理解 JS 的作用域和作用域链 作用域ES6 之前 JS 没有块级作用域。例如 1234if (true) &#123; var name = 'zhangsan'&#125;console.log(name) 从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的 name 就被暴露出去了，因此， JS 没有块级作用域，只有全局作用域和函数作用域。 1234567var a = 100function fn() &#123; var a = 200 console.log('fn', a)&#125;console.log('global', a)fn() 全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。 1234// 张三写的代码中var data = &#123;a: 100&#125;// 李四写的代码中var data = &#123;x: true&#125; 这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在(function(){....})()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。 作用域链首先认识一下什么叫做 自由变量。如下代码中， console.log(a)要得到 a 变量，但是在当前的作用域中没有定义 a （可对比一下 b）。当前作用域没有定义的变量，这称为 自由变量。自由变量如何得到——向父级作用域寻找。 1234567var a = 100function fn() &#123; var b = 200 console.log(a) console.log(b)&#125;fn() 如果父级也没有呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。 123456789101112var a = 100function F1() &#123; var b = 200 function F2() &#123; var c = 300 console.log(a) // 自由变量，顺着作用域链向父作用域找 console.log(b) // 自由变量，顺着作用域链向父作用域找 console.log(c) // 本作用域的变量 &#125; F2()&#125;F1() 闭包讲完这些内容，我们再来看一个例子，通过例子来理解闭包。 123456789function F1() &#123; var a = 100 return function () &#123; console.log(a) &#125;&#125;var f1 = F1()var a = 200f1() 自由变量将从作用域链中去寻找，但是 依据的是函数定义时的作用域链，而不是函数执行时，以上这个例子就是闭包。闭包主要有两个应用场景： 函数作为返回值，上面的例子就是 函数作为参数传递，看以下例子 123456789101112function F1() &#123; var a = 100 return function () &#123; console.log(a) &#125;&#125;function F2(f1) &#123; var a = 200 console.log(f1())&#125;var f1 = F1()F2(f1) 至此，对应着 作用域和闭包 这部分一开始的点击弹出 alert 的代码再看闭包，就很好理解了。 四：异步同步和异步也是面试中常考的内容，下面来讲解同步和异步的区别。 同步 vs 异步先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印 100, 1秒钟之后打印 200，最后打印 300.但是实际运行根本不是那么回事。 12345console.log(100)setTimeout(function () &#123; console.log(200)&#125;, 1000)console.log(300) 再对比以下程序。先打印 100，再弹出 200（等待用户确认），最后打印 300。这个运行效果就符合预期要求。 123console.log(100)alert(200) // 1秒钟之后点击确认console.log(300) 这俩到底有何区别——第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 异步（后面这个叫做 同步），即 不会阻塞后面程序的运行。 异步和单线程JS 需要异步的根本原因就是 JS 是单线程运行的，即在同一时间只能做一件事，不能“一心二用”。 一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了。异步的话，就好很多了， 5 秒钟等待就等待了，其他事情不耽误做，至于那 5 秒钟是网速太慢，不是因为 JS 的原因。 讲到单线程，我们再来看个真题： 题目：讲解下面代码的执行过程和结果 1234567var a = true;setTimeout(function () &#123; a = false;&#125;, 100)while (a) &#123; console.log('while执行了')&#125; 这是一个很有迷惑性的题目，不少人认为 100ms 之后，由于 a 变成了 false，所以 while 就中止了，实际不是这样，因为 JS 是单线程的，所以进入 while 循环之后，没有 时间（线程）去跑定时器了，所以这个代码跑起来是个死循环。 前端异步的场景 定时 setTimeout、setInterval 网络请求，如 Ajax、&lt;img&gt; 加载 Ajax 代码示例 12345console.log('start')$.get('./data1.json', function (data1) &#123; console.log(data1)&#125;)cosnole.log('end') img 代码示例（常用于打点统计） 123456789console.log('start')var img = document.createElemenr('img')// 或者 img = new Image()img.onload = function () &#123; console.log('loaded') img.onload = null&#125;img.src = './xxx.jpg'console.log('end') 五：ES6/7 新标准的考查 题目：ES6 箭头函数中的 this 和普通函数中的有什么不同 箭头函数箭头函数是 ES6 中心的函数定义形式，function name(arg1, arg2) {...}可以使用(arg1, arg2) =&gt; {...}来定义。示例如下： 123456789101112// 普通函数var arr = [1, 2, 3]arr.map(function (item) &#123; console.log(index) return item + 1&#125;)// ES6 箭头函数const arr = [1, 2, 3]arr.map((item, index) =&gt; &#123; console.log(index) return item + 1&#125;) 箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中 this 是全局变量的问题，看如下代码： 123456789101112131415function fn() &#123; console.log('real', this) // &#123;a: 100&#125; 该作用域下的 this 的真实的值 var arr = [1, 2, 3] // 普通 JS arr.map(function (item) &#123; console.log('js', this) // window 普通的函数。这里打印出来的是全局变量 return item + 1 &#125;) // 箭头函数 arr.map(item =&gt; &#123; console.log('es6', this) // &#123;a: 100&#125; 箭头函数，这里打印的就是父作用域的 this return item + 1 &#125;)&#125;fn.call(&#123;a: 100&#125;) 题目：ES6 模块化如何使用？ ModuleES6 中模块化语法更加简洁，直接看示例。 如果只是输出一个唯一的对象，使用 export default即可，代码如下 1234567// 创建 utill.js 文件，内容如export default &#123; a: 100&#125;// 创建 index.js 文件，内容如import obj from './utill.js'console.log(obj) 如果需要输出多个对象，就不能用 default 了，并且 import 时要加 {…}，代码如下： 1234567891011// 创建 util2.js 文件，内容如export function fn1() &#123; alert('fn1')&#125;export function fn2() &#123; alert('fn2')&#125;// 创建 index.js 文件，内容如import &#123; fn1, fn2 &#125; from './util2.js'fn1()fn2() 题目：ES6 class 和普通构造函数的区别 classclass 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6。ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如： JS构造函数的写法 123456789function MathHandle(x, y) &#123; this.x = x; this.y = y;&#125;MathHandle.prototype.add = function () &#123; return this.x + this.y;&#125;var m = new MathHandle(1, 2);console.log(m.add()) 用 ES6 class 的写法 1234567891011class MathHandle &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; add() &#123; return this.x + this.y &#125;&#125;const m = new MathHandle(1, 2)console.log(m.add()) 注意以下几点，全都是关于 class 语法的： class 是一种新的语法形式，是 class Name {...}这种形式，和函数的写法完全不一样 两者相比，构造函数函数体的内容要放在 class 中的 constructor函数中，constructor即构造器，初始化实例时默认执行 class 中函数的写法是 add() {...}这种形式，并没有 function关键字 使用 class 来实现集成就更加简单了，至少比构造函数实现继承简单很多。看下面例子 JS 构造函数实现继承 123456789101112131415// 动物function Animal() &#123; this.eat = function () &#123; console.log('animal eat') &#125;&#125;// 狗function Dog() &#123; this.bark = function () &#123; console.log('dog bark') &#125;&#125;Dog.prototype = new Animal()// 哈士奇var hashiqi = new Dog() ES6 class 实现继承 1234567891011121314151617181920class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat`) &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name) this.name = name &#125; say() &#123; console.log(`$&#123;this.name&#125; say`) &#125;&#125;const dog = new Dog('哈士奇')dog.say()dog.eat() 注意以下两点 使用 extends 即可实现继承，更加符合经典面向对象语言的写法，如 Java 子类的 constructor 一定要执行 super()，以调用父类的 constructor 题目：ES6 中新增的数据类型有哪些？ Set 和 MapSet 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方： Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复 Map 类似于对象，但普通对象的 key 必须是字符串或数字，而 Map 的 key 可以是任何数据类型 SetSet 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过 add 添加元素，元素不能重复，重复的会被忽略。 12345678910// 例 1const set = new Set([1, 2, 3, 4, 4])console.log(set) // Set(4) &#123;1, 2, 3, 4&#125;// 例 2const set = new Set();[2, 3, 5, 4, 5, 8, 8].forEach(item =&gt; set.add(item));for (let item of set) &#123; console.log(item);&#125;// 2 3 5 4 8 Set 实例的属性和方法有 size： 获取元素数量 add(value)： 添加元素，返回 Set 实例本身 delete(value)： 删除元素，返回一个布尔值，表示删除是否成功 has(value)： 返回一个布尔值，表示该值是否是 Set 实例的元素 clear()： 清除所有元素，没有返回值 1234567891011121314const s = new Set();s.add(1).add(2).add(2); // 添加元素s.size // 2s.has(1); // trues.has(2); // trues.has(3); // falses.delete(2);s.has(2); // falses.clear();console.log(s); // Set(0) &#123;&#125; Set 实例的遍历，可使用如下方法 keys()： 返回键名的遍历器 values()：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys() 和 values() 返回结果一致 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 1234567891011121314151617181920212223let set = new Set(['aaa', 'bbb', 'ccc']);for (let item of set.keys()) &#123; console.log(item);&#125;// aaa// bbb// cccfor (let item of set.values()) &#123; console.log(item);&#125;// aaa// bbb// cccfor (let item of set.entries()) &#123; console.log(item);&#125;// ['aaa', 'aaa']// ['bbb', 'bbb']// ['ccc', 'ccc']set.forEach((value, key) =&gt; console.log(key + ':' + value))// aaa : aaa// bbb : bbb// ccc : ccc MapMap 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。 123456789const map = new Map();const obj = &#123;p: 'Hello World'&#125;;map.set(obj, 'OK')map.get(obj) // 'OK'map.has(obj) // truemap.delete(obj) // truemap.has(obj) // false 需要使用 new Map() 初始化一个实例，下面代码中 set、get、has、delete 顾名即可思义。其中，map.set(obj, &#39;OK&#39;) 就是用对象作为的 kye（不光可以是对象，任何数据类型都可以），并且后面通过 map.get(obj) 正确获取了。 Map 实例的属性和方法如下： size： 获取成员的数量 set：设置成员 key 和 value get： 获取成员属性值 has： 判断成员是否存在 delete： 删除成员 clear： 清空所有 1234567891011121314const map = new Map();map.set('aaa', 100);map.set('bbb', 200);map.size // 2map.get('aaa') // 100map.has('aaa') // truemap.delete('aaa')map.has('aaa') // falsemap.clear() Map 实例的遍历方法有： keys()： 返回键名的遍历器 values()： 返回键值的遍历器 entries()： 返回所有成员的遍历器 forEach()： 遍历 Map 的所有成员 12345678910111213141516171819202122const map = new Map();map.set('aaa', 100);map.set('bbb', 200);for (let key of map.keys()) &#123; console.log(key);&#125;// 'aaa'// 'bbb'for (let value of map.values()) &#123; console.log(value);&#125;// 100// 200// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// aaa 100// bbb 200 PromisePromise 是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。 Promise 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。 简单归纳下 Promise： 三个状态、两个过程、一个方法，快速记忆方法： 3-2-1 三个状态：pending、fulfilled、rejected 两个过程： pending→fulfilled（resolve） pending→rejected（reject） 一个方法： then 当然还有其他概念，如 catch、Promise.all/race，这里就不展开了。 关于 ES6/7 的考查内容还有很多，这里就不逐一介绍了，如果想继续深入学习，可以点击查看《ES6入门》 小结 本文主要总结了 ES 基础语法中面试经常考查的知识点，包括之前就考查较多的原型、异步、作用域，以及 ES6 的一些新内容，这些知识点希望大家都要掌握。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解http]]></title>
    <url>%2F2018%2F06%2F14%2Fhttp%2F</url>
    <content type="text"><![CDATA[开始 输入URL打开网页 AJAX获取数据 img标签加载图片 ….. 输入url,按回车后redirect(浏览器记录判断跳转到新的地址了) 看App cache是否缓存了 DNS解析,查找到对应的服务器的ip地址 TCP链接,三次握手 发送请求和接收响应 网络协议分层 低三层 物理层:主要作用是定义物理设备如何传输数据(硬件相关:网卡 端口 网线 光缆….) 数据链路层:在通信的实体间建立数据链路连接(01 基本的数据传输) 网络层:为数据在结点之间传输创建逻辑链路(如寻找服务器的逻辑地址) 传输层 向用户提供端到端(End-to-End)的服务 传输层向高层屏蔽了下层数据通信的细节 应用层 为应用软件提供了很多服务 构建于TCP协议之上 屏蔽网络传输相关的细节 ……….未完待续]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技术 博客文章、书籍 积累]]></title>
    <url>%2F2018%2F06%2F10%2Fnecessary%2F</url>
    <content type="text"><![CDATA[总结 前端资源分享-只为更好前端 前端模块化（CommonJs,AMD和CMD) HTML和CSS 前端工程师必备实用网站 Box Shadow(阴影)-Css3演示 面试 前端面试宝典 原型链示意图]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>必备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-HTML知识点]]></title>
    <url>%2F2018%2F06%2F09%2FCSS-HTML%2F</url>
    <content type="text"><![CDATA[CSS 和 HTML 是网页开发中布局相关的组成部分，涉及的内容比较多和杂乱，本小节重点介绍下常考的知识点。 知识点梳理 一：选择器的权重和优先级CSS 选择器有很多，不同的选择器的权重和优先级不一样，对于一个元素，如果存在多个选择器，那么就需要根据权重来计算其优先级。 权重分为四级，分别是： 代表内联样式，如 style=&quot;xxx&quot;，权重为 1000 代表 ID 选择器，如 #content，权重为 100 代表类、伪类和属性选择器，如 .content、:hover、[attribute]，权重为 10 代表元素选择器和伪元素选择器，如 div、p，权重为 1 需要注意的是：通用选择器（*）、子选择器（&gt;）和相邻选择器（+）并不在这四个等级中，所以他们的权重都为 0 。权重值大的选择器其优先级也高，相同权重的优先级又遵循后定义覆盖前面定义的情况。 二：盒模型什么是 “盒子”初学 CSS 的小伙伴，一开始学 CSS 基础知识的时候一定学过 padding、margin和border，即内边距、外边距和边框。它们三者就构成了一个 “盒子”。就像我们收到的快递，本来买了一部小小的手机，收到的却是那么大一个盒子。因为手机的包装盒和手机之间有间隔层（内边距），手机盒子有厚度（边框），盒子和快递箱子之间还有一层泡沫板（外边距）。 题目：盒子模型的宽度如何计算 固定宽度的盒子1234&lt;div style="padding:10px; border:5px solid blue; margin: 10px; width:300px;"&gt; 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》， 文章言简意赅的介绍的浏览器的工作过程，web前端&lt;/div&gt; 如上代码，放在浏览器运行，发现文字内容的宽度刚好是 300px，也就是我们设置的宽度。 因此， 在盒子模型中，我们设置的宽度都是内容的宽度，不是整个盒子的宽度。而整个盒子的宽度是：（内容宽度 + border 宽度 + padding 宽度 + margin 宽度）之和。这样我们改四个钟的其中一个，都会导致盒子宽度的改变。这对我们来说不友好。 充满父容器的盒子默认情况下，div 是 display:block，宽度会充满整个父容器。但是别忘记，这个 div 是个盒子模型，它的整个宽度包括（内容宽度 + border 宽度 + padding 宽度 + margin 宽度），整个宽度充满父容器。 问题就在这里。如果父容器宽度不变，我们手动增大 margin、border 和padding 其中一项的宽度值，都会导致内容宽度的减少。极端情况下，如果内容的宽度压缩到不能再压缩了（例如一个字的宽度），那么浏览器会强迫增加父容器的宽度。这可不是我们想要看到的。 包裹内容的盒子这种情况下比较简单，内容的宽度按照内容计算，盒子的宽度将在内容宽度的基础上再增加（padding 宽度 + border 宽度 + margin 宽度）之和。 box-sizing:border-box前面提到，为盒子模型设置宽度，结果只是设置了内容的宽度，这个不合理。如何解决这一问题？答案就是为盒子指定样式：box-sizing；border-box。 1234&lt;div style="padding:10px; border:5px solid blue; margin: 10px; width:300px; box-sizing:border-box"&gt; 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》， 文章言简意赅的介绍的浏览器的工作过程，web前端&lt;/div&gt; 以上代码，为 div 设置了 box-sizing:border-box之后，300px 的 宽度是内容 + padding + 边框的宽度（不包括 margin），这样就比较符合我们的实际要求了。建议大家在为系统写 CSS 的时候，第一个样式是： 1* &#123;box-sizing: border-box&#125; 大名鼎鼎的 Bootstrap 也把 box-sizing:border-box 加入到它的 * 选择器中，我们为什么不这样做呢？ 纵向 margin 重叠这里提到 margin，那就不得不提一下 margin 的这一特性——纵向重叠。如&lt;p&gt;的纵向 margin 是 16px，那么两个&lt;p&gt;之间纵向的距离是多少？按常理来说应该是 16 + 16 = 32px，但是答案仍然是 16px。因为纵向的 margin 是会重叠的，如果两个不一样大的话，大的会把小的 “吃掉”。 三：浮动 floatfloat 用于网页布局比较多，使用起来也比较简单，这里总结了一些比较重要、需要注意的知识点，供大家参考。 误解和误用float 被设计出来的初衷是用于 文字环绕效果，即一个图片一段文字，图片 float:left之后，文字会环绕图片。 但是，后来大家发现结合 float + div 可以实现之前通过 table实现的网页布局，因此就被 “误用” 于网页布局了。 题目：为何 float 会导致父元素塌陷？ 破坏性float 的 破坏性——float 破坏了父标签的原本结构，使得父标签出现了坍塌现象。导致这一现象的最根本原因在于： 被设置了 float 的元素会脱离文档流。其根本原因在于 float 的设计初衷是解决文字环绕图片的问题。大家要记住 float 的这个影响。 包裹性包裹性也是 float 的一个非常重要的特性，大家用 float 时一定要熟知这一特性。咱们还是先从一个小例子看起： 如上图，普通的 div 如果没有设置宽度，它会撑满整个屏幕，在之前的盒子模型那一节也讲到过。而如果给 div 增加 float:left 之后，它突然变得紧凑了，宽度发生了变化，把内容中的三个字包裹了——这就是包裹性。为 div 设置了 float 之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。 注意，此时 div 虽然体现了包裹性，但是它的 display 样式是没有变化的，还是display:block。 float 为什么要具有包裹性？其实答案还是得从 float 的设计初衷来寻找，float 是被设计用于实现文字环绕效果的。文字环绕图片比较好理解，但是如果想要让文字环绕一个 div 呢？此时 div 不被 “包裹” 起来的话，就无法实现环绕效果了。 清空格float 还有一个大家可能不是很熟悉的特性——清空格。按照惯例，咱还是先举例说明（自己准备图片,查看添加 float:left 前后的效果）。 123456&lt;div style="border: 2px solid blue; padding:3px; float:left;"&gt; &lt;img src="image/1.png"/&gt; &lt;img src="image/2.png"/&gt; &lt;img src="image/3.png"/&gt; &lt;img src="image/4.png"/&gt;&lt;/div&gt; 在没有添加 float:left 之前，正常的 img 中间是会有空格的，因为多个 img 标签会换行，而浏览器识别换行为空格，这也是很正常的。 在添加了 float:left 之后，就使得 img 之间没有了空格，4 个 img 紧紧挨着。 如果大家之前没注意，现在想想之前写过的程序，是不是有这个特性。为什么 float 适合用于网页排版（俗称 “砌砖头”）？就是因为 float 排版出来的网页严丝合缝，中间连个苍蝇都飞不进去。 “清空格” 这一特性的根本原因是 float 会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没了关系，它就尽量往一边靠拢，能靠多近就靠多近，这就是清空格的本质。 题目：手写 clearfix clearfix清除浮动的影响，一般使用的样式如下，统称 clearfix 代码。所有 float 元素的父容器，一般情况下都应该加 clearfix 这个 class。 12345678.clearfix:after &#123; content: ''; display: table; clear: both;&#125;.clearfix &#123; *zoom: 1; /* 兼容 IE 低版本 */&#125; 1234&lt;div class="clearfix"&gt; &lt;img src="image/1.png" style="float: left"/&gt; &lt;img src="image/2.png" style="float: left"/&gt;&lt;/div&gt; 小结float 的设计初衷是解决文字环绕图片的问题，后来误打误撞用于做布局，因此有许多不合适或者需要注意的地方，上文基本都降到了需要的知识点。如果刚开始接触 float 的同学，学完上面的基础知识后，还应该做一些练习实战一下——经典的 “圣杯布局” 和 “双飞翼布局”。这里就不再展开讲了，网上资料非常多，例如 浅谈面试中常考的两种经典布局。 四：定位 positionposition 用于网页元素的定位，可设置 static/relative/absolute/fixed 这些值，其中 static 是默认值，不用介绍。 relative相对定位 relative 可以用一个例子很轻松的演示出来。例如我们写 4 个 &lt;p&gt;，出来的样子大家不用看也能知道。 1234&lt;p&gt;第一段文字&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;p&gt;第三段文字&lt;/p&gt;&lt;p&gt;第四段文字&lt;/p&gt; 然后我们在第三个 &lt;p&gt; 上面，加上 position:relative 并且设置 left 和 top 值，看这个 &lt;p&gt; 有什么变化 1234&lt;p&gt;第一段文字&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;p style="position:relative; top: 10px; left: 10px"&gt;第三段文字&lt;/p&gt;&lt;p&gt;第四段文字&lt;/p&gt; 通过浏览器运行的结果，大家应该要识别出两个信息（相信大部分人会忽略第二个信息） 第三个&lt;p&gt;发生了位置变化，分别向右向下移动了 10px 其他的三个&lt;p&gt;位置没有发生变化，这一点也很重要 可见，relative 会导致自身位置的相对变化，而不会影响其他元素的位置、大小。这是 relative 的要点之一。还有第二个要点，就是 relative 产生一个新的定位上下文。 absolute还是先写一个基本的 demo 1234&lt;p&gt;第一段文字&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;p style="background: yellow"&gt;第三段文字&lt;/p&gt;&lt;p&gt;第四段文字&lt;/p&gt; 然后，我们把第三个&lt;p&gt;改为position:absolute;，看看会发生什么变化。从浏览器运行的结果中，我们能看出几点信息： absolute 元素脱离了文档结构。和 relative 不同，其他三个元素的位置重新排列了。只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌。（此时你应该能立刻想起来，float 元素也会脱离文档结构。） absolute 元素具有 “包裹性”。之前&lt;p&gt;的宽度是撑满整个屏幕的，而此时&lt;p&gt;的宽度刚好是内容的宽度 absolute 元素具有 “跟随性”。虽然 absolute 元素脱离了文档结构，但是它的位置并没有发生变化，还是老老实实地待在它原本的位置，因为我们此时没有设置 top、left 的值 absolute 元素会悬浮在页面上方，会遮挡住下方的页面内容 最后，通过给 absolute 元素设置 top、left 值，可自定义其内容，这个都是平时比较常用的。这里需要注意的是，设置了 top、left 值时，元素是相对于最近的定位上下文来定位的，而不是相对于浏览器定位。 fixed其实 fixed 和 absolute 是一样的，唯一的区别在于 :absolute 元素是根据最近的定位上下文确定位置，而 fixed 根据 window（或者 iframe）确定位置。 题目：relative、absolute 和 fixed 分别依据谁来定位？ 定位上下文relative 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。 fixed 元素的定位是相对于 window（或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。 absolute 的定位相对于前两者要复杂许多。如果 absolute 设置了 top、left，浏览器会根据什么区确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了position:relative/absolute/fixed的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。 五：flex 布局布局的传统解决方案基于盒模型，依赖display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中（下文会专门讲解）就不容易实现。在目前主流的移动端页面中，使用 flex 布局能更好地完成需求，因此 flex 布局的知识是必须要掌握的。 基本使用任何一个容器都可以使用 flex 布局，代码也很简单（请到浏览器查看结果）。 12345678910111213141516&lt;style type="text/css"&gt; .container &#123; display: flex; &#125; .item &#123; border: 1px solid #000; flex: 1; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="item"&gt;aaa&lt;/div&gt; &lt;div class="item" style="flex: 2"&gt;bbb&lt;/div&gt; &lt;div class="item"&gt;ccc&lt;/div&gt; &lt;div class="item"&gt;ddd&lt;/div&gt;&lt;/div&gt; 注意，第三个&lt;div&gt;的flex:2，其他的&lt;div&gt;的flex:1，这样第二个&lt;div&gt;的宽度就是其他的&lt;div&gt;的两倍。 设计原理设置了display:flex的元素，我们称为 “容器”（flex container），其所有的子节点我们称为 “成员”（flex item）。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 将以上文字和图片结合起来，再详细看一遍，这样就能理解 flex 的设计原理，才能更好地实际使用。 设置主轴的方向flex-direction可决定主轴的方向，有四个可选项： row（默认值）：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 123.box &#123; flex-direction: column-reverse | column | row | row-reverse;&#125; 以上代码设置的主轴方向，将以此对应下图： 设置主轴的对齐方式justify-content属性定义了项目在主轴上的对齐方式，值如下： flex-start（默认值）：向主轴开始方向对齐 flex-end：向主轴结束方向对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 123.box &#123; justify-content: flex-start | flex-end | center |space-between | space-around;&#125; 交叉轴的对齐方式align-item属性定义项目在交叉轴上如何对齐，值如下： flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。 123.box &#123; align-item: flex-start | flex-end | center | baseline | stretch;&#125; 六：如何实现居中对齐？ 题目：如何实现水平居中 水平居中inline 元素用text-align:center;即可，如下： 123.container &#123; text-align: center;&#125; block 元素可使用margin: auto;，PC 时代的很多网站都这么搞。 1234567.container &#123; text-align: center;&#125;.item &#123; width: 1000px; margin: auto;&#125; 绝对定位元素可结合left和margin实现，但是必须知道宽度。 1234567891011.container &#123; position: relative; width: 500px;&#125;.item &#123; width: 300px; height: 100px; position: absolute; left: 50%; margin: -150px;&#125; 题目：如何实现垂直居中？ inline 元素可以设置line-height的值等于height值，如单行文字垂直居中： 1234.container &#123; height: 50px; line-height: 50px;&#125; 绝对定位元素，可结合left和margin实现，但是必须知道尺寸。 优点：兼容性好 缺点：需要提前知道尺寸 12345678910111213.container &#123; position: relative; height: 200px;&#125;.item &#123; width: 80px; height: 40px; position: absolute; left: 50%; top: 50%; margin-top: -20px; margin-left: -40px;&#125; 绝对定位可结合transform实现居中。 优点：不需要提前知道尺寸 缺点：兼容性不好 123456789101112.container &#123; position: relative; height: 200px;&#125;.item &#123; width: 80px; height: 40px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; 绝对定位结合margin: auto，不需要提前知道尺寸，兼容性好。 1234567891011121314.container &#123; position: relative; height: 300px;&#125;.item &#123; width: 100px; height: 50px; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;&#125; 其他的解决方案还有，不过没必要掌握太多，能说出上文的这几个解决方案即可。 七：理解语义化 题目：如何理解 HTML 语义化？ 所谓 “语义” 就是为了更容易读懂，这要分两部分： 让人（写程序、读程序）更易读懂 让机器（浏览器、搜索引擎）更易读懂 让人更易读懂对于人来说，代码可读性、语义化就是一个非常广泛的概念了，例如定义 JS 变量的时候使用更易读懂的名称，定义 CSS class 的时候也一样，例如length、list等，而不是使用a b这种谁都看不懂的名称。 不过我们平常考查的 “语义化” 并不会考查这么广义、这么泛的问题，而是考查 HTML 的语义化，是为了更好地让机器读懂 HTML。 让机器更易读懂HTML 符合 XML 标准，但又和 XML 不一样——HTML 不允许像 XML 那样自定义标签名称，HTML 有自己规定的标签名称。问题就在这里——HTML 为何要自己规定那么多标签名称呢，例如p div h1 ul等——就是为了语义化。其实，如果你精通 CSS 的话，你完全可以全部用&lt;div&gt;标签来实现所有的网页效果，其他的p h1 ul 等标签可以一个都不用。但是我们不推荐这么做，这样做就失去了 HTML 语义化的意义。 拿搜索引擎来说，爬虫下载到我们网页的 HTML 代码，它如何更好的去理解网页的内容呢？就是根据 HTML 既定的标签，h1标签就代表是标题；p里面的就是段落详细内容，权重肯定没有标题高；ul里面就是列表；strong就是加粗的强调的内容。如果我们不按照 HTML 语义化来写，全部都用&lt;div&gt;标签，那搜索引擎将很难理解我们网页的内容。 为了加强 HTML 语义化，HTML5 标准中又增加了header section artical等标签。因此，书写 HTML 时，语义化是非常重要的，否则 W3C 也没必要辛辛苦苦制定出这些标准来。 八：CSS3 动画CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。 首先，使用@keyframes定义一个动画，名称为testAnimation，如下代码，通过百分比来设置不同的 CSS 样式，规定动画的变化。所有的动画变化都可以这么定义出来。 12345678@keyframes testAnimation&#123; 0% &#123;background: red; left:0; top:0;&#125; 25% &#123;background: yellow; left:200px; top:0;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0; top:200px;&#125; 100% &#123;background: red; left:0; top:0;&#125;&#125; 然后，针对一个 CSS 选择器来设置动画，例如针对div元素设置动画，如下 1234567div &#123; width: 100px; height: 50px; position: absolute; animation-name: testAnimation; animation-duration: 5s;&#125; animation-name对应到动画名称，animation-duration是动画时长，还有其他属性： animation-timing-function：规定动画的速度曲线，默认是ease animation-delay：规定动画何时开始，默认是 0 animation-iterationcount：规定动画被播放的次数，默认是 1 animation-direction：规定动画是否在下一周期逆向地播放，默认是 normal animation-play-state：规定动画是否正在运行或暂停，默认是 running animation-fill-mode：规定动画执行之前和之后如何给动画的目标应用，默认是none，保留在最后一帧可以用forwards 题目：CSS 的 transition和animation有何区别 首先transition和animation都可以做动效，从语义上来理解，transition是过渡，由一个状态过渡到另一个状态，比如高度100px过渡到200px；而animation是动画，即更专业做动效的，animation有帧的概念，可以设置关键帧keyframe，一个动画可以由多个关键帧多个状态过渡组成。 九：重绘和回流重绘和回流也是面试经常考的题目，也是性能优化当中应该注意的点，下面简单介绍下。 重绘：指的是当页面中的元素不脱离文档流，而简单地进行样式的变化，比如修改颜色、背景等，浏览器重新绘制样式 回流：指的是处于文档流中 DOM 的尺寸大小，位置或者某些属性发生变化时，导致浏览器重新渲染部分或全部文档的情况 相比之下，回流要比重绘消耗性能开支更大。另外，一些属性的读取也会引起回流，比如读取某个 DOM 的高度和宽度，或者使用getComputedStyle方法。在写代码的时候要避免回流和重绘。比如在笔试中可能会遇见下面的题目： 题目：找出下面代码的优化点，并且优化它 12345var data = ['string1', 'string2', 'string3'];for (var i = 0; i &lt; data.length; i++) &#123; var dom = document.getElementById('list'); dom.innerHTML += '&lt;li&gt;' + data[i] + '&lt;/li&gt;';&#125; 上面的代码在循环中每次都获取dom，然后对其内部的 HTML 进行累加li，每次都会操作 DOM 结构，可以改成使用documentFragment或者先遍历组成 HTML 的字符串，最后操作一次 innerHTML。 小结本小节总结了 CSS 和 HTML 常考的知识点，包括 CSS 中比较重要的定位、布局的知识，也介绍了 CSS3 的知识点概念和题目，以及 HTML 的语义化。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
